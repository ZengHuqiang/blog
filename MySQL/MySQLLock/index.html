<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> MySQL锁模块 · 空空白的博客</title><meta name="description" content="MySQL锁模块 - kongkongbai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.kongkongbai.com/atom.xml" title="空空白的博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="空空白的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/categories/" target="_self">CATEGORY</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/achjqz" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/friends/" target="_self">FRIENDS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">MySQL锁模块</h1><div class="post-info">May 13, 2020<a class="tag-title" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">#数据库</a></div><div class="post-content"><h4 id="0-常见问题"><a href="#0-常见问题" class="headerlink" title="0.常见问题"></a>0.常见问题</h4><ul>
<li>MyISAM与InnoDB关于锁方面的区别是什么？</li>
<li>数据库事务的四大特性</li>
<li>事务隔离级别以及各级别下的并发访问问题</li>
<li>InnoDB可重复度隔离级别下如何避免幻读</li>
<li>RC、RR级别下的InnoDB的非阻塞读如何实现</li>
</ul>
<h3 id="1-MyISAM与InnoDB关于锁方面的区别"><a href="#1-MyISAM与InnoDB关于锁方面的区别" class="headerlink" title="1.MyISAM与InnoDB关于锁方面的区别"></a>1.MyISAM与InnoDB关于锁方面的区别</h3><p><a href="https://blog.csdn.net/xifeijian/article/details/20313977#t10" target="_blank" rel="noopener">（参考博客）！非常详细</a></p>
<ul>
<li>MyISAM默认用的表级锁，不支持行级锁</li>
<li>InnoDB默认用的行级锁，也支持表级锁</li>
</ul>
<h4 id="1-1MyISAM：表级锁"><a href="#1-1MyISAM：表级锁" class="headerlink" title="1.1MyISAM：表级锁"></a>1.1MyISAM：表级锁</h4><ul>
<li>在对数据表进行select操作时，MyISAM会为该表加上一个表的<strong>读锁（共享锁）</strong>，在对数据表进行增删改时，MyISAM会为该表叫上一个<strong>写锁（排它锁）</strong></li>
<li><strong>两个锁互斥</strong>，必须等另一种锁释放之后，才能加上不同种类的锁</li>
<li>读锁与读锁之间不互斥，<strong>写锁与写锁之间会发生互斥</strong></li>
<li>显式的加锁：<strong>lock table</strong> XXX <strong>read</strong>(或者<strong>write</strong>) ；解锁：unlock table</li>
</ul>
<h4 id="1-2InnoDB：索引时用行级锁，非索引时用表级锁"><a href="#1-2InnoDB：索引时用行级锁，非索引时用表级锁" class="headerlink" title="1.2InnoDB：索引时用行级锁，非索引时用表级锁"></a>1.2InnoDB：索引时用行级锁，非索引时用表级锁</h4><ul>
<li>相对于表级锁，<strong>行级锁只对操作的行数进行加锁操作</strong>，其锁的行为与表级锁一致</li>
<li>显式的对某行加锁：在末尾加<strong>lock in share mode（加读锁）</strong>；<strong>for update（加写锁）</strong></li>
</ul>
<h4 id="如何加表锁？"><a href="#如何加表锁？" class="headerlink" title="如何加表锁？"></a><strong>如何加表锁？</strong></h4><ul>
<li>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</li>
<li>在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。<strong>这也正是MyISAM表不会出现死锁（Deadlock Free）的原因</strong>。</li>
</ul>
<h4 id="如何加行锁？"><a href="#如何加行锁？" class="headerlink" title="如何加行锁？"></a>如何加行锁？</h4><ul>
<li><p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p>
<p>¡ 共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。</p>
<p>¡ 排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。</p>
</li>
<li><p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的</strong>，这一点MySQL与Oracle不同，后者是<strong>通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p>
</li>
</ul>
<h4 id="1-3MyISAM适合的场景"><a href="#1-3MyISAM适合的场景" class="headerlink" title="1.3MyISAM适合的场景"></a>1.3MyISAM适合的场景</h4><ul>
<li>频繁执行全表count语句（<strong>MyISAM会保存一个表行数的变量</strong>，InnoDB则需要重新扫描全表）</li>
<li>对数据进行增删改的频率不高，查询非常频繁（MyISAM增删改会涉及锁表操作，InnoDB只会锁行）</li>
<li>没有事务</li>
</ul>
<h4 id="1-4InnoDB适合的场景"><a href="#1-4InnoDB适合的场景" class="headerlink" title="1.4InnoDB适合的场景"></a>1.4InnoDB适合的场景</h4><ul>
<li>数据增删改查都相当频繁（InnoDB只锁行，避免很多操作的阻塞）</li>
<li>可靠性要求比较高，要求支持事务</li>
</ul>
<h4 id="1-5数据库锁的分类"><a href="#1-5数据库锁的分类" class="headerlink" title="1.5数据库锁的分类"></a>1.5数据库锁的分类</h4><ul>
<li>按锁的粒度划分，可分为<strong>表级锁、行级锁、页级锁</strong>（介于两者之间）</li>
<li>按锁级别划分，可分为<strong>共享锁、排它锁</strong></li>
<li>按加锁方式划分，可分为<strong>自动锁、显式锁</strong></li>
<li>按操作划分，可分为<strong>DML锁</strong>（对数据上的锁）、<strong>DDL锁</strong>（对表结构上的锁）</li>
<li>按使用方式划分，可分为<strong>乐观锁</strong>（通过加版本号或时间戳来实现，更新提交时检查版本号是否对应）<strong>、悲观锁</strong></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/MySQL/MySQLTransaction/">上一篇</a><a class="next" href="/MySQL/MySQLIndex/">下一篇</a></div><div class="copyright"><p>© 2020 <a href="http://www.kongkongbai.com">kongkongbai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/achjqz/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/github-gist.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/dockerfile.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/x86asm.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>