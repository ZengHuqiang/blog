<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空空白的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kongkongbai.com/"/>
  <updated>2020-06-08T03:51:41.823Z</updated>
  <id>http://www.kongkongbai.com/</id>
  
  <author>
    <name>kongkongbai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>17.寻找中位数_纪念第一次独立做出Hard题</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer17/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer17/</id>
    <published>2020-06-08T03:23:03.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p><strong>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</strong><br><strong>double findMedian() - 返回目前所有元素的中位数。</strong><br>示例 1：</p><p>输入：<br><code>[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</code><br><code>[[],[1],[2],[],[3],[]]</code><br><code>输出：[null,null,null,1.50000,null,2.00000]</code><br>示例 2：</p><p>输入：<br><code>[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</code><br><code>[[],[2],[],[3],[]]</code><br><code>输出：[null,null,2.00000,null,2.50000]</code></p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：采用两个堆维护中间数</p><p>较小的前半段用大顶堆，维护前面数字的最大值；较大的后半段用小顶堆，维护后面数字的最小值</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; p1 ;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; p2 ;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//大顶堆</span></span><br><span class="line">        p1 = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2-o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//小顶堆</span></span><br><span class="line">        p2 = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//偶数个时进入一个数</span></span><br><span class="line">        <span class="keyword">if</span>(size%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                p1.offer(num);</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;p2.peek())&#123;</span><br><span class="line">                p1.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p1.offer(p2.poll());</span><br><span class="line">                p2.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//奇数个时进入一个数</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;p1.peek())&#123;</span><br><span class="line">                p2.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p2.offer(p1.poll());</span><br><span class="line">                p1.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(p1.peek()+p2.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)p1.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>16.字符串的排列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer15/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer15/</id>
    <published>2020-06-07T02:42:01.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：递归回溯，dfs</p><p>从第一个字符开始向下递归，保证每层中的字符都不相同</p><p>排列方案数量： 对于一个长度为 nn 的字符串（假设字符互不重复），其排列共有 n \times (n-1) \times (n-2) … \times 2 \times 1n×(n−1)×(n−2)…×2×1 种方案。</p><p><strong>排列方案的生成方法：</strong> 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 11 位字符（ nn 种情况）、再固定第 22 位字符（ n-1n−1 种情况）、… 、最后固定第 nn 位字符（ 11 种情况）。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/b2b90a527d7d8aeb1bc3981c3634c791.png" alt="Picture1.png"></p><p><strong>重复方案与剪枝：</strong> 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/668302f70a8e3d11936ab655f0738225.png" alt="Picture2.png"></p><p>每次递归时，创建一个HashSet来保存当前层次中 已递归过的字符，当遇到重复时直接跳过。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"><span class="keyword">char</span>[] c;</span><br><span class="line"><span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    c = s.toCharArray();</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==c.length-<span class="number">1</span>)&#123;</span><br><span class="line">        res.add(String.valueOf(c));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;c.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>;</span><br><span class="line">        set.add(c[i]);</span><br><span class="line">        swap(i,x);</span><br><span class="line">        dfs(x+<span class="number">1</span>);</span><br><span class="line">        swap(x,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = c[i];</span><br><span class="line">    c[i] = c[x];</span><br><span class="line">    c[x] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一个字符串，打印出该字符串中字符的所有排列。&lt;/p&gt;
&lt;p&gt;你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>15.二叉树的序列与反序列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer15/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer15/</id>
    <published>2020-06-05T03:06:51.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>示例: </p><p>你可以将以下二叉树：</p><pre><code>  1 / \2   3   / \  4   5</code></pre><p>序列化为 “[1,2,3,null,null,4,5]” or “[1,2,3,null,null,4,5,null,null,null,null]”</p><p>如何序列化可以自己进行设计</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：通过层次遍历进行序列化，反序列化时利用队列（也是层次遍历的思想）</p><p>需要注意，字符串的处理细节</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.append(<span class="string">"null,"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(temp.val);</span><br><span class="line">            res.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(temp.left);</span><br><span class="line">        queue.add(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">    res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">    res.append(<span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="string">"[]"</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//将[x,x,x,x]数据提取为字符串数组</span></span><br><span class="line">    String[] subData = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>).split(<span class="string">","</span>);</span><br><span class="line">    <span class="comment">//将字符转换为数字</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(subData[<span class="number">0</span>]));</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(!subData[index].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">            temp.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(subData[index]));</span><br><span class="line">            queue.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(!subData[index].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">            temp.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(subData[index]));</span><br><span class="line">            queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;请实现两个函数，分别用来序列化和反序列化二叉树。&lt;/p&gt;
&lt;p&gt;示例: &lt;/p&gt;
&lt;p&gt;你可以将以下二叉树：&lt;/p&gt;
&lt;pr
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>14.搜索二叉树和双向链表</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer14/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer14/</id>
    <published>2020-06-04T11:15:40.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/76591cecc79c0ca89776fd6f5b84e552.png" alt="img"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p> <img src="https://pic.rmb.bdstatic.com/bjh/632c68e4611d23601d1bd6b2836b1f93.png" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p><strong>思路一：中序遍历</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node head,tail;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    head.left = tail;</span><br><span class="line">    tail.right = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    <span class="keyword">if</span>(tail!=<span class="keyword">null</span>) tail.right = root;</span><br><span class="line">    <span class="keyword">else</span> head = root;</span><br><span class="line">    root.left = tail;</span><br><span class="line">    tail = root;</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&lt;/p
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>13.复杂链表的深拷贝</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer13/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer13/</id>
    <published>2020-06-04T07:25:38.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p><strong>思路一：HashMap</strong></p><p>第一步 遍历链表，复制各个结点，用next串接链表，在这个过程中使用HashMap&lt;oldNode,newNode&gt;将新旧节点一一对应</p><p>第二步 再遍历链表，将原链表的random对应关系，使用HashMap映射到新链表中</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//创建HashMap集合</span></span><br><span class="line">    Node cur=head;</span><br><span class="line">    <span class="comment">//复制结点值</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//存储put:&lt;key,value1&gt;</span></span><br><span class="line">        map.put(cur,<span class="keyword">new</span> Node(cur.val)); <span class="comment">//顺序遍历，存储老结点和新结点(先存储新创建的结点值)</span></span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制结点指向</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//得到get:&lt;key&gt;.value2,3</span></span><br><span class="line">        map.get(cur).next = map.get(cur.next); <span class="comment">//新结点next指向同旧结点的next指向</span></span><br><span class="line">        map.get(cur).random = map.get(cur.random); <span class="comment">//新结点random指向同旧结点的random指向</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回复制的链表</span></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://www.kongkongbai.com/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/singleton/"/>
    <id>http://www.kongkongbai.com/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/singleton/</id>
    <published>2020-06-03T13:02:54.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><h4 id="1-1定义与类型"><a href="#1-1定义与类型" class="headerlink" title="1.1定义与类型"></a>1.1定义与类型</h4><ul><li>定义：保证一个类仅有一个实例，并提供一个全局访问点</li><li>类型：创建型</li></ul><h4 id="1-2使用场景"><a href="#1-2使用场景" class="headerlink" title="1.2使用场景"></a>1.2使用场景</h4><ul><li>想确保任何情况下都绝对只有一个实例</li></ul><h4 id="1-3优点"><a href="#1-3优点" class="headerlink" title="1.3优点"></a>1.3优点</h4><ul><li>在内存中只有一个实例，减小了内存开销</li><li>可以避免对资源的多重占用</li><li>设置全局访问点，严格的控制访问</li></ul><h4 id="1-4缺点"><a href="#1-4缺点" class="headerlink" title="1.4缺点"></a>1.4缺点</h4><ul><li>没有接口，拓展困难</li></ul><h4 id="1-5重点问题"><a href="#1-5重点问题" class="headerlink" title="1.5重点问题"></a>1.5重点问题</h4><ul><li><strong>私有构造器</strong></li><li><strong>线程安全问题</strong></li><li><strong>延迟加载</strong></li><li><strong>序列化和反序列化安全问题</strong></li><li><strong>反射</strong></li></ul><h4 id="1-6设计模式的结合"><a href="#1-6设计模式的结合" class="headerlink" title="1.6设计模式的结合"></a>1.6设计模式的结合</h4><ul><li>单例模式和工厂模式</li><li>单例模式和享元模式</li></ul><h3 id="2-三种单例模式的实现"><a href="#2-三种单例模式的实现" class="headerlink" title="2.三种单例模式的实现"></a>2.三种单例模式的实现</h3><h4 id="2-1懒汉式—延迟加载"><a href="#2-1懒汉式—延迟加载" class="headerlink" title="2.1懒汉式—延迟加载"></a>2.1懒汉式—延迟加载</h4><p><a href="http://39.107.124.120/wp-content/uploads/2020/04/懒汉式单例模式01.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/59c3f5111f1eac97c359a378d470ae7a.png" alt="懒汉式单例模式01"></a></p><p><strong>线程安全问题：</strong></p><ul><li>当多个线程同时运行到lazySingleton = new LazySingleton（）时，会创建不同的对象</li></ul><h4 id="2-1-1改进"><a href="#2-1-1改进" class="headerlink" title="2.1.1改进"></a>2.1.1改进</h4><p><strong>1.对这个静态方法上同步锁（即对这个类对象加锁）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazySingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺陷：由于上了同步类锁，上锁范围比较大，影响性能</strong></p><p><strong>2.双重检查机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式的双重检测机制改进</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckingSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckingSingleton lazyDoubleCheckingSingleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckingSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckingSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyDoubleCheckingSingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckingSingleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazyDoubleCheckingSingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazyDoubleCheckingSingleton = <span class="keyword">new</span> LazyDoubleCheckingSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyDoubleCheckingSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解：第一重空值检测，保证必须时单例为空的情况才能进入；加同步类锁，保证在单例为空的情况下，同一时间只有一个线程能够进入创建实例的代码段；第二重空值检测，保证进入了第一重检测的线程中后面进入同步代码块的线程不会再重新创建实例。</p><p><strong>双重检测机制中存在问题—指令重排序</strong></p><p><a href="http://39.107.124.120/wp-content/uploads/2020/03/单例的双重检测实现01.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/cb621d85d6104e69887c99e3a14ea28a.jpeg" alt="单例的双重检测实现01"></a></p><p><strong>解决1：使用volatile修饰实例，禁止重排序</strong></p><h4 id="2-2-基于类初始化的延迟加载解决方案（静态内部类）"><a href="#2-2-基于类初始化的延迟加载解决方案（静态内部类）" class="headerlink" title="2.2.基于类初始化的延迟加载解决方案（静态内部类）"></a><strong>2.2.基于类初始化的延迟加载解决方案（静态内部类）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleton staticInnerClassSingleton = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.staticInnerClassSingleton ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://39.107.124.120/wp-content/uploads/2020/04/静态内部类实现单例原理.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/5cd78a5b2ab0425e23c534ea06e163e8.jpeg" alt="静态内部类实现单例原理"></a></p><p><strong>延迟加载</strong>原理：加载一个类时，<strong>其内部类不会同时被加载</strong>。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。</p><p><strong>线程安全</strong>原理：Class对象在被初始化时，会加上<strong>Class对象初始化锁。</strong></p><p><strong>什么时候Java的类会被立刻初始化？</strong></p><p>1）T是一个类，而且一个T类型的<strong>实例被创建。</strong></p><p>2）T是一个类，且T中声明的一个<strong>静态方法被调用</strong>。</p><p>3）T中声明的一个<strong>静态字段被赋值</strong>。</p><p>4）T中声明的一个<strong>静态字段被使用</strong>，而且这个字段<strong>不是一个常量字段</strong>。</p><p>5）T是一个顶级类（Top Level Class，见Java语言规范的§7.6），而且一个断言语句（assert关键字修饰的语句）嵌套在T内部被执行（不常见）</p><h4 id="2-3饿汉式-–类加载时完成实例化"><a href="#2-3饿汉式-–类加载时完成实例化" class="headerlink" title="2.3饿汉式 –类加载时完成实例化"></a>2.3饿汉式 –类加载时完成实例化</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/11370a710100ca2ce46d02d775510759.png" alt="饿汉式"></p><ul><li>没有延迟加载，在类被加载时，实例就已经被加载</li><li>优点：简单，没有线程安全问题</li><li>缺点：如果该单例没有被使用，会增加内存负担</li></ul><h3 id="3-单例模式的安全问题"><a href="#3-单例模式的安全问题" class="headerlink" title="3.单例模式的安全问题"></a>3.单例模式的安全问题</h3><h4 id="3-1序列化与反序列化问题"><a href="#3-1序列化与反序列化问题" class="headerlink" title="3.1序列化与反序列化问题"></a>3.1序列化与反序列化问题</h4><ul><li><h5 id="序列化与反序列化破坏单例模式"><a href="#序列化与反序列化破坏单例模式" class="headerlink" title="序列化与反序列化破坏单例模式"></a>序列化与反序列化破坏单例模式</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将instance对象序列化写入oos中</span></span><br><span class="line">HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singleton_file"</span>));</span><br><span class="line">oos.writeObject(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再将其反序列化生成对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"singleton_file"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">HungrySingleton newInstance = (HungrySingleton) ois.readObject();</span><br></pre></td></tr></table></figure><ul><li><h5 id="为什么这两个对象不相同？"><a href="#为什么这两个对象不相同？" class="headerlink" title="为什么这两个对象不相同？"></a>为什么这两个对象不相同？</h5></li></ul><p>1.反序列化创建对象时，先调用<strong>isInstantialble()</strong>是否能生成对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>如果对象为serializable/externalizable并且可以在运行时可序列化，则返回true，否则返回false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns true if represented class is serializable&#x2F;externalizable and can</span><br><span class="line"> * be instantiated by the serialization runtime--i.e., if it is</span><br><span class="line"> * externalizable and defines a public no-arg constructor, or if it is</span><br><span class="line"> * non-externalizable and its first non-serializable superclass defines an</span><br><span class="line"> * accessible no-arg constructor.  Otherwise, returns false.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean isInstantiable() &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    return (cons !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.由于单例类实现了serializable，则通过<strong>desc.newInstance()*</strong><u>反射</u><em>的方式创建实例，这也是为什么序列化与反序列化可以破坏单例模式（*</em>一个是正常单例对象，一个是反射创建的对象**）</p><p>3.之后会进行<strong>hasReadResolveMethod()</strong>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    desc.hasReadResolveMethod())</span><br></pre></td></tr></table></figure><p>当class对象为serializable or externalizable，且定义了<strong>readResolve</strong>方法时，返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns true if represented class is serializable or externalizable and</span><br><span class="line"> * defines a conformant readResolve method.  Otherwise, returns false.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean hasReadResolveMethod() &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    return (readResolveMethod !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如果单例对象包含了readResolve方法，则通过<strong>反射调用readResolve方法</strong>来生成对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object rep = desc.invokeReadResolve(obj);</span><br></pre></td></tr></table></figure><p><strong>这也提供了解决序列化和反序列化破坏单例的方法：</strong>在单例类中添加readResolve方法，返回单例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决序列化与反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2反射攻击及其解决方案"><a href="#3-2反射攻击及其解决方案" class="headerlink" title="3.2反射攻击及其解决方案"></a>3.2反射攻击及其解决方案</h4><h5 id="对于类加载时创建单例对象（饿汉式-和-静态内部类）：在静态构造器中禁止反射加载"><a href="#对于类加载时创建单例对象（饿汉式-和-静态内部类）：在静态构造器中禁止反射加载" class="headerlink" title="对于类加载时创建单例对象（饿汉式 和 静态内部类）：在静态构造器中禁止反射加载"></a>对于类加载时创建单例对象（饿汉式 和 静态内部类）：在静态构造器中禁止反射加载</h5><p>饿汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//解决反射破坏单例</span></span><br><span class="line">    <span class="keyword">if</span>(hungrySingleton!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//禁止反射创建单例对象</span></span><br><span class="line">    <span class="keyword">if</span>(InnerClass.staticInnerClassSingleton!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的"><a href="#对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的" class="headerlink" title="对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的"></a>对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先反射创建对象，在调用getInstance创建对象时，无法触发设置在构造器中的保护代码</span></span><br><span class="line">LazySingleton newinstance = (LazySingleton)constructor.newInstance();</span><br><span class="line">LazySingleton instance = LazySingleton.getInstance();</span><br></pre></td></tr></table></figure><h5 id="可以再加一层保护"><a href="#可以再加一层保护" class="headerlink" title="可以再加一层保护"></a>可以再加一层保护</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加flag参数来保证构造器只被调用一次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这也并不是完美的，还可以通过反射改变flag的值后，在通过反射创建对象</p><h3 id="4-枚举单例"><a href="#4-枚举单例" class="headerlink" title="4.枚举单例"></a>4.枚举单例</h3><p><strong><a href="https://blog.csdn.net/javazejian/article/details/71333103#%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">参考博客</a></strong></p><ul><li><strong>为什么推荐使用枚举单例？</strong></li></ul><p>因为枚举单例不受序列化以及反射的影响，同时枚举类的特性（在类加载时通过静态代码块实例化单例）也很符合单例模式的要求</p><ul><li><h5 id="枚举单例的创建"><a href="#枚举单例的创建" class="headerlink" title="枚举单例的创建"></a>枚举单例的创建</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式的枚举单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumStarvingSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumStarvingSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumStarvingSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ContainerHolder.HOLDER.instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> ContainerHolder&#123;</span><br><span class="line">        HOLDER;</span><br><span class="line">        <span class="keyword">private</span> EnumStarvingSingleton instance;</span><br><span class="line">        ContainerHolder()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> EnumStarvingSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h5 id="为什么枚举单例不受序列化的影响？"><a href="#为什么枚举单例不受序列化的影响？" class="headerlink" title="为什么枚举单例不受序列化的影响？"></a>为什么枚举单例不受序列化的影响？</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TC_ENUM:</span><br><span class="line">    <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br></pre></td></tr></table></figure><p><strong>readEnum方法：</strong>通过调用Enum.valueOf()方法来获取枚举类，<strong>而枚举类中每个枚举常量具有唯一的name，所以反序列化的枚举类是唯一的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name = readString(<span class="keyword">false</span>);<span class="comment">//获取枚举常量的名称</span></span><br><span class="line">Enum&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line"><span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);<span class="comment">//通过获取的名称获得枚举类</span></span><br></pre></td></tr></table></figure><ul><li><strong>为什么枚举单例不受反射的影响？</strong></li></ul><ol><li>如果按默认方式反射获取构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line"><span class="comment">//会提示没有此构造器</span></span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.NoSuchMethodException: com.creational.singleton.EnumInstance.&lt;init&gt;()</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举的构造方法，只能由编译器调用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果我们传入参数类型呢，会报非法参数的异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = EnumInstance<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">EnumInstance instance = (EnumInstance)constructor.newInstance(<span class="string">"hello"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span></span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">417</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>为什么呢？</li></ol><p>在newInstance方法中，会进行是否为枚举类的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本介绍&quot;&gt;&lt;a href=&quot;#1-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.基本介绍&quot;&gt;&lt;/a&gt;1.基本介绍&lt;/h3&gt;&lt;h4 id=&quot;1-1定义与类型&quot;&gt;&lt;a href=&quot;#1-1定义与类型&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.kongkongbai.com/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.kongkongbai.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>spring自研框架-一-创建注解并提取目标对象</title>
    <link href="http://www.kongkongbai.com/Spring/SimpleframeWork01/"/>
    <id>http://www.kongkongbai.com/Spring/SimpleframeWork01/</id>
    <published>2020-06-03T12:10:20.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-先来了解下IoC"><a href="#1-先来了解下IoC" class="headerlink" title="1.先来了解下IoC"></a>1.先来了解下IoC</h3><h4 id="1-1控制反转"><a href="#1-1控制反转" class="headerlink" title="1.1控制反转"></a>1.1控制反转</h4><ul><li>依托一个类似工厂的IoC容器</li><li>将对象的创建、依赖关系的管理以及生命周期交由IoC容器管理</li><li>降低系统在实现上的复杂性和耦合度、易于拓展、满足开闭原则</li></ul><h4 id="1-2依赖注入—实现控制反转"><a href="#1-2依赖注入—实现控制反转" class="headerlink" title="1.2依赖注入—实现控制反转"></a>1.2依赖注入—实现控制反转</h4><ul><li><strong>把底层类作为参数传递给上层类</strong>，实现上层对下层的“控制”</li></ul><p>主流的依赖注入方式：</p><ol><li>By 构造函数</li><li>By setter方法</li><li>By 接口</li><li>By 注解</li></ol><h4 id="1-3为什么要依托IoC容器？"><a href="#1-3为什么要依托IoC容器？" class="headerlink" title="1.3为什么要依托IoC容器？"></a>1.3为什么要依托IoC容器？</h4><ul><li>避免在各处使用new来创建类，并且可以做到统一维护</li><li>创建实例的时候不需要知道具体的细节（通过读取配置文件，<u><em>用反射的机制来完成创建</em>？</u>）</li><li><strong>反射+工厂模式</strong>的合体，满足开闭原则</li></ul><h4 id="1-4框架具备的最基本功能"><a href="#1-4框架具备的最基本功能" class="headerlink" title="1.4框架具备的最基本功能"></a>1.4框架具备的最基本功能</h4><ul><li>解析配置：项目中采用注解</li><li>定位与注册对象</li><li>注入对象：在用户需要使用对象时，返回正确对象</li><li>提供通用的工具类</li></ul><h3 id="2-IoC容器的实现"><a href="#2-IoC容器的实现" class="headerlink" title="2.IoC容器的实现"></a>2.IoC容器的实现</h3><p><strong>基本步骤：</strong></p><ol><li>创建注解</li><li>提取标记对象</li><li>实现容器（项目中采用键值对）</li><li>依赖注入</li></ol><h4 id="2-1-创建注解"><a href="#2-1-创建注解" class="headerlink" title="2.1 创建注解"></a>2.1 创建注解</h4><table><thead><tr><th></th><th>作用</th><th>作用对象</th><th>生命周期</th><th></th></tr></thead><tbody><tr><td>Controller</td><td>标记Controller层</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime(因为要通过反射创建对象)</td><td></td></tr><tr><td>Service</td><td>标记Service层</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr><tr><td>Repository</td><td>用于标记Dao层中的实现类</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr><tr><td>Component</td><td>用于标记通用的需要容器管理的组件</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr></tbody></table><h4 id="2-2-提取标记对象"><a href="#2-2-提取标记对象" class="headerlink" title="2.2 提取标记对象"></a>2.2 提取标记对象</h4><p><strong>实现思路：</strong></p><ol><li>指定范围，获取范围内的所有类</li><li>遍历所有类，获取被注解标记的类并加载进容器中</li></ol><h5 id="2-2-1-获取范围内的所有类"><a href="#2-2-1-获取范围内的所有类" class="headerlink" title="2.2.1 获取范围内的所有类"></a>2.2.1 获取范围内的所有类</h5><p><strong>实现思路：</strong></p><ol><li>获取类的加载器 –&gt;目的：获取项目发布的实际路径</li><li>通过类的加载器获取到加载的资源信息</li><li>依据不同的资源类型，采用不同的方式获取资源的集合</li></ol><p><strong>extractPackageClass(String packageName)</strong>：通过输入的包名，返回包下所有类的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包下的类集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 类集合Set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; extractPackageClass(String packageName)&#123;</span><br><span class="line">    <span class="comment">//1.获取类的加载器--&gt;目的：获取项目发布的实际路径</span></span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    <span class="comment">//2.通过类的加载器获取到加载的资源信息</span></span><br><span class="line">    <span class="comment">//getResource()方法 接受‘/’来隔开的名称，所以需要先将packageName中‘.'替换为’/‘</span></span><br><span class="line">    <span class="comment">//getResource()返回包含该类资源的url</span></span><br><span class="line">    URL url = classLoader.getResource(packageName.replace(<span class="string">"."</span>,<span class="string">"/"</span>));</span><br><span class="line">    <span class="keyword">if</span>(url==<span class="keyword">null</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">"unable to get anything from package:"</span>+packageName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.依据不同的资源类型，采用不同的方式获取资源的集合</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//过滤出文件类型的资源:我们需要获取的是协议为file，即本地的资源</span></span><br><span class="line">    <span class="keyword">if</span>(url.getProtocol().equalsIgnoreCase(FILE_PROTOCOL))&#123;</span><br><span class="line">        classSet = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        <span class="comment">//首先通过获取的path路径获取路径的File对象</span></span><br><span class="line">        File packageDirectory = <span class="keyword">new</span> File(url.getPath());</span><br><span class="line">        extractClassFile(classSet,packageDirectory,packageName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：通过getResource（）返回的是URL数据，我们需要对返回的URL过滤，选出protocol为file类型（本地文件类型），并获取其中的Path路径信息，在提取该包路径中所有的Class类型文件</p><p><img src="https://pic.rmb.bdstatic.com/bjh/c4f8f523aae6d3d793ce6e0305142094.jpeg" alt="image-20200603194722808"></p><p><strong>getClassLoader()</strong>：通过获取当前线程的类加载器获取加载该类的类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取ClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当前线程的内容加载器即该类的类加载器</span></span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>extractClassFile(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName)</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归获取目标package里面的所有class文件（包括子package里面的class文件）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> emptyClassSet 装载目标类的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileSource 文件或者目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractClassFile</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件：当检索的不是文件夹时</span></span><br><span class="line">    <span class="keyword">if</span>(!fileSource.isDirectory()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果是一个文件夹，通过调用listFiles()获取这个文件夹中的所有文件或文件夹</span></span><br><span class="line">    <span class="comment">//并通过文件过滤器，留下文件夹类型，其余文件类型如果为class文件则直接加载</span></span><br><span class="line">    File[] files = fileSource.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果是文件夹类型，则通过</span></span><br><span class="line">            <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//获取文件的绝对值路径</span></span><br><span class="line">                String absoluteFilePath = file.getAbsolutePath();</span><br><span class="line">                <span class="keyword">if</span>(absoluteFilePath.endsWith(<span class="string">".class"</span>))&#123;</span><br><span class="line">                    <span class="comment">//若是class文件，则直接加载</span></span><br><span class="line">                    addToClassSet(absoluteFilePath);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToClassSet</span><span class="params">(String absoluteFilePath)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1.从class文件的绝对值路径里提取出包含了package的类名</span></span><br><span class="line">            <span class="comment">//比如：F:/simpleframework/simpleframwork/targt/classes/com/imooc/entity/dto/MainPage</span></span><br><span class="line">            <span class="comment">//提取为类名：com.imooc.entity.dto.MainPage</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//首先将绝对值路径中的分割符替换为“.”</span></span><br><span class="line">            absoluteFilePath = absoluteFilePath.replace(File.separator,<span class="string">"."</span>);</span><br><span class="line">                <span class="comment">//首先截取由包名开始的字段</span></span><br><span class="line">            String className = absoluteFilePath.substring(absoluteFilePath.indexOf(packageName));</span><br><span class="line">                <span class="comment">//之后再将最后“.”结尾的文件后缀去掉</span></span><br><span class="line">            className = className.substring(<span class="number">0</span>,className.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">            <span class="comment">//2.通过反射机制获取对应的Class对象并放入classSet中</span></span><br><span class="line">            Class targetCLass = loadClass(className);</span><br><span class="line">            emptyClassSet.add(targetCLass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            extractClassFile(emptyClassSet,file,packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>loadClass(className)</strong>：通过反射机制获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        log.error(<span class="string">"load class error:"</span>,e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单的做一个UT："><a href="#简单的做一个UT：" class="headerlink" title="简单的做一个UT："></a>简单的做一个UT：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtilTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"提取目标类方法：extractPackageClass"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extractPackageClassTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.extractPackageClass(<span class="string">"com.imooc.entity"</span>);</span><br><span class="line">        System.out.println(classSet);</span><br><span class="line">        Assertions.assertEquals(<span class="number">4</span>,classSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-先来了解下IoC&quot;&gt;&lt;a href=&quot;#1-先来了解下IoC&quot; class=&quot;headerlink&quot; title=&quot;1.先来了解下IoC&quot;&gt;&lt;/a&gt;1.先来了解下IoC&lt;/h3&gt;&lt;h4 id=&quot;1-1控制反转&quot;&gt;&lt;a href=&quot;#1-1控制反转&quot; class
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://www.kongkongbai.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.kongkongbai.com/tags/Spring/"/>
    
      <category term="自研框架" scheme="http://www.kongkongbai.com/tags/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>12.二叉搜索树的后序遍历序列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer12/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer12/</id>
    <published>2020-06-03T03:07:00.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><pre><code>     5   / \  2   6 / \1   3</code></pre><p>示例 1：</p><p>输入: [1,6,3,2,5]<br>输出: false<br>示例 2：</p><p>输入: [1,3,2,6,5]<br>输出: true</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：递归分治"><a href="#思路一：递归分治" class="headerlink" title="思路一：递归分治"></a>思路一：递归分治</h5><p>所有的子树都满足，左子树&lt;根&lt;右子树</p><p>如何判断哪里为左子树，哪里为右子树？最后一个结点为根，从开始出发，小于根的为左子树，其余为右子树</p><p>如何判断这棵树满足 左子树&lt;根&lt;右子树？从开始序列出发，保证刚刚分出来的左子树序列全部小于根，右子树序列全部大于根</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recue(postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recue</span><span class="params">(<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> p = i;</span><br><span class="line">    <span class="comment">//找到右子树的开始序号</span></span><br><span class="line">    <span class="keyword">while</span>(postorder[p]&lt;postorder[j]) p++;</span><br><span class="line">    <span class="keyword">int</span> m = p;</span><br><span class="line">    <span class="comment">//找到右子树的末尾序号</span></span><br><span class="line">    <span class="keyword">while</span>(postorder[p]&gt;postorder[j]) p++;</span><br><span class="line">    <span class="keyword">return</span> p==j&amp;&amp;recue(postorder,i,m-<span class="number">1</span>)&amp;&amp;recue(postorder,m,j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：单调辅助栈，还没看懂，基本思路是将后序遍历翻转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单调栈使用，单调递增的单调栈</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 表示上一个根节点的元素，这里可以把postorder的最后一个元素root看成无穷大节点的左孩子</span></span><br><span class="line">    <span class="keyword">int</span> pervElem = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 逆向遍历，就是翻转的先序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">// 左子树元素必须要小于递增栈被peek访问的元素，否则就不是二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> (postorder[i] &gt; pervElem)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; postorder[i] &lt; stack.peek())&#123;</span><br><span class="line">            <span class="comment">// 数组元素小于单调栈的元素了，表示往左子树走了，记录下上个根节点</span></span><br><span class="line">            <span class="comment">// 找到这个左子树对应的根节点，之前右子树全部弹出，不再记录，因为不可能在往根节点的右子树走了</span></span><br><span class="line">            pervElem = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个新元素入栈</span></span><br><span class="line">        stack.push(postorder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>11.栈的弹出序列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer11/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer11/</id>
    <published>2020-06-01T08:09:18.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：利用辅助栈模拟出入栈"><a href="#思路一：利用辅助栈模拟出入栈" class="headerlink" title="思路一：利用辅助栈模拟出入栈"></a>思路一：利用辅助栈模拟出入栈</h5><p>考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</p><p><strong>入栈操作</strong>： 按照压栈序列的顺序执行。<br><strong>出栈操作</strong>： 每次入栈后，<strong>循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立</strong>，将符合弹出序列顺序的栈顶元素全部弹出。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushed.length;i++)&#123;</span><br><span class="line">        s.push(pushed[i]);</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty()&amp;&amp;popped[index]==s.peek())&#123;</span><br><span class="line">            index++;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.isEmpty()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>10.树的子结构</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer10/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer10/</id>
    <published>2020-05-25T13:37:13.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><pre><code> 3/ \4   5  / \ 1   2</code></pre><p>给定的树 B：</p><p>   4<br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：深度优先遍历（先序遍历）+递归判断</p><ul><li>先序遍历树A的每个节点An</li><li>判断树A中以<strong>An为根节点的子树是否以相同根节点包含树B</strong></li></ul><h5 id="如何判断A树是否以相同根节点包含树B呢？"><a href="#如何判断A树是否以相同根节点包含树B呢？" class="headerlink" title="如何判断A树是否以相同根节点包含树B呢？"></a>如何判断A树是否以相同根节点包含树B呢？</h5><ul><li>如果树B为空，说明路径匹配成功，返回true</li><li>如果树A为空 或者 树A根节点值与树B不同，返回false</li><li>递归判断 (A.left, B.left) 与 (A.right, B.right)是否也满足条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (A!=<span class="keyword">null</span>&amp;&amp;B!=<span class="keyword">null</span>)&amp;&amp;(recure(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recure</span><span class="params">(TreeNode A, TreeNode B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.val!=B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> recure(A.left,B.left)&amp;&amp;recure(A.right,B.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;p&gt;B是A的子结构， 即 A中有
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>9.正则表达式</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer09/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer09/</id>
    <published>2020-05-24T04:50:09.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目（较难）"><a href="#1-题目（较难）" class="headerlink" title="1.题目（较难）"></a>1.题目（较难）</h3><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a>思路一：动态规划</h5><p><img src="https://pic.rmb.bdstatic.com/bjh/fd8f9b644377521e8df1d3ba3f2981ad.png" alt="image-20200524124527719"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/d2628a28ee50ae8d1d809aaed6d84ec2.png" alt="image-20200524124558964"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> m = p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                f[i][j] = (i==<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)!=<span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;(s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>)||p.charAt(j-<span class="number">1</span>)==<span class="string">'.'</span>))&#123;</span><br><span class="line">                        f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        f[i][j] = f[i][j-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">2</span>&amp;&amp;(s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">2</span>)||p.charAt(j-<span class="number">2</span>)==<span class="string">'.'</span>))&#123;</span><br><span class="line">                        f[i][j] = f[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目（较难）&quot;&gt;&lt;a href=&quot;#1-题目（较难）&quot; class=&quot;headerlink&quot; title=&quot;1.题目（较难）&quot;&gt;&lt;/a&gt;1.题目（较难）&lt;/h3&gt;&lt;p&gt;请实现一个函数用来匹配包含’. ‘和’&lt;em&gt;‘的正则表达式。模式中的字符’.’表示任意一个
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>9.打印从1到最大的n位数</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer08/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer08/</id>
    <published>2020-05-20T07:33:36.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>本题主要考察如何处理超过int、long阀值的数；这时肯定不能用数值来表示要打印的数，而需要借助字符串</p><p>increment函数，若发生进位则一直进行for循环，直到不产生进位则break。如果i为0（即到了最高位）还发生了进位，则设置isOverflow为true，并返回至主函数的while判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// 将str初始化为n个'0'字符组成的字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        str.append(<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!increment(str))&#123;</span><br><span class="line">        <span class="comment">// 去掉左侧的0</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; str.length() &amp;&amp; str.charAt(index) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(str.toString().substring(index)+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">increment</span><span class="params">(StringBuilder str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isOverflow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">char</span> s = (<span class="keyword">char</span>)(str.charAt(i) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果s大于'9'则发生进位</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            str.replace(i, i + <span class="number">1</span>, <span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                isOverflow = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没发生进位则跳出for循环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            str.replace(i, i + <span class="number">1</span>, String.valueOf(s));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOverflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入数字 &lt;code&gt;n&lt;/code&gt;，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>8.快速幂运算</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer08/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer08/</id>
    <published>2020-05-20T06:58:13.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>说明:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] </li></ul><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：二进制角度"><a href="#思路一：二进制角度" class="headerlink" title="思路一：二进制角度"></a><strong>思路一：二进制角度</strong></h5><p><img src="https://pic.rmb.bdstatic.com/bjh/cfe0dae9267127f30c563da674b2d914.png" alt="01"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/3baa061fda1521a6dbc9928f95e8f305.png" alt="TIM截图20200520145209"></p><p><strong>特别注意：虽然不考虑大数，但是要考虑最小的负数情况，它的相反数会发生溢出，所以需要long类型进行控制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>/x;</span><br><span class="line">        N = -N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastPow(x,N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>) res = res*x;</span><br><span class="line">        x = x*x;</span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="思路二：分治思想，递归"><a href="#思路二：分治思想，递归" class="headerlink" title="思路二：分治思想，递归"></a>思路二：分治思想，递归</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        N = -N;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/fastPow(x,N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastPow(x,N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> s = fastPow(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> s*s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> s = fastPow(x,(n-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> s*s*x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;实现函数double Power(double base, int exponent)，求base的exponent次方。不
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>MySQL语法模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLGrammar/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLGrammar/</id>
    <published>2020-05-13T08:18:34.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<p><strong>三张表实例：</strong></p><ul><li>course：course_id、course_name</li><li>student：studen_id、student_name</li><li>score：student_id、course_id、score</li></ul><h4 id="1-Group-By"><a href="#1-Group-By" class="headerlink" title="1.Group By"></a>1.Group By</h4><ul><li>满足“Select子句中的列名必须满足为分组列（group by中的列名）或列函数”（只针对需要聚合的一个表）</li><li>列函数对于group by子句定义的每个组各返回一个结果</li></ul><p>例1：查询所有同学的学号、选课数、总成绩</p><p>例2：查询所有同学的学号、姓名、选课数、总成绩</p><p>select s.student_id, stu.name, count(s.course_id), sum(s.score)<br>from score s, student stu<br>group by s.student_id;</p><h4 id="2-Having"><a href="#2-Having" class="headerlink" title="2.Having"></a>2.Having</h4><ul><li>通常与Group by 子句一起使用</li><li>where过滤行，Having过滤组</li><li>出现在同一sql的顺序：Where&gt;Group by &gt;Having</li></ul><p>例1：查询平均成绩大于60分的同学的学号和平均成绩</p><p>select student_id, avg(score)<br>from score<br>group by student_id<br>having avg(score) &gt; 60;</p><p>例2：取出student_id为1学生的学生情况</p><p>select * from score having student_id = 1;</p><p>例3：查询没有学全所有课的同学的学号和姓名</p><p>select student_id, name<br>from score, course,</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;三张表实例：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;course：course_id、course_name&lt;/li&gt;
&lt;li&gt;student：studen_id、student_name&lt;/li&gt;
&lt;li&gt;score：student_id、cours
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLTransaction/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLTransaction/</id>
    <published>2020-05-13T08:18:15.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySql只有InnoDB支持事务系统"><a href="#MySql只有InnoDB支持事务系统" class="headerlink" title="MySql只有InnoDB支持事务系统"></a>MySql只有InnoDB支持事务系统</h3><ul><li><strong>MySQL</strong>默认隔离级别为：<strong>Repeatable Read</strong></li><li><strong>Oracle</strong>默认隔离级别为：<strong>Read Commited</strong></li></ul><h3 id="1-数据库的四大特性——ACID"><a href="#1-数据库的四大特性——ACID" class="headerlink" title="1.数据库的四大特性——ACID"></a>1.数据库的四大特性——ACID</h3><ul><li><strong>Atomicity</strong>（原子性）：一个事务中的操作要么全部执行，要么全部不执行</li><li><strong>Consistency</strong>（一致性）：指事务开始之前和结束之后，数据库的完整性约束没有被破坏</li><li><strong>Isolation</strong>（隔离性）：指多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果</li><li><strong>Durability</strong>（持久性）：事务完成之后对数据库的修改是持久性的，不会被回滚</li></ul><h3 id="2-事务的隔离性"><a href="#2-事务的隔离性" class="headerlink" title="2.事务的隔离性"></a>2.事务的隔离性</h3><p><a href="https://blog.csdn.net/CoderBruis/article/details/102692753" target="_blank" rel="noopener">参考博客</a></p><h4 id="2-1事务的隔离级别"><a href="#2-1事务的隔离级别" class="headerlink" title="2.1事务的隔离级别"></a>2.1事务的隔离级别</h4><ul><li><strong>Read uncommitted</strong>:一个事务可以读取另一个未提交事务的数据<strong>（无法避免脏读）</strong></li><li><strong>Read committed</strong>:一个事务要等另一个事务提交后才能读取数据（<strong>无法避免update和insert操作带来的幻读问题</strong>）</li><li><strong>Repeatable read:</strong>就是在开始读取数据（事务开启）时，不再允许修改操作(<strong>无法避免insert操作带来的幻读问题</strong>)</li><li><strong>Serializable:</strong>事务串行化顺序执行</li></ul><h4 id="2-2事务并发访问可能导致的问题"><a href="#2-2事务并发访问可能导致的问题" class="headerlink" title="2.2事务并发访问可能导致的问题"></a>2.2事务并发访问可能导致的问题</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/88cc8399da5f90a0be2a5630f426d15f.jpeg" alt="事务隔离级别"></p><ul><li><strong>脏读</strong>：脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。</li><li><strong>不可重复读</strong>：（同时操作，事务一分别读取事务二操作时和提交后的数据，读取的记录内容不一致）不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。</li><li><strong>幻读</strong>：和可重复读类似，但是事务二的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致</li><li>InnoDB Repeatable read级别下可以避免幻读</li></ul><h4 id="2-3InnoDB-Repeatable-read级别下如何避免幻读"><a href="#2-3InnoDB-Repeatable-read级别下如何避免幻读" class="headerlink" title="2.3InnoDB Repeatable read级别下如何避免幻读"></a>2.3InnoDB <strong>Repeatable read级别下如何避免幻读</strong></h4><p><a href="https://blog.csdn.net/xifeijian/article/details/20313977#t10" target="_blank" rel="noopener">（参考博客）</a></p><ul><li>表象：快照读（非阻塞读）——伪MVCC（多版本的并发控制）</li><li>内在：next-key锁（行锁+gap锁）</li></ul><h5 id="2-3-1当前读和快照读"><a href="#2-3-1当前读和快照读" class="headerlink" title="2.3.1当前读和快照读"></a>2.3.1当前读和快照读</h5><ul><li>当前读：加了锁的增删改查操作(select…lock in share mode;select…for update; update 、delete、insert)</li><li>快照读：不加锁的非阻塞读，select</li></ul><p><strong>区别：</strong></p><ul><li>read committed级别下。当前读与快照读读取的版本一样。</li><li>repeatable read 级别下，当前读返回的是数据的最新版本，<strong>快照读返回的可能数据未修改前的版本也可能是最新的数据版本</strong>。因为在RR级别下，事务调用快照读的时机很重要，创建快照的时机决定了读取的版本。</li></ul><h5 id="2-3-2RC、RR级别下InnoDB的非阻塞读-快照读-如何实现"><a href="#2-3-2RC、RR级别下InnoDB的非阻塞读-快照读-如何实现" class="headerlink" title="2.3.2RC、RR级别下InnoDB的非阻塞读(快照读)如何实现"></a>2.3.2RC、RR级别下InnoDB的非阻塞读(快照读)如何实现</h5><ul><li>数据行里的<strong>DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID</strong>字段</li></ul><p>1.DB_TRX_ID—-该字段标明最近一次对数据做修改（事务ID）<br>2.DB_ROLL_PTR—-回滚指针，写入<strong>回滚段的undo日志</strong><br>3.DB__ROW_ID —-行号 随着新行出现单调递增的id</p><ul><li>undo日志：主要分为<strong>insert undo</strong>日志（事务回滚涉及）和<strong>uodate undo</strong>日志（事务回滚和快照读都涉及）对事务变更就会产生undo记录，存储的是老版数据，事务回滚需要</li><li>read view：可见性判断来决定当前看的是哪个版本数据</li></ul><p><strong>实现的具体过程：</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/0eb3675fe478e80f6681717c2ed10aec.png" alt="快照读的实现"></p><p>比如现在有一个记录Field1、Field2、Field3数据分别为11、12、13，现在事务要修改该记录，将Field2修改为32。则这条记录首先会加载X锁，首先undo log中会拷贝一条修改前的记录，并赋值DB_ROW_ID。此时被X锁锁住的记录的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID分别进行赋值，并且DB_ROLL_PTR的记录会指向undo log中的DB_ROW_ID的值。</p><p><strong>RR的快照读出现旧数据的原因：</strong></p><p>如果在数据更新之前进行了一次快照读，事务会保存数据库的快照在undo log中，如果此时其他事务更新了数据，那么快照读依旧会沿用undo log中的数据，此时数据不再是最新数据。</p><h5 id="2-3-3内在：next-key锁（行锁-Gap锁）"><a href="#2-3-3内在：next-key锁（行锁-Gap锁）" class="headerlink" title="2.3.3内在：next-key锁（行锁+Gap锁）"></a>2.3.3内在：next-key锁（行锁+Gap锁）</h5><h5 id="2-3-3Gap锁"><a href="#2-3-3Gap锁" class="headerlink" title="2.3.3Gap锁"></a>2.3.3Gap锁</h5><p><strong>什么时候会用到Gap锁？</strong></p><ul><li>只有在RR和Serializable级别下</li><li>如果<strong>where条件全部命中</strong>，<strong>则不会用Gap锁</strong>，只会加行锁（因为如果条件全部命中，记录就存在唯一性，新增的记录不会产生幻读现象）</li><li>如果<strong>where条件部分命中或者全不命中，则会加Gap锁</strong></li><li>Gap锁会用在<strong>非唯一索引或者不走索引的当前读</strong>中</li></ul><ol><li>非唯一索引：加锁范围为与相邻非唯一键的区间中，左边&lt;=gap&lt;=右边，还与主键的字母排序有关（<strong>本质是与B+数的排列有关</strong>）</li><li>不走索引：会锁住所有的键</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MySql只有InnoDB支持事务系统&quot;&gt;&lt;a href=&quot;#MySql只有InnoDB支持事务系统&quot; class=&quot;headerlink&quot; title=&quot;MySql只有InnoDB支持事务系统&quot;&gt;&lt;/a&gt;MySql只有InnoDB支持事务系统&lt;/h3&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLLock/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLLock/</id>
    <published>2020-05-13T08:18:00.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-常见问题"><a href="#0-常见问题" class="headerlink" title="0.常见问题"></a>0.常见问题</h4><ul><li>MyISAM与InnoDB关于锁方面的区别是什么？</li><li>数据库事务的四大特性</li><li>事务隔离级别以及各级别下的并发访问问题</li><li>InnoDB可重复度隔离级别下如何避免幻读</li><li>RC、RR级别下的InnoDB的非阻塞读如何实现</li></ul><h3 id="1-MyISAM与InnoDB关于锁方面的区别"><a href="#1-MyISAM与InnoDB关于锁方面的区别" class="headerlink" title="1.MyISAM与InnoDB关于锁方面的区别"></a>1.MyISAM与InnoDB关于锁方面的区别</h3><p><a href="https://blog.csdn.net/xifeijian/article/details/20313977#t10" target="_blank" rel="noopener">（参考博客）！非常详细</a></p><ul><li>MyISAM默认用的表级锁，不支持行级锁</li><li>InnoDB默认用的行级锁，也支持表级锁</li></ul><h4 id="1-1MyISAM：表级锁"><a href="#1-1MyISAM：表级锁" class="headerlink" title="1.1MyISAM：表级锁"></a>1.1MyISAM：表级锁</h4><ul><li>在对数据表进行select操作时，MyISAM会为该表加上一个表的<strong>读锁（共享锁）</strong>，在对数据表进行增删改时，MyISAM会为该表叫上一个<strong>写锁（排它锁）</strong></li><li><strong>两个锁互斥</strong>，必须等另一种锁释放之后，才能加上不同种类的锁</li><li>读锁与读锁之间不互斥，<strong>写锁与写锁之间会发生互斥</strong></li><li>显式的加锁：<strong>lock table</strong> XXX <strong>read</strong>(或者<strong>write</strong>) ；解锁：unlock table</li></ul><h4 id="1-2InnoDB：索引时用行级锁，非索引时用表级锁"><a href="#1-2InnoDB：索引时用行级锁，非索引时用表级锁" class="headerlink" title="1.2InnoDB：索引时用行级锁，非索引时用表级锁"></a>1.2InnoDB：索引时用行级锁，非索引时用表级锁</h4><ul><li>相对于表级锁，<strong>行级锁只对操作的行数进行加锁操作</strong>，其锁的行为与表级锁一致</li><li>显式的对某行加锁：在末尾加<strong>lock in share mode（加读锁）</strong>；<strong>for update（加写锁）</strong></li></ul><h4 id="如何加表锁？"><a href="#如何加表锁？" class="headerlink" title="如何加表锁？"></a><strong>如何加表锁？</strong></h4><ul><li>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</li><li>在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。<strong>这也正是MyISAM表不会出现死锁（Deadlock Free）的原因</strong>。</li></ul><h4 id="如何加行锁？"><a href="#如何加行锁？" class="headerlink" title="如何加行锁？"></a>如何加行锁？</h4><ul><li><p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><p>¡ 共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。</p><p>¡ 排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。</p></li><li><p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的</strong>，这一点MySQL与Oracle不同，后者是<strong>通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p></li></ul><h4 id="1-3MyISAM适合的场景"><a href="#1-3MyISAM适合的场景" class="headerlink" title="1.3MyISAM适合的场景"></a>1.3MyISAM适合的场景</h4><ul><li>频繁执行全表count语句（<strong>MyISAM会保存一个表行数的变量</strong>，InnoDB则需要重新扫描全表）</li><li>对数据进行增删改的频率不高，查询非常频繁（MyISAM增删改会涉及锁表操作，InnoDB只会锁行）</li><li>没有事务</li></ul><h4 id="1-4InnoDB适合的场景"><a href="#1-4InnoDB适合的场景" class="headerlink" title="1.4InnoDB适合的场景"></a>1.4InnoDB适合的场景</h4><ul><li>数据增删改查都相当频繁（InnoDB只锁行，避免很多操作的阻塞）</li><li>可靠性要求比较高，要求支持事务</li></ul><h4 id="1-5数据库锁的分类"><a href="#1-5数据库锁的分类" class="headerlink" title="1.5数据库锁的分类"></a>1.5数据库锁的分类</h4><ul><li>按锁的粒度划分，可分为<strong>表级锁、行级锁、页级锁</strong>（介于两者之间）</li><li>按锁级别划分，可分为<strong>共享锁、排它锁</strong></li><li>按加锁方式划分，可分为<strong>自动锁、显式锁</strong></li><li>按操作划分，可分为<strong>DML锁</strong>（对数据上的锁）、<strong>DDL锁</strong>（对表结构上的锁）</li><li>按使用方式划分，可分为<strong>乐观锁</strong>（通过加版本号或时间戳来实现，更新提交时检查版本号是否对应）<strong>、悲观锁</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;0-常见问题&quot;&gt;&lt;a href=&quot;#0-常见问题&quot; class=&quot;headerlink&quot; title=&quot;0.常见问题&quot;&gt;&lt;/a&gt;0.常见问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;MyISAM与InnoDB关于锁方面的区别是什么？&lt;/li&gt;
&lt;li&gt;数据库事务的四大特性&lt;/l
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLIndex/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLIndex/</id>
    <published>2020-05-13T08:17:43.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-解决的问题"><a href="#0-解决的问题" class="headerlink" title="0.解决的问题"></a>0.解决的问题</h3><ul><li>为什么要使用索引–&gt;<strong>因为索引可以避免全表扫描,提升查找数据的效率,</strong></li><li>什么样的信息能成为索引–&gt;<strong>主键、唯一键以及普通键等能够让数据存在区分的字段</strong></li><li>索引的数据结构–&gt;<strong>主流:B+树</strong></li><li>密集索引和稀疏索引的区别–&gt;看下面解答</li></ul><h3 id="1-索引实现数据结构之间的比较"><a href="#1-索引实现数据结构之间的比较" class="headerlink" title="1.索引实现数据结构之间的比较"></a>1.索引实现数据结构之间的比较</h3><h4 id="1-1二叉查找树"><a href="#1-1二叉查找树" class="headerlink" title="1.1二叉查找树"></a>1.1二叉查找树</h4><p>查找效率一般情况较高，如果出现线性情况，效率会很低</p><h4 id="1-2B-B-树"><a href="#1-2B-B-树" class="headerlink" title="1.2B/B+树"></a>1.2B/B+树</h4><p><strong>////引用</strong></p><h3 id="3-2索引的实现"><a href="#3-2索引的实现" class="headerlink" title="3.2索引的实现"></a>3.2索引的实现</h3><h3 id="3-2-0相关数据结构的区别"><a href="#3-2-0相关数据结构的区别" class="headerlink" title="3.2.0相关数据结构的区别"></a>3.2.0相关数据结构的区别</h3><ul><li>二叉树与B/B+树的区别：二叉树<strong>优化比较次数</strong>，B/B+树<strong>优化磁盘读写次数</strong></li><li>B树与B+树的区别：B+树的数据都存放在叶子结点中</li><li>B树和二叉搜索树（如红黑树）的区别：B树的每一个结点可以存放多个数据，这样可以优化硬盘的读写速度</li></ul><h3 id="3-2-1-B树"><a href="#3-2-1-B树" class="headerlink" title="3.2.1 B树"></a>3.2.1 B树</h3><h4 id="定义（m阶B树）："><a href="#定义（m阶B树）：" class="headerlink" title="定义（m阶B树）："></a>定义（m阶B树）：</h4><ul><li>每个非叶子节点（除根外）至多有m个子结点，至少有向上取整【m/2】个子结点</li><li>根节点（如果不是叶子）至少有两个子结点</li><li>所有叶子节点在同一层</li><li>每个非根结点都包含k个元素（关键字），这里m/2≤k&lt;m，这里m/2向下取整。</li></ul><h4 id="实例：如何插入-删除一颗B树"><a href="#实例：如何插入-删除一颗B树" class="headerlink" title="实例：如何插入/删除一颗B树"></a>实例：<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">如何插入/删除一颗B树</a></h4><p>插入总体思路：先将元素直接按大小插入对应结点中，如果结点中元素数量&gt;=m-1，则进行分裂（向上分裂）</p><p>删除总体思路：将元素删除后，如果结点中元素数量&lt;m/2(向下取整)，则进行合并操作</p><h3 id="3-2-2-B-树"><a href="#3-2-2-B-树" class="headerlink" title="3.2.2 B+树"></a>3.2.2 B+树</h3><h4 id="定义（m阶B-树，在B树上的优化）："><a href="#定义（m阶B-树，在B树上的优化）：" class="headerlink" title="定义（m阶B+树，在B树上的优化）："></a>定义（m阶B+树，在B树上的优化）：</h4><ul><li>非叶子节点只做索引，不存储实际信息</li><li>所有的叶子结点中包含了全部元素的实际信息</li><li>所有叶子节点之间都有一个链指针</li></ul><h4 id="实例：如何插入-删除一颗B-树"><a href="#实例：如何插入-删除一颗B-树" class="headerlink" title="实例：如何插入/删除一颗B+树"></a>实例：<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">如何插入/删除一颗B+树</a></h4><p>总体思路与B树差不多，只是在分裂结点时，只是将关键元素复制一遍后分裂</p><h3 id="3-2-3为什么B-Tree更适合用来做存储索引"><a href="#3-2-3为什么B-Tree更适合用来做存储索引" class="headerlink" title="3.2.3为什么B+Tree更适合用来做存储索引"></a>3.2.3为什么B+Tree更适合用来做存储索引</h3><ul><li>B+树的磁盘读写代价更低</li><li>B+树的查询效率更加稳定</li><li>B+树更有利于对数据库的扫描（叶子节点有链表指针链接）</li></ul><p><strong>////////引用</strong></p><h4 id="1-3Hash索引"><a href="#1-3Hash索引" class="headerlink" title="1.3Hash索引"></a>1.3Hash索引</h4><p>优点：</p><ul><li><strong>查找效率高</strong></li></ul><p>缺点：</p><ul><li>仅能满足“=”，<strong>不能使用范围查询</strong></li><li>无法被用来避免数据的<strong>排序操作</strong></li><li>不能利用部分索引键？查询（B+树支持）</li><li>不能避免表扫描？</li><li>遇到大量Hash值相等的情况后性能并不一定就会比B-Tree高</li></ul><h4 id="1-4BitMap"><a href="#1-4BitMap" class="headerlink" title="1.4BitMap"></a>1.4BitMap</h4><h3 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2.索引分类"></a>2.索引分类</h3><h4 id="2-1密集索引和稀疏索引的区别"><a href="#2-1密集索引和稀疏索引的区别" class="headerlink" title="2.1密集索引和稀疏索引的区别"></a>2.1密集索引和稀疏索引的区别</h4><ul><li>密集索引文件中的每个搜索码都对应一个索引值(这就可以理解为<strong>叶子结点不但需要保存键值,还保存位于同一行记录的其他列信息</strong>。由于密集索引决定了表的物理排列顺序，<strong>一个表只有一个物理排列顺序</strong>，所以一个表只能创建一个密集索引)</li><li>稀疏索引文件只为索引码的某些值建立索引项(这可以理解为<strong>叶子结点只保存了键位信息以及该行数据的地址</strong>，有的稀疏索引只保存了键位信息主键)</li></ul><h4 id="2-1MySQL中InnoDB和MyISAM索引的区别"><a href="#2-1MySQL中InnoDB和MyISAM索引的区别" class="headerlink" title="2.1MySQL中InnoDB和MyISAM索引的区别"></a>2.1MySQL中InnoDB和MyISAM索引的区别</h4><p><strong>InnoDB:聚簇表分布</strong></p><ul><li>只有一个<strong>主键索引为密集索引,其他都是稀疏索引</strong></li></ul><p>主键索引(密集索引)的选取</p><ul><li>若一个主键被定义,该主键为密集索引</li><li>若没有主键被定义,该表的第一个唯一非空索引作为密集索引</li><li>若不满足以上条件,innoDB内部会生成一个隐藏主键(密集索引)</li><li>非主键索引存储 <strong>相关键位与其对应的主键值</strong>,之后查找主键索引来获取数据,<strong>包含两次查找</strong></li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/e8c6cc75986aa242aa67426e2d7dcd1c.jpeg" alt="InnoDB的密集索引"></p><p>非主键索引的两次查找</p><ul><li>在<strong>非主键稀疏索引</strong>中查找出该行数据对应的主键</li><li>将该主键在<strong>主键的密集索引</strong>中查出整行的所有信息</li></ul><p><strong>MyISAM:非聚簇分布</strong></p><ul><li>无论主键还是什么都是<strong>稀疏索引</strong></li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/c976d0ec57537f269f37b43d62e78bca.jpeg" alt="MyISAM稀疏索引"></p><ul><li>主键索引和辅助键索引没有区别,只是存储的键值不一样</li><li><strong>索引和数据分开存储</strong></li><li>稀疏索引查找后会得到一个数据的存储地址,对应查询的结果</li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/0944b3986fd7e6ecfe21e80d7813965c.png" alt="InnoDB和MyISAM文件存储区别"></p><h3 id="3-如何定位并优化MySQL"><a href="#3-如何定位并优化MySQL" class="headerlink" title="3.如何定位并优化MySQL"></a>3.如何定位并优化MySQL</h3><p><strong>大致思路:</strong></p><ul><li>根据<strong>慢日志</strong>定位慢查询sql</li><li>使用explain等工具分析sql</li><li>修改sql或者尽量让sql走索引</li></ul><p><strong>慢日志:</strong></p><ul><li>默认慢日志关闭,可以通过命令(改变参数)开启慢日志,慢日志会记录所有被认为是慢查询的记录</li><li>修改<strong>long_query_time</strong> : 超过这个阀值会被判定为慢查询</li><li><strong>slow_queries</strong> : 本次会话中的慢查询次数</li></ul><p><strong>explain工具(在sql语句前加explain字段,用于分析sql语句):</strong></p><ul><li>type字段 : <strong>index、all</strong>表示全表查询,可能需要优化</li><li>extra字段 :</li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/80e1fcabc5972452605b4168769a1198.jpeg" alt="extra字段"></p><p><strong>修改优化sql:</strong></p><ul><li>添加索引 : <strong>alter table</strong> person_info <strong>add inedex</strong> idx_name(name)</li><li>选择最优索引 : 有时候InnoDB优化器选择的索引方式不一定最优,需要根据实际情况调优</li></ul><h3 id="4-联合索引"><a href="#4-联合索引" class="headerlink" title="4.联合索引"></a>4.联合索引</h3><p><strong>定义:对多个字段同时建立的索引</strong></p><h4 id="4-1最左匹配原则"><a href="#4-1最左匹配原则" class="headerlink" title="4.1最左匹配原则"></a>4.1最左匹配原则</h4><ul><li>mysql会一直向右匹配直到<strong>遇到范围查询</strong>（&gt;、&lt;、beteewn、like）就<strong>停止匹配</strong>（比如建立索引(a,b,c,d),那么a=1 and b=2 and c&gt;5 and d=6中d就用不到索引<strong>,其中a和b的顺序是任意的</strong>）</li></ul><h4 id="4-2联合索引的最左匹配原则的成因"><a href="#4-2联合索引的最左匹配原则的成因" class="headerlink" title="4.2联合索引的最左匹配原则的成因"></a>4.2联合索引的最左匹配原则的成因</h4><ul><li>mysql在创建联合索引时, 会先对最左边第一个字段进行排序, 在第一个字段排序的基础上再一次比较第二个字段以及后面的字段, 最后得到索引的数据</li><li>因此如果不从最左边的开始匹配, 就无法得到后面排序的结果</li></ul><h4 id="4-3索引建立得越多越好吗"><a href="#4-3索引建立得越多越好吗" class="headerlink" title="4.3索引建立得越多越好吗?"></a>4.3索引建立得越多越好吗?</h4><ul><li><strong>数据量小</strong>的表不需要建立索引，建立<strong>会增加额外的索引开销</strong></li><li>数据变更需要维护索引，因此更多的索引意味着<strong>更多的维护成本</strong></li><li>更多的索引意味着也需要<strong>更多的空间</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-解决的问题&quot;&gt;&lt;a href=&quot;#0-解决的问题&quot; class=&quot;headerlink&quot; title=&quot;0.解决的问题&quot;&gt;&lt;/a&gt;0.解决的问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;为什么要使用索引–&amp;gt;&lt;strong&gt;因为索引可以避免全表扫描,提升查找数据的效率,
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>7.机器人运动-DFS和BFS</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer07/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer07/</id>
    <published>2020-05-13T08:05:53.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h4 id="思路一：深度优先遍历DFS"><a href="#思路一：深度优先遍历DFS" class="headerlink" title="思路一：深度优先遍历DFS"></a>思路一：深度优先遍历DFS</h4><ul><li>深度优先搜索： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li><li>剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。</li></ul><h5 id="算法解析："><a href="#算法解析：" class="headerlink" title="算法解析："></a>算法解析：</h5><ul><li>递归参数： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。</li><li>终止条件： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 00 ，代表不计入可达解。</li><li>递推工作</li><li><ul><li>标记当前单元格 ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。</li><li>搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。</li><li>回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m,n,k;</span><br><span class="line"><span class="keyword">boolean</span>[][] visited;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;<span class="keyword">this</span>.n = n;<span class="keyword">this</span>.k = k;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> Si, <span class="keyword">int</span> Sj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=m||j&gt;=n||Si+Sj&gt;k||visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + dfs(i,j+<span class="number">1</span>,Si,(j+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>?Sj-<span class="number">8</span>:Sj+<span class="number">1</span>) + dfs(i+<span class="number">1</span>,j,(i+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>?Si-<span class="number">8</span>:Si+<span class="number">1</span>,Sj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二：BFS，一层一层的遍历，直到到达最后一层（运用队列）"><a href="#思路二：BFS，一层一层的遍历，直到到达最后一层（运用队列）" class="headerlink" title="思路二：BFS，一层一层的遍历，直到到达最后一层（运用队列）"></a>思路二：<strong>BFS，一层一层的遍历，直到到达最后一层（运用队列）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span>[] x = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> i = x[<span class="number">0</span>], j = x[<span class="number">1</span>], Si = x[<span class="number">2</span>], Sj = x[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m||j&gt;=n||Si+Sj&gt;k||visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        res ++;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j+<span class="number">1</span>,Si,(Sj+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>?Sj-<span class="number">8</span>:Sj+<span class="number">1</span>&#125;);</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,j,(Si+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>?Si-<span class="number">8</span>:Si+<span class="number">1</span>.Sj&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>6.矩阵中的路径-DFS</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer06/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer06/</id>
    <published>2020-05-13T08:04:10.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：深度优先遍历+回溯。从第一个字符开始遍历，如果等于目标字符，则遍历它的上下左右四个位置是否也满足条件，如果满足就继续向下搜寻，如果不满足，则回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(board,words,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] words, <span class="keyword">int</span> i,<span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=board.length||j&gt;=board[<span class="number">0</span>].length||i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||words[k]!=board[i][j]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(k==words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">    board[i][j] = <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">boolean</span> res = dfs(board,words,i+<span class="number">1</span>,j,k+<span class="number">1</span>)||dfs(board,words,i,j+<span class="number">1</span>,k+<span class="number">1</span>)</span><br><span class="line">            ||dfs(board, words, i-<span class="number">1</span>, j, k+<span class="number">1</span>)||dfs(board, words, i, j-<span class="number">1</span>, k+<span class="number">1</span>);</span><br><span class="line">    board[i][j] = temp;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>5.斐波拉契-动态规划</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer05/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer05/</id>
    <published>2020-05-13T08:02:30.000Z</published>
    <updated>2020-06-08T03:51:41.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><p>F(0) = 0,  F(1) = 1<br>F(N) = F(N – 1) + F(N – 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/3b54a4ce1a386fdb2e39819d540161d5.png" alt="斐波那契数列的动态规划"></p><p><strong>动态规划解析：</strong><br><strong>状态定义</strong>： 设 dp为一维数组，其中 dp[i] 的值代表 斐波那契数列第 ii 个数字 。<br><strong>转移方程</strong>： dp[i + 1] = dp[i] + dp[i – 1]，即对应数列定义 f(n + 1) = f(n) + f(n – 1) ；<br><strong>初始状态</strong>： dp[0]=0, dp[1] = 1 ，即初始化前两个数字；<br><strong>返回值</strong>： dp[n] ，即斐波那契数列的第 nn 个数字。</p><p><a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">动态规划算法参考博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：&lt;/p&gt;
&lt;p&gt;F(0) 
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
</feed>
