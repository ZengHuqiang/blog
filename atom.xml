<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空空白的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kongkongbai.com/"/>
  <updated>2020-06-03T03:15:14.572Z</updated>
  <id>http://www.kongkongbai.com/</id>
  
  <author>
    <name>kongkongbai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>12.二叉搜索树的后序遍历序列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer12/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer12/</id>
    <published>2020-06-03T03:07:00.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><pre><code>     5   / \  2   6 / \1   3</code></pre><p>示例 1：</p><p>输入: [1,6,3,2,5]<br>输出: false<br>示例 2：</p><p>输入: [1,3,2,6,5]<br>输出: true</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：递归分治"><a href="#思路一：递归分治" class="headerlink" title="思路一：递归分治"></a>思路一：递归分治</h5><p>所有的子树都满足，左子树&lt;根&lt;右子树</p><p>如何判断哪里为左子树，哪里为右子树？最后一个结点为根，从开始出发，小于根的为左子树，其余为右子树</p><p>如何判断这棵树满足 左子树&lt;根&lt;右子树？从开始序列出发，保证刚刚分出来的左子树序列全部小于根，右子树序列全部大于根</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recue(postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recue</span><span class="params">(<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> p = i;</span><br><span class="line">    <span class="comment">//找到右子树的开始序号</span></span><br><span class="line">    <span class="keyword">while</span>(postorder[p]&lt;postorder[j]) p++;</span><br><span class="line">    <span class="keyword">int</span> m = p;</span><br><span class="line">    <span class="comment">//找到右子树的末尾序号</span></span><br><span class="line">    <span class="keyword">while</span>(postorder[p]&gt;postorder[j]) p++;</span><br><span class="line">    <span class="keyword">return</span> p==j&amp;&amp;recue(postorder,i,m-<span class="number">1</span>)&amp;&amp;recue(postorder,m,j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：单调辅助栈，还没看懂，基本思路是将后序遍历翻转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单调栈使用，单调递增的单调栈</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 表示上一个根节点的元素，这里可以把postorder的最后一个元素root看成无穷大节点的左孩子</span></span><br><span class="line">    <span class="keyword">int</span> pervElem = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 逆向遍历，就是翻转的先序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">// 左子树元素必须要小于递增栈被peek访问的元素，否则就不是二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> (postorder[i] &gt; pervElem)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; postorder[i] &lt; stack.peek())&#123;</span><br><span class="line">            <span class="comment">// 数组元素小于单调栈的元素了，表示往左子树走了，记录下上个根节点</span></span><br><span class="line">            <span class="comment">// 找到这个左子树对应的根节点，之前右子树全部弹出，不再记录，因为不可能在往根节点的右子树走了</span></span><br><span class="line">            pervElem = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个新元素入栈</span></span><br><span class="line">        stack.push(postorder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>11.栈的弹出序列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer11/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer11/</id>
    <published>2020-06-01T08:09:18.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：利用辅助栈模拟出入栈"><a href="#思路一：利用辅助栈模拟出入栈" class="headerlink" title="思路一：利用辅助栈模拟出入栈"></a>思路一：利用辅助栈模拟出入栈</h5><p>考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</p><p><strong>入栈操作</strong>： 按照压栈序列的顺序执行。<br><strong>出栈操作</strong>： 每次入栈后，<strong>循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立</strong>，将符合弹出序列顺序的栈顶元素全部弹出。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushed.length;i++)&#123;</span><br><span class="line">        s.push(pushed[i]);</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty()&amp;&amp;popped[index]==s.peek())&#123;</span><br><span class="line">            index++;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.isEmpty()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>10.树的子结构</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer10/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer10/</id>
    <published>2020-05-25T13:37:13.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><pre><code> 3/ \4   5  / \ 1   2</code></pre><p>给定的树 B：</p><p>   4<br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：深度优先遍历（先序遍历）+递归判断</p><ul><li>先序遍历树A的每个节点An</li><li>判断树A中以<strong>An为根节点的子树是否以相同根节点包含树B</strong></li></ul><h5 id="如何判断A树是否以相同根节点包含树B呢？"><a href="#如何判断A树是否以相同根节点包含树B呢？" class="headerlink" title="如何判断A树是否以相同根节点包含树B呢？"></a>如何判断A树是否以相同根节点包含树B呢？</h5><ul><li>如果树B为空，说明路径匹配成功，返回true</li><li>如果树A为空 或者 树A根节点值与树B不同，返回false</li><li>递归判断 (A.left, B.left) 与 (A.right, B.right)是否也满足条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (A!=<span class="keyword">null</span>&amp;&amp;B!=<span class="keyword">null</span>)&amp;&amp;(recure(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recure</span><span class="params">(TreeNode A, TreeNode B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.val!=B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> recure(A.left,B.left)&amp;&amp;recure(A.right,B.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;p&gt;B是A的子结构， 即 A中有
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>9.正则表达式</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer09/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer09/</id>
    <published>2020-05-24T04:50:09.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目（较难）"><a href="#1-题目（较难）" class="headerlink" title="1.题目（较难）"></a>1.题目（较难）</h3><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a>思路一：动态规划</h5><p><img src="https://pic.rmb.bdstatic.com/bjh/fd8f9b644377521e8df1d3ba3f2981ad.png" alt="image-20200524124527719"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/d2628a28ee50ae8d1d809aaed6d84ec2.png" alt="image-20200524124558964"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> m = p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                f[i][j] = (i==<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)!=<span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;(s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>)||p.charAt(j-<span class="number">1</span>)==<span class="string">'.'</span>))&#123;</span><br><span class="line">                        f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        f[i][j] = f[i][j-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">2</span>&amp;&amp;(s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">2</span>)||p.charAt(j-<span class="number">2</span>)==<span class="string">'.'</span>))&#123;</span><br><span class="line">                        f[i][j] = f[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目（较难）&quot;&gt;&lt;a href=&quot;#1-题目（较难）&quot; class=&quot;headerlink&quot; title=&quot;1.题目（较难）&quot;&gt;&lt;/a&gt;1.题目（较难）&lt;/h3&gt;&lt;p&gt;请实现一个函数用来匹配包含’. ‘和’&lt;em&gt;‘的正则表达式。模式中的字符’.’表示任意一个
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>9.打印从1到最大的n位数</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer08/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer08/</id>
    <published>2020-05-20T07:33:36.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>本题主要考察如何处理超过int、long阀值的数；这时肯定不能用数值来表示要打印的数，而需要借助字符串</p><p>increment函数，若发生进位则一直进行for循环，直到不产生进位则break。如果i为0（即到了最高位）还发生了进位，则设置isOverflow为true，并返回至主函数的while判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// 将str初始化为n个'0'字符组成的字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        str.append(<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!increment(str))&#123;</span><br><span class="line">        <span class="comment">// 去掉左侧的0</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; str.length() &amp;&amp; str.charAt(index) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(str.toString().substring(index)+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">increment</span><span class="params">(StringBuilder str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isOverflow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">char</span> s = (<span class="keyword">char</span>)(str.charAt(i) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果s大于'9'则发生进位</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            str.replace(i, i + <span class="number">1</span>, <span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                isOverflow = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没发生进位则跳出for循环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            str.replace(i, i + <span class="number">1</span>, String.valueOf(s));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOverflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入数字 &lt;code&gt;n&lt;/code&gt;，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>8.快速幂运算</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer08/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer08/</id>
    <published>2020-05-20T06:58:13.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>说明:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] </li></ul><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：二进制角度"><a href="#思路一：二进制角度" class="headerlink" title="思路一：二进制角度"></a><strong>思路一：二进制角度</strong></h5><p><img src="https://pic.rmb.bdstatic.com/bjh/cfe0dae9267127f30c563da674b2d914.png" alt="01"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/3baa061fda1521a6dbc9928f95e8f305.png" alt="TIM截图20200520145209"></p><p><strong>特别注意：虽然不考虑大数，但是要考虑最小的负数情况，它的相反数会发生溢出，所以需要long类型进行控制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>/x;</span><br><span class="line">        N = -N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastPow(x,N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>) res = res*x;</span><br><span class="line">        x = x*x;</span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="思路二：分治思想，递归"><a href="#思路二：分治思想，递归" class="headerlink" title="思路二：分治思想，递归"></a>思路二：分治思想，递归</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        N = -N;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/fastPow(x,N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastPow(x,N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> s = fastPow(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> s*s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> s = fastPow(x,(n-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> s*s*x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;实现函数double Power(double base, int exponent)，求base的exponent次方。不
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>MySQL语法模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLGrammar/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLGrammar/</id>
    <published>2020-05-13T08:18:34.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<p><strong>三张表实例：</strong></p><ul><li>course：course_id、course_name</li><li>student：studen_id、student_name</li><li>score：student_id、course_id、score</li></ul><h4 id="1-Group-By"><a href="#1-Group-By" class="headerlink" title="1.Group By"></a>1.Group By</h4><ul><li>满足“Select子句中的列名必须满足为分组列（group by中的列名）或列函数”（只针对需要聚合的一个表）</li><li>列函数对于group by子句定义的每个组各返回一个结果</li></ul><p>例1：查询所有同学的学号、选课数、总成绩</p><p>例2：查询所有同学的学号、姓名、选课数、总成绩</p><p>select s.student_id, stu.name, count(s.course_id), sum(s.score)<br>from score s, student stu<br>group by s.student_id;</p><h4 id="2-Having"><a href="#2-Having" class="headerlink" title="2.Having"></a>2.Having</h4><ul><li>通常与Group by 子句一起使用</li><li>where过滤行，Having过滤组</li><li>出现在同一sql的顺序：Where&gt;Group by &gt;Having</li></ul><p>例1：查询平均成绩大于60分的同学的学号和平均成绩</p><p>select student_id, avg(score)<br>from score<br>group by student_id<br>having avg(score) &gt; 60;</p><p>例2：取出student_id为1学生的学生情况</p><p>select * from score having student_id = 1;</p><p>例3：查询没有学全所有课的同学的学号和姓名</p><p>select student_id, name<br>from score, course,</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;三张表实例：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;course：course_id、course_name&lt;/li&gt;
&lt;li&gt;student：studen_id、student_name&lt;/li&gt;
&lt;li&gt;score：student_id、cours
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLTransaction/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLTransaction/</id>
    <published>2020-05-13T08:18:15.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySql只有InnoDB支持事务系统"><a href="#MySql只有InnoDB支持事务系统" class="headerlink" title="MySql只有InnoDB支持事务系统"></a>MySql只有InnoDB支持事务系统</h3><ul><li><strong>MySQL</strong>默认隔离级别为：<strong>Repeatable Read</strong></li><li><strong>Oracle</strong>默认隔离级别为：<strong>Read Commited</strong></li></ul><h3 id="1-数据库的四大特性——ACID"><a href="#1-数据库的四大特性——ACID" class="headerlink" title="1.数据库的四大特性——ACID"></a>1.数据库的四大特性——ACID</h3><ul><li><strong>Atomicity</strong>（原子性）：一个事务中的操作要么全部执行，要么全部不执行</li><li><strong>Consistency</strong>（一致性）：指事务开始之前和结束之后，数据库的完整性约束没有被破坏</li><li><strong>Isolation</strong>（隔离性）：指多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果</li><li><strong>Durability</strong>（持久性）：事务完成之后对数据库的修改是持久性的，不会被回滚</li></ul><h3 id="2-事务的隔离性"><a href="#2-事务的隔离性" class="headerlink" title="2.事务的隔离性"></a>2.事务的隔离性</h3><p><a href="https://blog.csdn.net/CoderBruis/article/details/102692753" target="_blank" rel="noopener">参考博客</a></p><h4 id="2-1事务的隔离级别"><a href="#2-1事务的隔离级别" class="headerlink" title="2.1事务的隔离级别"></a>2.1事务的隔离级别</h4><ul><li><strong>Read uncommitted</strong>:一个事务可以读取另一个未提交事务的数据<strong>（无法避免脏读）</strong></li><li><strong>Read committed</strong>:一个事务要等另一个事务提交后才能读取数据（<strong>无法避免update和insert操作带来的幻读问题</strong>）</li><li><strong>Repeatable read:</strong>就是在开始读取数据（事务开启）时，不再允许修改操作(<strong>无法避免insert操作带来的幻读问题</strong>)</li><li><strong>Serializable:</strong>事务串行化顺序执行</li></ul><h4 id="2-2事务并发访问可能导致的问题"><a href="#2-2事务并发访问可能导致的问题" class="headerlink" title="2.2事务并发访问可能导致的问题"></a>2.2事务并发访问可能导致的问题</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/88cc8399da5f90a0be2a5630f426d15f.jpeg" alt="事务隔离级别"></p><ul><li><strong>脏读</strong>：脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。</li><li><strong>不可重复读</strong>：（同时操作，事务一分别读取事务二操作时和提交后的数据，读取的记录内容不一致）不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。</li><li><strong>幻读</strong>：和可重复读类似，但是事务二的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致</li><li>InnoDB Repeatable read级别下可以避免幻读</li></ul><h4 id="2-3InnoDB-Repeatable-read级别下如何避免幻读"><a href="#2-3InnoDB-Repeatable-read级别下如何避免幻读" class="headerlink" title="2.3InnoDB Repeatable read级别下如何避免幻读"></a>2.3InnoDB <strong>Repeatable read级别下如何避免幻读</strong></h4><p><a href="https://blog.csdn.net/xifeijian/article/details/20313977#t10" target="_blank" rel="noopener">（参考博客）</a></p><ul><li>表象：快照读（非阻塞读）——伪MVCC（多版本的并发控制）</li><li>内在：next-key锁（行锁+gap锁）</li></ul><h5 id="2-3-1当前读和快照读"><a href="#2-3-1当前读和快照读" class="headerlink" title="2.3.1当前读和快照读"></a>2.3.1当前读和快照读</h5><ul><li>当前读：加了锁的增删改查操作(select…lock in share mode;select…for update; update 、delete、insert)</li><li>快照读：不加锁的非阻塞读，select</li></ul><p><strong>区别：</strong></p><ul><li>read committed级别下。当前读与快照读读取的版本一样。</li><li>repeatable read 级别下，当前读返回的是数据的最新版本，<strong>快照读返回的可能数据未修改前的版本也可能是最新的数据版本</strong>。因为在RR级别下，事务调用快照读的时机很重要，创建快照的时机决定了读取的版本。</li></ul><h5 id="2-3-2RC、RR级别下InnoDB的非阻塞读-快照读-如何实现"><a href="#2-3-2RC、RR级别下InnoDB的非阻塞读-快照读-如何实现" class="headerlink" title="2.3.2RC、RR级别下InnoDB的非阻塞读(快照读)如何实现"></a>2.3.2RC、RR级别下InnoDB的非阻塞读(快照读)如何实现</h5><ul><li>数据行里的<strong>DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID</strong>字段</li></ul><p>1.DB_TRX_ID—-该字段标明最近一次对数据做修改（事务ID）<br>2.DB_ROLL_PTR—-回滚指针，写入<strong>回滚段的undo日志</strong><br>3.DB__ROW_ID —-行号 随着新行出现单调递增的id</p><ul><li>undo日志：主要分为<strong>insert undo</strong>日志（事务回滚涉及）和<strong>uodate undo</strong>日志（事务回滚和快照读都涉及）对事务变更就会产生undo记录，存储的是老版数据，事务回滚需要</li><li>read view：可见性判断来决定当前看的是哪个版本数据</li></ul><p><strong>实现的具体过程：</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/0eb3675fe478e80f6681717c2ed10aec.png" alt="快照读的实现"></p><p>比如现在有一个记录Field1、Field2、Field3数据分别为11、12、13，现在事务要修改该记录，将Field2修改为32。则这条记录首先会加载X锁，首先undo log中会拷贝一条修改前的记录，并赋值DB_ROW_ID。此时被X锁锁住的记录的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID分别进行赋值，并且DB_ROLL_PTR的记录会指向undo log中的DB_ROW_ID的值。</p><p><strong>RR的快照读出现旧数据的原因：</strong></p><p>如果在数据更新之前进行了一次快照读，事务会保存数据库的快照在undo log中，如果此时其他事务更新了数据，那么快照读依旧会沿用undo log中的数据，此时数据不再是最新数据。</p><h5 id="2-3-3内在：next-key锁（行锁-Gap锁）"><a href="#2-3-3内在：next-key锁（行锁-Gap锁）" class="headerlink" title="2.3.3内在：next-key锁（行锁+Gap锁）"></a>2.3.3内在：next-key锁（行锁+Gap锁）</h5><h5 id="2-3-3Gap锁"><a href="#2-3-3Gap锁" class="headerlink" title="2.3.3Gap锁"></a>2.3.3Gap锁</h5><p><strong>什么时候会用到Gap锁？</strong></p><ul><li>只有在RR和Serializable级别下</li><li>如果<strong>where条件全部命中</strong>，<strong>则不会用Gap锁</strong>，只会加行锁（因为如果条件全部命中，记录就存在唯一性，新增的记录不会产生幻读现象）</li><li>如果<strong>where条件部分命中或者全不命中，则会加Gap锁</strong></li><li>Gap锁会用在<strong>非唯一索引或者不走索引的当前读</strong>中</li></ul><ol><li>非唯一索引：加锁范围为与相邻非唯一键的区间中，左边&lt;=gap&lt;=右边，还与主键的字母排序有关（<strong>本质是与B+数的排列有关</strong>）</li><li>不走索引：会锁住所有的键</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MySql只有InnoDB支持事务系统&quot;&gt;&lt;a href=&quot;#MySql只有InnoDB支持事务系统&quot; class=&quot;headerlink&quot; title=&quot;MySql只有InnoDB支持事务系统&quot;&gt;&lt;/a&gt;MySql只有InnoDB支持事务系统&lt;/h3&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLLock/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLLock/</id>
    <published>2020-05-13T08:18:00.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-常见问题"><a href="#0-常见问题" class="headerlink" title="0.常见问题"></a>0.常见问题</h4><ul><li>MyISAM与InnoDB关于锁方面的区别是什么？</li><li>数据库事务的四大特性</li><li>事务隔离级别以及各级别下的并发访问问题</li><li>InnoDB可重复度隔离级别下如何避免幻读</li><li>RC、RR级别下的InnoDB的非阻塞读如何实现</li></ul><h3 id="1-MyISAM与InnoDB关于锁方面的区别"><a href="#1-MyISAM与InnoDB关于锁方面的区别" class="headerlink" title="1.MyISAM与InnoDB关于锁方面的区别"></a>1.MyISAM与InnoDB关于锁方面的区别</h3><p><a href="https://blog.csdn.net/xifeijian/article/details/20313977#t10" target="_blank" rel="noopener">（参考博客）！非常详细</a></p><ul><li>MyISAM默认用的表级锁，不支持行级锁</li><li>InnoDB默认用的行级锁，也支持表级锁</li></ul><h4 id="1-1MyISAM：表级锁"><a href="#1-1MyISAM：表级锁" class="headerlink" title="1.1MyISAM：表级锁"></a>1.1MyISAM：表级锁</h4><ul><li>在对数据表进行select操作时，MyISAM会为该表加上一个表的<strong>读锁（共享锁）</strong>，在对数据表进行增删改时，MyISAM会为该表叫上一个<strong>写锁（排它锁）</strong></li><li><strong>两个锁互斥</strong>，必须等另一种锁释放之后，才能加上不同种类的锁</li><li>读锁与读锁之间不互斥，<strong>写锁与写锁之间会发生互斥</strong></li><li>显式的加锁：<strong>lock table</strong> XXX <strong>read</strong>(或者<strong>write</strong>) ；解锁：unlock table</li></ul><h4 id="1-2InnoDB：索引时用行级锁，非索引时用表级锁"><a href="#1-2InnoDB：索引时用行级锁，非索引时用表级锁" class="headerlink" title="1.2InnoDB：索引时用行级锁，非索引时用表级锁"></a>1.2InnoDB：索引时用行级锁，非索引时用表级锁</h4><ul><li>相对于表级锁，<strong>行级锁只对操作的行数进行加锁操作</strong>，其锁的行为与表级锁一致</li><li>显式的对某行加锁：在末尾加<strong>lock in share mode（加读锁）</strong>；<strong>for update（加写锁）</strong></li></ul><h4 id="如何加表锁？"><a href="#如何加表锁？" class="headerlink" title="如何加表锁？"></a><strong>如何加表锁？</strong></h4><ul><li>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</li><li>在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。<strong>这也正是MyISAM表不会出现死锁（Deadlock Free）的原因</strong>。</li></ul><h4 id="如何加行锁？"><a href="#如何加行锁？" class="headerlink" title="如何加行锁？"></a>如何加行锁？</h4><ul><li><p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><p>¡ 共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。</p><p>¡ 排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。</p></li><li><p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的</strong>，这一点MySQL与Oracle不同，后者是<strong>通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p></li></ul><h4 id="1-3MyISAM适合的场景"><a href="#1-3MyISAM适合的场景" class="headerlink" title="1.3MyISAM适合的场景"></a>1.3MyISAM适合的场景</h4><ul><li>频繁执行全表count语句（<strong>MyISAM会保存一个表行数的变量</strong>，InnoDB则需要重新扫描全表）</li><li>对数据进行增删改的频率不高，查询非常频繁（MyISAM增删改会涉及锁表操作，InnoDB只会锁行）</li><li>没有事务</li></ul><h4 id="1-4InnoDB适合的场景"><a href="#1-4InnoDB适合的场景" class="headerlink" title="1.4InnoDB适合的场景"></a>1.4InnoDB适合的场景</h4><ul><li>数据增删改查都相当频繁（InnoDB只锁行，避免很多操作的阻塞）</li><li>可靠性要求比较高，要求支持事务</li></ul><h4 id="1-5数据库锁的分类"><a href="#1-5数据库锁的分类" class="headerlink" title="1.5数据库锁的分类"></a>1.5数据库锁的分类</h4><ul><li>按锁的粒度划分，可分为<strong>表级锁、行级锁、页级锁</strong>（介于两者之间）</li><li>按锁级别划分，可分为<strong>共享锁、排它锁</strong></li><li>按加锁方式划分，可分为<strong>自动锁、显式锁</strong></li><li>按操作划分，可分为<strong>DML锁</strong>（对数据上的锁）、<strong>DDL锁</strong>（对表结构上的锁）</li><li>按使用方式划分，可分为<strong>乐观锁</strong>（通过加版本号或时间戳来实现，更新提交时检查版本号是否对应）<strong>、悲观锁</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;0-常见问题&quot;&gt;&lt;a href=&quot;#0-常见问题&quot; class=&quot;headerlink&quot; title=&quot;0.常见问题&quot;&gt;&lt;/a&gt;0.常见问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;MyISAM与InnoDB关于锁方面的区别是什么？&lt;/li&gt;
&lt;li&gt;数据库事务的四大特性&lt;/l
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLIndex/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLIndex/</id>
    <published>2020-05-13T08:17:43.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-解决的问题"><a href="#0-解决的问题" class="headerlink" title="0.解决的问题"></a>0.解决的问题</h3><ul><li>为什么要使用索引–&gt;<strong>因为索引可以避免全表扫描,提升查找数据的效率,</strong></li><li>什么样的信息能成为索引–&gt;<strong>主键、唯一键以及普通键等能够让数据存在区分的字段</strong></li><li>索引的数据结构–&gt;<strong>主流:B+树</strong></li><li>密集索引和稀疏索引的区别–&gt;看下面解答</li></ul><h3 id="1-索引实现数据结构之间的比较"><a href="#1-索引实现数据结构之间的比较" class="headerlink" title="1.索引实现数据结构之间的比较"></a>1.索引实现数据结构之间的比较</h3><h4 id="1-1二叉查找树"><a href="#1-1二叉查找树" class="headerlink" title="1.1二叉查找树"></a>1.1二叉查找树</h4><p>查找效率一般情况较高，如果出现线性情况，效率会很低</p><h4 id="1-2B-B-树"><a href="#1-2B-B-树" class="headerlink" title="1.2B/B+树"></a>1.2B/B+树</h4><p><strong>////引用</strong></p><h3 id="3-2索引的实现"><a href="#3-2索引的实现" class="headerlink" title="3.2索引的实现"></a>3.2索引的实现</h3><h3 id="3-2-0相关数据结构的区别"><a href="#3-2-0相关数据结构的区别" class="headerlink" title="3.2.0相关数据结构的区别"></a>3.2.0相关数据结构的区别</h3><ul><li>二叉树与B/B+树的区别：二叉树<strong>优化比较次数</strong>，B/B+树<strong>优化磁盘读写次数</strong></li><li>B树与B+树的区别：B+树的数据都存放在叶子结点中</li><li>B树和二叉搜索树（如红黑树）的区别：B树的每一个结点可以存放多个数据，这样可以优化硬盘的读写速度</li></ul><h3 id="3-2-1-B树"><a href="#3-2-1-B树" class="headerlink" title="3.2.1 B树"></a>3.2.1 B树</h3><h4 id="定义（m阶B树）："><a href="#定义（m阶B树）：" class="headerlink" title="定义（m阶B树）："></a>定义（m阶B树）：</h4><ul><li>每个非叶子节点（除根外）至多有m个子结点，至少有向上取整【m/2】个子结点</li><li>根节点（如果不是叶子）至少有两个子结点</li><li>所有叶子节点在同一层</li><li>每个非根结点都包含k个元素（关键字），这里m/2≤k&lt;m，这里m/2向下取整。</li></ul><h4 id="实例：如何插入-删除一颗B树"><a href="#实例：如何插入-删除一颗B树" class="headerlink" title="实例：如何插入/删除一颗B树"></a>实例：<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">如何插入/删除一颗B树</a></h4><p>插入总体思路：先将元素直接按大小插入对应结点中，如果结点中元素数量&gt;=m-1，则进行分裂（向上分裂）</p><p>删除总体思路：将元素删除后，如果结点中元素数量&lt;m/2(向下取整)，则进行合并操作</p><h3 id="3-2-2-B-树"><a href="#3-2-2-B-树" class="headerlink" title="3.2.2 B+树"></a>3.2.2 B+树</h3><h4 id="定义（m阶B-树，在B树上的优化）："><a href="#定义（m阶B-树，在B树上的优化）：" class="headerlink" title="定义（m阶B+树，在B树上的优化）："></a>定义（m阶B+树，在B树上的优化）：</h4><ul><li>非叶子节点只做索引，不存储实际信息</li><li>所有的叶子结点中包含了全部元素的实际信息</li><li>所有叶子节点之间都有一个链指针</li></ul><h4 id="实例：如何插入-删除一颗B-树"><a href="#实例：如何插入-删除一颗B-树" class="headerlink" title="实例：如何插入/删除一颗B+树"></a>实例：<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">如何插入/删除一颗B+树</a></h4><p>总体思路与B树差不多，只是在分裂结点时，只是将关键元素复制一遍后分裂</p><h3 id="3-2-3为什么B-Tree更适合用来做存储索引"><a href="#3-2-3为什么B-Tree更适合用来做存储索引" class="headerlink" title="3.2.3为什么B+Tree更适合用来做存储索引"></a>3.2.3为什么B+Tree更适合用来做存储索引</h3><ul><li>B+树的磁盘读写代价更低</li><li>B+树的查询效率更加稳定</li><li>B+树更有利于对数据库的扫描（叶子节点有链表指针链接）</li></ul><p><strong>////////引用</strong></p><h4 id="1-3Hash索引"><a href="#1-3Hash索引" class="headerlink" title="1.3Hash索引"></a>1.3Hash索引</h4><p>优点：</p><ul><li><strong>查找效率高</strong></li></ul><p>缺点：</p><ul><li>仅能满足“=”，<strong>不能使用范围查询</strong></li><li>无法被用来避免数据的<strong>排序操作</strong></li><li>不能利用部分索引键？查询（B+树支持）</li><li>不能避免表扫描？</li><li>遇到大量Hash值相等的情况后性能并不一定就会比B-Tree高</li></ul><h4 id="1-4BitMap"><a href="#1-4BitMap" class="headerlink" title="1.4BitMap"></a>1.4BitMap</h4><h3 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2.索引分类"></a>2.索引分类</h3><h4 id="2-1密集索引和稀疏索引的区别"><a href="#2-1密集索引和稀疏索引的区别" class="headerlink" title="2.1密集索引和稀疏索引的区别"></a>2.1密集索引和稀疏索引的区别</h4><ul><li>密集索引文件中的每个搜索码都对应一个索引值(这就可以理解为<strong>叶子结点不但需要保存键值,还保存位于同一行记录的其他列信息</strong>。由于密集索引决定了表的物理排列顺序，<strong>一个表只有一个物理排列顺序</strong>，所以一个表只能创建一个密集索引)</li><li>稀疏索引文件只为索引码的某些值建立索引项(这可以理解为<strong>叶子结点只保存了键位信息以及该行数据的地址</strong>，有的稀疏索引只保存了键位信息主键)</li></ul><h4 id="2-1MySQL中InnoDB和MyISAM索引的区别"><a href="#2-1MySQL中InnoDB和MyISAM索引的区别" class="headerlink" title="2.1MySQL中InnoDB和MyISAM索引的区别"></a>2.1MySQL中InnoDB和MyISAM索引的区别</h4><p><strong>InnoDB:聚簇表分布</strong></p><ul><li>只有一个<strong>主键索引为密集索引,其他都是稀疏索引</strong></li></ul><p>主键索引(密集索引)的选取</p><ul><li>若一个主键被定义,该主键为密集索引</li><li>若没有主键被定义,该表的第一个唯一非空索引作为密集索引</li><li>若不满足以上条件,innoDB内部会生成一个隐藏主键(密集索引)</li><li>非主键索引存储 <strong>相关键位与其对应的主键值</strong>,之后查找主键索引来获取数据,<strong>包含两次查找</strong></li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/e8c6cc75986aa242aa67426e2d7dcd1c.jpeg" alt="InnoDB的密集索引"></p><p>非主键索引的两次查找</p><ul><li>在<strong>非主键稀疏索引</strong>中查找出该行数据对应的主键</li><li>将该主键在<strong>主键的密集索引</strong>中查出整行的所有信息</li></ul><p><strong>MyISAM:非聚簇分布</strong></p><ul><li>无论主键还是什么都是<strong>稀疏索引</strong></li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/c976d0ec57537f269f37b43d62e78bca.jpeg" alt="MyISAM稀疏索引"></p><ul><li>主键索引和辅助键索引没有区别,只是存储的键值不一样</li><li><strong>索引和数据分开存储</strong></li><li>稀疏索引查找后会得到一个数据的存储地址,对应查询的结果</li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/0944b3986fd7e6ecfe21e80d7813965c.png" alt="InnoDB和MyISAM文件存储区别"></p><h3 id="3-如何定位并优化MySQL"><a href="#3-如何定位并优化MySQL" class="headerlink" title="3.如何定位并优化MySQL"></a>3.如何定位并优化MySQL</h3><p><strong>大致思路:</strong></p><ul><li>根据<strong>慢日志</strong>定位慢查询sql</li><li>使用explain等工具分析sql</li><li>修改sql或者尽量让sql走索引</li></ul><p><strong>慢日志:</strong></p><ul><li>默认慢日志关闭,可以通过命令(改变参数)开启慢日志,慢日志会记录所有被认为是慢查询的记录</li><li>修改<strong>long_query_time</strong> : 超过这个阀值会被判定为慢查询</li><li><strong>slow_queries</strong> : 本次会话中的慢查询次数</li></ul><p><strong>explain工具(在sql语句前加explain字段,用于分析sql语句):</strong></p><ul><li>type字段 : <strong>index、all</strong>表示全表查询,可能需要优化</li><li>extra字段 :</li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/80e1fcabc5972452605b4168769a1198.jpeg" alt="extra字段"></p><p><strong>修改优化sql:</strong></p><ul><li>添加索引 : <strong>alter table</strong> person_info <strong>add inedex</strong> idx_name(name)</li><li>选择最优索引 : 有时候InnoDB优化器选择的索引方式不一定最优,需要根据实际情况调优</li></ul><h3 id="4-联合索引"><a href="#4-联合索引" class="headerlink" title="4.联合索引"></a>4.联合索引</h3><p><strong>定义:对多个字段同时建立的索引</strong></p><h4 id="4-1最左匹配原则"><a href="#4-1最左匹配原则" class="headerlink" title="4.1最左匹配原则"></a>4.1最左匹配原则</h4><ul><li>mysql会一直向右匹配直到<strong>遇到范围查询</strong>（&gt;、&lt;、beteewn、like）就<strong>停止匹配</strong>（比如建立索引(a,b,c,d),那么a=1 and b=2 and c&gt;5 and d=6中d就用不到索引<strong>,其中a和b的顺序是任意的</strong>）</li></ul><h4 id="4-2联合索引的最左匹配原则的成因"><a href="#4-2联合索引的最左匹配原则的成因" class="headerlink" title="4.2联合索引的最左匹配原则的成因"></a>4.2联合索引的最左匹配原则的成因</h4><ul><li>mysql在创建联合索引时, 会先对最左边第一个字段进行排序, 在第一个字段排序的基础上再一次比较第二个字段以及后面的字段, 最后得到索引的数据</li><li>因此如果不从最左边的开始匹配, 就无法得到后面排序的结果</li></ul><h4 id="4-3索引建立得越多越好吗"><a href="#4-3索引建立得越多越好吗" class="headerlink" title="4.3索引建立得越多越好吗?"></a>4.3索引建立得越多越好吗?</h4><ul><li><strong>数据量小</strong>的表不需要建立索引，建立<strong>会增加额外的索引开销</strong></li><li>数据变更需要维护索引，因此更多的索引意味着<strong>更多的维护成本</strong></li><li>更多的索引意味着也需要<strong>更多的空间</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-解决的问题&quot;&gt;&lt;a href=&quot;#0-解决的问题&quot; class=&quot;headerlink&quot; title=&quot;0.解决的问题&quot;&gt;&lt;/a&gt;0.解决的问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;为什么要使用索引–&amp;gt;&lt;strong&gt;因为索引可以避免全表扫描,提升查找数据的效率,
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>7.机器人运动-DFS和BFS</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer07/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer07/</id>
    <published>2020-05-13T08:05:53.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h4 id="思路一：深度优先遍历DFS"><a href="#思路一：深度优先遍历DFS" class="headerlink" title="思路一：深度优先遍历DFS"></a>思路一：深度优先遍历DFS</h4><ul><li>深度优先搜索： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li><li>剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。</li></ul><h5 id="算法解析："><a href="#算法解析：" class="headerlink" title="算法解析："></a>算法解析：</h5><ul><li>递归参数： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。</li><li>终止条件： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 00 ，代表不计入可达解。</li><li>递推工作</li><li><ul><li>标记当前单元格 ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。</li><li>搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。</li><li>回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m,n,k;</span><br><span class="line"><span class="keyword">boolean</span>[][] visited;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;<span class="keyword">this</span>.n = n;<span class="keyword">this</span>.k = k;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> Si, <span class="keyword">int</span> Sj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=m||j&gt;=n||Si+Sj&gt;k||visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + dfs(i,j+<span class="number">1</span>,Si,(j+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>?Sj-<span class="number">8</span>:Sj+<span class="number">1</span>) + dfs(i+<span class="number">1</span>,j,(i+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>?Si-<span class="number">8</span>:Si+<span class="number">1</span>,Sj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二：BFS，一层一层的遍历，直到到达最后一层（运用队列）"><a href="#思路二：BFS，一层一层的遍历，直到到达最后一层（运用队列）" class="headerlink" title="思路二：BFS，一层一层的遍历，直到到达最后一层（运用队列）"></a>思路二：<strong>BFS，一层一层的遍历，直到到达最后一层（运用队列）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span>[] x = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> i = x[<span class="number">0</span>], j = x[<span class="number">1</span>], Si = x[<span class="number">2</span>], Sj = x[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m||j&gt;=n||Si+Sj&gt;k||visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        res ++;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j+<span class="number">1</span>,Si,(Sj+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>?Sj-<span class="number">8</span>:Sj+<span class="number">1</span>&#125;);</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,j,(Si+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>?Si-<span class="number">8</span>:Si+<span class="number">1</span>.Sj&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>6.矩阵中的路径-DFS</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer06/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer06/</id>
    <published>2020-05-13T08:04:10.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：深度优先遍历+回溯。从第一个字符开始遍历，如果等于目标字符，则遍历它的上下左右四个位置是否也满足条件，如果满足就继续向下搜寻，如果不满足，则回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(board,words,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] words, <span class="keyword">int</span> i,<span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=board.length||j&gt;=board[<span class="number">0</span>].length||i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||words[k]!=board[i][j]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(k==words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">    board[i][j] = <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">boolean</span> res = dfs(board,words,i+<span class="number">1</span>,j,k+<span class="number">1</span>)||dfs(board,words,i,j+<span class="number">1</span>,k+<span class="number">1</span>)</span><br><span class="line">            ||dfs(board, words, i-<span class="number">1</span>, j, k+<span class="number">1</span>)||dfs(board, words, i, j-<span class="number">1</span>, k+<span class="number">1</span>);</span><br><span class="line">    board[i][j] = temp;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>5.斐波拉契-动态规划</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer05/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer05/</id>
    <published>2020-05-13T08:02:30.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><p>F(0) = 0,  F(1) = 1<br>F(N) = F(N – 1) + F(N – 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/3b54a4ce1a386fdb2e39819d540161d5.png" alt="斐波那契数列的动态规划"></p><p><strong>动态规划解析：</strong><br><strong>状态定义</strong>： 设 dp为一维数组，其中 dp[i] 的值代表 斐波那契数列第 ii 个数字 。<br><strong>转移方程</strong>： dp[i + 1] = dp[i] + dp[i – 1]，即对应数列定义 f(n + 1) = f(n) + f(n – 1) ；<br><strong>初始状态</strong>： dp[0]=0, dp[1] = 1 ，即初始化前两个数字；<br><strong>返回值</strong>： dp[n] ，即斐波那契数列的第 nn 个数字。</p><p><a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">动态规划算法参考博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：&lt;/p&gt;
&lt;p&gt;F(0) 
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>4.使用双栈实现队列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer04/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer04/</id>
    <published>2020-05-13T08:00:57.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路：插入时，先将s1栈中所有元素压入s2中，然后将value压入s1，最后将s2的元素压入s1；删除时，直接删除s1栈中的栈顶元素</p><p><img src="https://pic.rmb.bdstatic.com/bjh/34c0b15323f61b4cb83109f6904441b2.png" alt="双栈实现队列"></p><h3 id="3-实现队列的方式"><a href="#3-实现队列的方式" class="headerlink" title="3.实现队列的方式"></a>3.实现队列的方式</h3><ul><li>循环数组，注意双指针的取余操作</li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/f890b44bf420a258f2282957f0b7e895.png" alt="循环数组实现队列"></p><p>增加元素：（rear+1）%size  删除元素（front+1）%size</p><ul><li>集合</li><li>双栈</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>3.二维数组查找</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer03/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer03/</id>
    <published>2020-05-13T07:59:39.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路：线性查找，从矩阵右上角或者左下角开始查找，因为右下角的数始终大于左上角的数</p><p><img src="https://pic.rmb.bdstatic.com/bjh/23e5e7abf6349ea6a4461bf879abc7bc.png" alt="二维数组查找"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>2.多数元素</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer02/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer02/</id>
    <published>2020-05-13T07:57:25.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：Hash表</p><p>思路二：排序，求下标为【n/2】的元素</p><p><strong>思路三：Boyer-Moore 投票算法</strong></p><p>如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 <code>0</code>，从结果本身我们可以看出众数比其他数多。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/0f7b43191525c7c4e48918aa6ca56385.png" alt="Boyer-Moore 投票算法"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。&lt;/p&gt;
&lt;p&gt;你
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>1.只出现一次的数字</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer01/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer01/</id>
    <published>2020-05-13T07:51:08.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：Hash表存储数字出现次数"><a href="#思路一：Hash表存储数字出现次数" class="headerlink" title="思路一：Hash表存储数字出现次数"></a>思路一：Hash表存储数字出现次数</h5><p><strong>如何遍历Hash表？</strong></p><ol><li><p>迭代器：</p><p>Iterator iter = map.keySet().iterator();</p><p>while (iter.hasNext())</p><p><strong>Or</strong></p></li></ol><p>   Iterator iter = map.entrySet().iterator();</p><p>   while (iter.hasNext()) 【<strong>效率高</strong>】</p><ol start="2"><li><p>for each：<br>**for (String key : map.keySet())<br>OR<br>for (Entry entry : map.entrySet())</p><p>**</p></li></ol><h5 id="思路二：数学法，针对重复数字只出现两次；"><a href="#思路二：数学法，针对重复数字只出现两次；" class="headerlink" title="思路二：数学法，针对重复数字只出现两次；"></a>思路二：数学法，针对重复数字只出现两次；</h5><p><strong>2∗(a+b+c)−(a+a+b+b+c)=c</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return 2 * sum(set(nums)) - sum(nums)</span><br></pre></td></tr></table></figure><p><strong>思路三：位运算，异或操作</strong></p><p>如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位<br><strong>a⊕0=a</strong><br>如果我们对相同的二进制位做 XOR 运算，返回的结果是 0<br><strong>a⊕a=0</strong><br>XOR 满足交换律和结合律<br> <strong>a⊕b⊕a=(a⊕a)⊕b=0⊕b=b</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">    result = result ^ num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>编程技巧篇</title>
    <link href="http://www.kongkongbai.com/Algorithm/Summary/algorithmSkill01/"/>
    <id>http://www.kongkongbai.com/Algorithm/Summary/algorithmSkill01/</id>
    <published>2020-05-13T07:46:21.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数学归纳法"><a href="#1-数学归纳法" class="headerlink" title="1.数学归纳法"></a>1.数学归纳法</h2><p>数学归纳法时编码的依据</p><h4 id="用于证明断言对所有自然数成立"><a href="#用于证明断言对所有自然数成立" class="headerlink" title="用于证明断言对所有自然数成立"></a>用于证明断言对所有自然数成立</h4><ul><li>证明对于N=1成立</li><li>证明N&gt;1时：如果对于N-1成立，那么对于N成立</li></ul><h4 id="实例：证明1-2-3…-n-n-n-1-2成立"><a href="#实例：证明1-2-3…-n-n-n-1-2成立" class="headerlink" title="实例：证明1+2+3…+n = n(n+1)/2成立"></a>实例：证明1+2+3…+n = n(n+1)/2成立</h4><ul><li>当n=1时，1 = 1*2/2 成立</li><li>当n = n-1时，如果1+2+3+…+(n-1)=(n-1)n/2成立</li><li>那么1+2+3+…+n = 1+2+3+…+(n-1) + n</li><li>则1+2+3+…+n = (n-1)n/2 + n = n(n+1)/2成立</li><li>所以等式成立</li></ul><h4 id="类比编码：设计int-sum（int-n）：返回1-2-…-n的值"><a href="#类比编码：设计int-sum（int-n）：返回1-2-…-n的值" class="headerlink" title="类比编码：设计int sum（int n）：返回1+2+…+n的值"></a>类比编码：设计int sum（int n）：返回1+2+…+n的值</h4><ul><li>当n = 1时，if(n == 1) return 1;</li><li>当n = n-1时，else return sum(n-1) +n;</li></ul><h2 id="2-递归控制"><a href="#2-递归控制" class="headerlink" title="2.递归控制"></a>2.递归控制</h2><h4 id="如何证明递归函数正确执行？数学归纳法的数学语言–-gt-程序语言"><a href="#如何证明递归函数正确执行？数学归纳法的数学语言–-gt-程序语言" class="headerlink" title="如何证明递归函数正确执行？数学归纳法的数学语言–&gt;程序语言"></a>如何证明递归函数正确执行？数学归纳法的数学语言–&gt;程序语言</h4><h3 id="2-1递归书写方法"><a href="#2-1递归书写方法" class="headerlink" title="2.1递归书写方法"></a>2.1递归书写方法</h3><ul><li><strong>严格定义递归函数的作用</strong>，包括参数，返回值，Side-effect（附加影响，比如它改变的全局变量）</li><li><strong>先一般，后特殊</strong></li><li>每次调用必须<strong>缩小问题规模</strong></li><li>每次问题规模<strong>缩小程度必须为1</strong></li></ul><h3 id="2-2实战例题"><a href="#2-2实战例题" class="headerlink" title="2.2实战例题"></a>2.2实战例题</h3><h5 id="例1-链表创建-使用递归"><a href="#例1-链表创建-使用递归" class="headerlink" title="例1.链表创建(使用递归)"></a>例1.链表创建(使用递归)</h5><p>输入一个数组，将数组中的每个数据放在结点中，组成一个链表，并返回头指针</p><p>Node CreateLinkedList(List<Integer> values)</p><p>总体思路：将问题的规模减小1，从<strong>创建长度为n的链表，到创建长度为n-1的链表</strong>，然后将头结点与长度为n-1的链表组合起来。</p><p>创建结点类 ：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/55eab06880ed96dc42d0b9e250ae91a7.png" alt="createLinkedList01"></p><p>函数算法：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/e62f4bc39edc3cd4be1fff864771164f.png" alt="createLinkedList02"></p><h5 id="例2：链表反转"><a href="#例2：链表反转" class="headerlink" title="例2：链表反转"></a>例2：链表反转</h5><p>总体思路：将问题规模减少1，即<strong>从将长度为n的链表进行反转，转换为将长度为n-1的链表进行反转</strong>，再将第一个结点放置链表的尾部</p><p><img src="https://pic.rmb.bdstatic.com/bjh/b9c0007af0de086a2d2db16f3cabe501.png" alt="reverseLinkedList01"></p><p>实现过程：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/dfcdcb61d650abe73a13bec789959dc7.png" alt="reverseLinkedList02"></p><h5 id="例三：列出所有的组合（较难理解）"><a href="#例三：列出所有的组合（较难理解）" class="headerlink" title="例三：列出所有的组合（较难理解）"></a>例三：列出所有的组合（较难理解）</h5><ul><li>input：【1，2，3，4】，2</li><li>output：【1，2】、【1，3】、【1，4】、【2，3】、【2，4】、【3，4】列出所有两个数字组成的组合</li></ul><p>总体思路：将问题规模减少为选择第一个元素：combainations（data[m-1] , n-1 ) 和 不选择第一个元素：combainations (data[m-1],n)。每次只选择第一个元素，当n为0时，表示全部元素已选完，输出存放的元素。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/d5448b1a780b3f703fa8ee99450b83e4.png" alt="combinations01"></p><h3 id="2-3递归的缺点"><a href="#2-3递归的缺点" class="headerlink" title="2.3递归的缺点"></a>2.3递归的缺点</h3><h5 id="Stack："><a href="#Stack：" class="headerlink" title="Stack："></a>Stack：</h5><ul><li>函数调用<strong>开销大</strong></li><li>Stack Overflow：递归过大时可能出现<strong>栈溢出</strong></li><li>问题规模大时，<strong>消耗资源过大</strong></li></ul><h2 id="3-循环控制"><a href="#3-循环控制" class="headerlink" title="3.循环控制"></a>3.循环控制</h2><h3 id="3-1写循环的基本思路"><a href="#3-1写循环的基本思路" class="headerlink" title="3.1写循环的基本思路"></a>3.1写循环的基本思路</h3><h5 id="数学归纳法运用于循环中"><a href="#数学归纳法运用于循环中" class="headerlink" title="数学归纳法运用于循环中"></a>数学归纳法运用于循环中</h5><h5 id="循环不变式（loop-invariant）、"><a href="#循环不变式（loop-invariant）、" class="headerlink" title="循环不变式（loop invariant）、"></a>循环不变式（loop invariant）、</h5><ul><li>是一句断言定义各变量所满足的条件</li></ul><p>var a,b;</p><p>while(){</p><p>}</p><p>a,b必须满足 <strong>进入循环之前满足条件，退出循环之后也要满足条件</strong></p><h5 id="循环书写方法："><a href="#循环书写方法：" class="headerlink" title="循环书写方法："></a>循环书写方法：</h5><ul><li>定义循环不变式，并在循环体每次结束后<strong>保持</strong>循环不变式</li><li>先<strong>一般</strong>，后<strong>特殊</strong></li><li>每次必须<strong>向前推进</strong>循环不变式中涉及的变量值</li><li>每次推进规模必须为1</li></ul><h3 id="3-2实战例题"><a href="#3-2实战例题" class="headerlink" title="3.2实战例题"></a>3.2实战例题</h3><h5 id="例一：链表反转"><a href="#例一：链表反转" class="headerlink" title="例一：链表反转"></a>例一：链表反转</h5><p>总体思路：定义循环不变式，定义两个变量：<strong>newHead指向已经成功反转链表的头指针，currentHead还未反转链表的头指针</strong>；通过不断推进两个变量（缩小规模），来完成所有结点反转</p><p><img src="https://pic.rmb.bdstatic.com/bjh/c63b2bed9df072a4f7f1fab9f753c5d4.png" alt="LinkedListReverser-loop01"></p><h5 id="例二：链表中delete-if"><a href="#例二：链表中delete-if" class="headerlink" title="例二：链表中delete_if"></a>例二：链表中delete_if</h5><p>总体思路：定义循环不变式，定义一个变量：prevHead指向已经成功处理完成链表的尾结点；通过不断推进该变量直至其getNext()==null时，所有链表处理完毕。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/1b4461c6363f84490cd5a24f9fc4736b.png" alt="deleteIfEquals-loop"></p><h2 id="3-3边界控制"><a href="#3-3边界控制" class="headerlink" title="3.3边界控制"></a>3.3边界控制</h2><h5 id="例一：二分查找"><a href="#例一：二分查找" class="headerlink" title="例一：二分查找"></a>例一：二分查找</h5><ul><li>在有序数组中查找元素K，返回K所在下标</li><li>binarySearch（【1，2，10，15，100】，15） == 3</li></ul><p>二分查找思路：</p><ul><li>规定查找的值可能在数组arr内下标区间a，b</li><li>计算区间a，b的中间点m</li><li>若k&lt;arr【m】，将区间缩小为a，m，继续二分查找</li><li>若k&gt;arr【m】，将区间缩小为m，b，继续二分查找</li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/7ea352c1c9eb805c61f435c2ce4c94b4.png" alt="binaruSearch01"></p><ul><li>b的边界控制可以为arr.length，也可以为arr.length-1(这里选择length)</li><li>考虑三种边界情况<br>//a == b : m = a –&gt;空集的时候<br>//b == a+1 : m = a –&gt;一个元素的时候<br>//b == a+2 : m = a+1 –&gt;多个元素的时候</li><li>int m = (a + b) / 2 可能会引起整数溢出</li></ul><h2 id="4-树"><a href="#4-树" class="headerlink" title="4.树"></a>4.树</h2><h3 id="4-1二叉树的遍历"><a href="#4-1二叉树的遍历" class="headerlink" title="4.1二叉树的遍历"></a>4.1二叉树的遍历</h3><ul><li>前序遍历：先遍历<strong>树根</strong>，然后前序遍历<strong>左子树</strong>，再前序遍历<strong>右子树</strong></li><li>中序遍历：先中序遍历<strong>左子树</strong>，然后中序遍历<strong>树根</strong>，再中序遍历<strong>右子树 【中序遍历的结果是顺序结果】</strong></li><li>后序遍历：先后序遍历<strong>左子树</strong>，然后后序遍历<strong>右子树</strong>，再后序遍历<strong>树根</strong></li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/782c366bb0f1702a81d19485d208332e.png" alt="树的遍历"></p><p>代码实现：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/57ccc49d5236d95048aa4f75cd81e9cc.png" alt="树的遍历02"></p><h3 id="4-2根据前序中序构造二叉树"><a href="#4-2根据前序中序构造二叉树" class="headerlink" title="4.2根据前序中序构造二叉树"></a>4.2根据前序中序构造二叉树</h3><p>总体思路：</p><ul><li>通过前序第一个结点–&gt;确定根节点</li><li>确认前序中左子树序号和中序中左子树序号，重新递归找左子树的根节点</li><li>右子树同上</li></ul><p>代码实现：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/f3c5b6cde772d1bb689a69c258b3d3a2.png" alt="通过前中序寻找后序"></p><p>细节：<strong>subString(startindex,endindex) –&gt;截取字符串 [startIndex，endIndex)</strong></p><h3 id="4-3寻找中序遍历的下一个结点"><a href="#4-3寻找中序遍历的下一个结点" class="headerlink" title="4.3寻找中序遍历的下一个结点"></a>4.3寻找中序遍历的下一个结点</h3><p>前提条件：这棵二叉树是双向的，子树存储了根的指针</p><p>总体实现：</p><ul><li>考虑N下一个结点为：左子树、根节点、右子树这三种情况</li><li>N的下一个结点不可能为左子树，因为中序遍历为：左根右</li><li>若N的右子树存在，返回右子树的<strong>第一个结点（中序遍历的第一个结点）</strong>；否则考虑根节点</li><li>若N的根节点存在，若N为根节点的左子树，则返回该根节点，否则一直往根节点走，指导是某个结点的左子树为止</li></ul><p>代码实现：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/86432d98799804379f0c1a0566dc4ba8.png" alt="中序遍历的下一个结点"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-数学归纳法&quot;&gt;&lt;a href=&quot;#1-数学归纳法&quot; class=&quot;headerlink&quot; title=&quot;1.数学归纳法&quot;&gt;&lt;/a&gt;1.数学归纳法&lt;/h2&gt;&lt;p&gt;数学归纳法时编码的依据&lt;/p&gt;
&lt;h4 id=&quot;用于证明断言对所有自然数成立&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Summary" scheme="http://www.kongkongbai.com/categories/Algorithm/Summary/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>面试高频算法题</title>
    <link href="http://www.kongkongbai.com/Algorithm/Summary/interviewAlgorithm/"/>
    <id>http://www.kongkongbai.com/Algorithm/Summary/interviewAlgorithm/</id>
    <published>2020-05-13T07:38:20.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><ul><li>用数组【start，end】中间的数与target比较，通过比较结果，二分的缩小下一次的比较范围</li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/793c33b9fdaf19d4c4f9fe022c520371.png" alt="二分查找"></p><h3 id="2-数组：将数组中0放后面，其他顺序不变"><a href="#2-数组：将数组中0放后面，其他顺序不变" class="headerlink" title="2.数组：将数组中0放后面，其他顺序不变"></a>2.数组：将数组中0放后面，其他顺序不变</h3><ul><li>思路：<a href="https://blog.csdn.net/weixin_42600072/article/details/88391582" target="_blank" rel="noopener">双指针策略</a>，定义一个指针指向新数组的有效信息末尾，遍历数组，将有效信息（除0外）按序排列到数组前面，最后再数组后面补0</li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/2c869117b58e42f61bd4c564ba0a6ce5.png" alt="MoveZeros"></p><h3 id="3-数组：有序数组去重"><a href="#3-数组：有序数组去重" class="headerlink" title="3.数组：有序数组去重"></a>3.数组：有序数组去重</h3><ul><li><strong>双指针策略，定义一个慢指针slow，一个快指针fast</strong></li><li>如果num[slow] ==num[fast] ，将快指针向后移</li><li>如果num[slow] != num[fast], 将慢指针向后移，并且赋值num[slow] = num[fast]</li><li>直到快指针走到数组末尾，此时的慢指针即指向去重后的有序数组末尾</li><li><a href="https://www.cnblogs.com/zhanghongfeng/p/11771758.html" target="_blank" rel="noopener">参考</a></li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/3ba51664daaf41d107b1fb3d7d086345.png" alt="removeDuplicates"></p><h3 id="4-对仅有0，1，2的数组排序"><a href="#4-对仅有0，1，2的数组排序" class="headerlink" title="4.对仅有0，1，2的数组排序"></a>4.对仅有0，1，2的数组排序</h3><ul><li>双指针策略，定义一个指针zero，从前指向最后一个0元素的序号，定义一个指针two，从后指向最后一个2元素的序号</li><li>遍历数组，如果是1，则返回跳过往后判断，如果是0，则与num【zero+1】交换位置并zero++，如果是2，则与num【two-1】交换位置并two–</li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/b9ef8ab0bc1d8ee84f01f82ec213b010.png" alt="对0、1、2排序"></p><h3 id="5-数组中第K大元素——堆排序（未完成）"><a href="#5-数组中第K大元素——堆排序（未完成）" class="headerlink" title="5.数组中第K大元素——堆排序（未完成）"></a>5.数组中第K大元素——堆排序（未完成）</h3><ol><li>思路一：维护K最小堆，剩下元素与顶堆比较，若大于则删除顶堆元素后插入，最后剩下的顶堆元素就是要找的元素</li><li>思路二：快速排序方法</li><li><a href="https://blog.csdn.net/qq_34538534/article/details/93377862" target="_blank" rel="noopener">参考博客</a></li></ol><h3 id="6-有序数组两个数和等于target"><a href="#6-有序数组两个数和等于target" class="headerlink" title="6.有序数组两个数和等于target"></a>6.有序数组两个数和等于target</h3><ul><li>思路一：用Hash表来做（<a href="http://39.107.124.120/2020/03/18/两数相加/" target="_blank" rel="noopener">参考</a>）</li><li>思路二：双指针，以前一后，夹逼</li></ul><h3 id="7-第一个缺失的正整数"><a href="#7-第一个缺失的正整数" class="headerlink" title="7.第一个缺失的正整数"></a>7.第一个缺失的正整数</h3><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数</p><p><strong>思路：</strong></p><ul><li>遍历第一遍，将正整数放到正确的索引中</li><li>遍历第二遍，将第一个缺失的正整数找出来</li></ul><p><strong>代码：</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/e1bd9f15cf363440aafd12b2e20bee52.png" alt="第一个缺失的正整数"></p><h3 id="8-三数之和为0"><a href="#8-三数之和为0" class="headerlink" title="8.三数之和为0"></a>8.三数之和为0</h3><p><strong>思路：</strong></p><p>固定一个数，将问题转化为在数组中找两数之和等于target，使用HashMap</p><p><strong>代码(未解决重复元素的情况)：</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/62141c76ba407151ee4b8cf9d9c2e363.png" alt="三数之和为0"></p><p><strong>代码（解决去重和重复元素</strong>）：</p><ul><li>重复元素：由exist判断进行自动规避</li><li>去重：对结果元素进行排序<strong>list.sort(Comparator.naturalOrder())</strong></li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/309aa4f700c89f48f73c2179a488de23.png" alt="三数之和（去重+处理重复元素）"></p><h3 id="9-循环有序数组二分查找"><a href="#9-循环有序数组二分查找" class="headerlink" title="9.循环有序数组二分查找"></a>9.循环有序数组二分查找</h3><p><strong>思路：</strong></p><p>相比于传统的二分查找，再判断target在mid左边还是右边时，加一个判断target和mid是否同时大于（当mid&gt;target时）或者小于（当mid&lt;target时）left</p><p><strong>代码：</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/d6a018a68878916d3f6ae56982ceca2c.png" alt="循环有序数组的二分查找"></p><h3 id="10-根据字符出现次数排序"><a href="#10-根据字符出现次数排序" class="headerlink" title="10.根据字符出现次数排序"></a><strong>10.根据字符</strong>出现次数排序</h3><p><strong>思路：</strong></p><ul><li>使用HashMap将字符串中各个字符的出现次数</li><li><strong>使用Collections.sort进行HashMap的排序，结果存在List&gt;中（较难）</strong></li><li>使用StringBuilder sb = new StringBuilder()进行字符串的拼接</li></ul><p><strong>代码：</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/c4ec845faf6193d59e0dba07e21d8cf2.png" alt="根据字符出现次数排序"></p><h3 id="11-子数组之和等于所给数的个数"><a href="#11-子数组之和等于所给数的个数" class="headerlink" title="11.子数组之和等于所给数的个数"></a>11.子数组之和等于所给数的个数</h3><p>数组为已排序数组，求有多少个这样的数组</p><p><strong>思路一：双指针思想，定义一个数组的起始指针start和end指针，如果数组总和大于target，start前移；如果小于，end后移；如果相等，则正确组数加1后，start和end均后移</strong></p><p><strong>思路二：创建数组sum[]，其中sum[n]表示数组前n个数之和，再二次遍历sum，计算sum[m]-sum[n]：表示n到m数字的和，与k进行比较（复杂，不推荐）</strong></p><p>变体：给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p><p><strong>思路一：思路一不行，可以延续思路二</strong></p><p><strong>思路二：使用HashMap+前缀+取模，存放sum%k的值，如果map中已经存在了sum%k这个value，判断数组中元素是否大于1，大于则存在</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/e1c40b7bdf8bd78865f9007ec7536144.png" alt="连续子数组之和"></p><h3 id="12-最大子序列之和"><a href="#12-最大子序列之和" class="headerlink" title="12.最大子序列之和"></a><strong>12.最大子序列之和</strong></h3><p><strong>思路：计算前n个数的和，若为负数则抛弃，若为正数，则与max进行比较，max为前面最大子序列之和</strong></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="13-根据x值划分链表"><a href="#13-根据x值划分链表" class="headerlink" title="13.根据x值划分链表"></a>13.根据x值划分链表</h3><p>-给定一个链表和一个值x,将链表划分成两 部分,使得划分后小于x的结点在前,大于 等于x的结点在后。在这两部分中要保持原 链表中的出现顺序。</p><p><strong>思路一：遍历的时候新建立两个链表，最后合并，需要建立4个新指针（左右各两个指向头尾），另外需要判断头结点为空的情况</strong>（<a href="https://www.jianshu.com/p/d37786e9d83e" target="_blank" rel="noopener">参考博客</a>）</p><p><strong>思路一改进：在思路一的基础上设计空头节点，保留头部信息，最后不需要进行非空判断。</strong></p><h3 id="14-调整单链表使得奇数位置的元素位于偶数位置元素之前"><a href="#14-调整单链表使得奇数位置的元素位于偶数位置元素之前" class="headerlink" title="14.调整单链表使得奇数位置的元素位于偶数位置元素之前"></a>14.调整单链表使得奇数位置的元素位于偶数位置元素之前</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个单链表，使得奇数位置的元素位于偶数位置元素之前。比如说：1-&gt;2-&gt;4-&gt;5-&gt;6-&gt;NULL，调整以后1-&gt;4-&gt;6-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>思路一：分为odd和even两个链表，设置三个指针(也可以理解为四个，因为odd链表头为本来链表的头结点)，指针odd指向奇数位置的元素，指针even指向偶数位置的元素，指针evenHead指向第一个偶数位置的元素按照奇数位置和偶数位置把链表划分为两部分，然后，奇数链表尾指针指向偶数位置首指针。时间复杂度也是o(n)。（<a href="https://blog.csdn.net/yang20141109/article/details/51287226?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">参考博客</a>）</strong></p><h3 id="15-删除有序链表中所有重复结点（简单）"><a href="#15-删除有序链表中所有重复结点（简单）" class="headerlink" title="15.删除有序链表中所有重复结点（简单）"></a>15.删除有序链表中所有重复结点（简单）</h3><p><strong>思路一：创建一个last指针，判断last.val与last.next.val是否相等，如果相等则删除last.next指针</strong></p><h3 id="16-根据指针删除结点"><a href="#16-根据指针删除结点" class="headerlink" title="16.根据指针删除结点"></a>16.根据指针删除结点</h3><p><strong>思路一：正常思路是我们要删除一个结点，需要让这个结点的前一个节点指向这个结点的下一个结点。</strong></p><p><strong>思路二：我们将这个结点的下一个结点的val赋值给当前结点，然后跳过下一个结点即可。即保存下一个结点的信息，然后跳过下一个结点</strong></p><h3 id="17-删除倒数第n个结点"><a href="#17-删除倒数第n个结点" class="headerlink" title="17.删除倒数第n个结点"></a>17.删除倒数第n个结点</h3><p><strong>思路一：遍历一遍确定位置，然后在删除指定位置的结点（可以考虑hashmap）</strong></p><p><strong>思路二：双指针思路，两个指针start和end同时指向head，然后end向后移动n位，之后start和end同时向后移动，直到end指向null</strong></p><h3 id="18-判断链表是否为回文"><a href="#18-判断链表是否为回文" class="headerlink" title="18.判断链表是否为回文"></a>18.判断链表是否为回文</h3><p><strong>思路一：用数组存储链表的数据，然后通过数组进行判断（不满足空间复杂度）</strong></p><p><strong>思路二：全部反转链表后，与原链表进行比较</strong></p><p><strong>思路三：通过快慢指针找到中间结点，然后翻转后面一半的链表后，从head和中间结点以后比较</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/05b6fa761d3e74a90fc09327fb39fd63.png" alt="快慢指针找中间结点"></p><h3 id="19-找到两条单向链表的交点"><a href="#19-找到两条单向链表的交点" class="headerlink" title="19.找到两条单向链表的交点"></a>19.找到两条单向链表的交点</h3><p><strong>思路一：Hash法，将第一个链表结点地址存入hash表中，然后遍历第二条链表查看是否有相同的结点</strong></p><p><strong>思路二：回环法，遍历第一个链表到链尾，然后将其指向第二个链表头部，如果形成了回环则表示两个链表相交</strong></p><p><strong>思路三：尾结点判断法，遍历两个链表到尾部，如果相等则代表相交</strong></p><h3 id="20-找到环形链表的交点"><a href="#20-找到环形链表的交点" class="headerlink" title="20.找到环形链表的交点"></a>20.找到环形链表的交点</h3><p><a href="https://blog.csdn.net/jiary5201314/article/details/50990349" target="_blank" rel="noopener">参考博客</a></p><p><strong>思路：这是一种特殊情况，首先清楚一个单向链表和一个有环链表是不可能相交的，所以如果有环链表相交，必定公用同一个环，所以我们将第一个链表的换解开后，判断第二个链表是否回环即可判断是否相交</strong></p><p><strong>判断是否有环：快慢指针、hash表存放</strong></p><p><strong>判断环点：hash表存放</strong></p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="21-给定n，求最少需要几个完全平方数组成"><a href="#21-给定n，求最少需要几个完全平方数组成" class="headerlink" title="21.给定n，求最少需要几个完全平方数组成"></a>21.给定n，求最少需要几个完全平方数组成</h3><p><strong>思路一：（推荐）动态规划，一个数最少等于前面所有可能数最少加上一个完全平方数。创建一个一维数组来存储中间（<a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">动态规划算法博客</a>）</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/09367e1840a2fd0bea2cbd6da7dbc62e.png" alt="动态规划找完全平方"></p><p><strong>思路二：贪心枚举，维护一个完全平方数表（HashSet），我们定义一个is_divided（int n,int count）函数来确定n是否可以被分解count次后满足条件，我们只需要返回true or false 而不需要知道确切是那些组合。之后我们从count=1开始枚举，直到找到最小的count</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/other/97a1554e71a47ee316d902a7c3452263.png" alt="贪心枚举找完全平方"></p><h3 id="22-给定数组，求前k个频率最高的数"><a href="#22-给定数组，求前k个频率最高的数" class="headerlink" title="22.给定数组，求前k个频率最高的数"></a>22.给定数组，求前k个频率最高的数</h3><p><strong>思路一：使用HashMap存放数字以及其频率，然后根据Value进行排序，使用java的Collections.sort()对Map.Entry进行排序**</strong>，具体实现参考第10题**</p><p><strong>思路二：（<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/" target="_blank" rel="noopener">参考</a>）改进，在排序上可以对HashMap进行堆排序，维护k个最小优先队列</strong></p><p><a href="https://www.cnblogs.com/gnivor/p/4841191.html" target="_blank" rel="noopener">优先队列的使用</a></p><p><img src="https://pic.rmb.bdstatic.com/bjh/2c2e37693d70e4b943e375e59f5a9b1c.png" alt="求前K个频率最高的数_优先队列"></p><h3 id="23-合并K个已排序链表"><a href="#23-合并K个已排序链表" class="headerlink" title="23.合并K个已排序链表"></a>23.合并K个已排序链表</h3><p><strong>思路一：优先队列，对每次的首节点进行排序，维护一个优先队列，注意每次指针的向后移动，确保堆中维护的是当前位置的首节点</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/320304c0a26f1147c0ceb6b7acbe6f4c.png" alt="合并k个已排序链表_优先队列"></p><h3 id="24-O-1-时间实现栈内max"><a href="#24-O-1-时间实现栈内max" class="headerlink" title="24.O(1)时间实现栈内max"></a>24.O(1)时间实现栈内max</h3><p><strong>思路一：创建一个maxStack辅助栈，每次入栈时判断x与顶部元素大小，若x大于栈顶，则进入辅助栈，否则将栈顶元素再次加入maxStack中；出栈时同时出。</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/09e20c0ac904c72a3396fd62c57abe82.png" alt="max栈的创建"></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="25-二叉树的最大-最小深度"><a href="#25-二叉树的最大-最小深度" class="headerlink" title="25.二叉树的最大/最小深度"></a>25.二叉树的最大/最小深度</h3><ul><li>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</li></ul><p><strong>思路一：递归</strong></p><p>最小深度：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/d7a9fb81459a9b722058afea438979fd.png" alt="二叉树最小深度"></p><p>最大深度不用考虑根节点的有一个子树为空的情况。</p><h3 id="26-二叉树翻转左右孩子"><a href="#26-二叉树翻转左右孩子" class="headerlink" title="26.二叉树翻转左右孩子"></a>26.二叉树翻转左右孩子</h3><p><strong>思路一：递归，先翻转左右两个子树，然后让子树进行翻转</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/6a27dcd4b6f864c711a6b4f521cb1c3c.png" alt="左右翻转二叉树"></p><h3 id="27-求完全二叉树的节点个数"><a href="#27-求完全二叉树的节点个数" class="headerlink" title="27.求完全二叉树的节点个数"></a>27.求完全二叉树的节点个数</h3><p><strong>思路一：递归，用求二叉树的方式求完全二叉树的节点数，没有用到二叉树的特性</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/4eea51be13e7f06ca2b45485cec42729.png" alt="二叉树的节点数"></p><p><strong>思路二：完全二叉树的节点数=底部+除底部以外的完全满二叉树</strong>，计算底部时：使用helper()函数计算最后一层节点的数量，传入的depth是下面最多还有的深度，所以depth == 0也就是深度遍历终止的地方，此处有节点返回1，无节点返回0。<br>关键的剪枝操作：当左子树的最后一层的节点没有充满时，直接返回左子树中的最后一层的节点数（右子树最后一层一定没有节点）。（<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/ji-bai-100zhong-de-fang-fa-zhong-zui-hao-li-jie-de/" target="_blank" rel="noopener">参考</a>）</p><h3 id="28-根节点到叶子结点和为sum的路径"><a href="#28-根节点到叶子结点和为sum的路径" class="headerlink" title="28.根节点到叶子结点和为sum的路径"></a>28.根节点到叶子结点和为sum的路径</h3><p><strong>思路一：递归，如果当前节点和不为sum，通过sum=sum-root.val向下遍历子节点。回溯，定义一个LinkedList的path存放路径。</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/ac711b0d9c10b30a9de9ed850971e62c.png" alt="路径和为sum的路径"></p><h3 id="29-路径和为sum的总条数"><a href="#29-路径和为sum的总条数" class="headerlink" title="29.路径和为sum的总条数"></a>29.路径和为sum的总条数</h3><p><strong>思路一：可以去掉对叶子节点的判断</strong></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="30-判断BST"><a href="#30-判断BST" class="headerlink" title="30.判断BST"></a>30.判断BST</h3><p>思路一：如果只是判断左子树&lt;根&lt;右子树是不够的，还需要判断左边子树所有的节点小于根，以及右边的所有节点大于根，<strong>所以需要有一个上届和下届</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/other/8e3f72d0ce1890e72879982bdf5cb1c2.png" alt="判断BST"></p><p><strong>思路二：中序遍历</strong></p><h3 id="31-有序数组转二叉平衡搜索树"><a href="#31-有序数组转二叉平衡搜索树" class="headerlink" title="31.有序数组转二叉平衡搜索树"></a>31.有序数组转二叉平衡搜索树</h3><p>思路一：二分法</p><p><img src="https://pic.rmb.bdstatic.com/bjh/92c1aa0bc855fbf91911a93a1bf5a5a0.png" alt="有序数组转二叉平衡树"></p><h3 id="32-普通二叉树中两个节点的最小公共祖先"><a href="#32-普通二叉树中两个节点的最小公共祖先" class="headerlink" title="32.普通二叉树中两个节点的最小公共祖先"></a>32.普通二叉树中两个节点的最小公共祖先</h3><p>思路一：递归，定义mid判断根节点是否有目标结点，left判断左子树是否有目标结点，right判断右子树是否有目标结点。如果<strong>mid+left+right=2则表示当前节点就是公共最小祖先</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/1d11f23b84305fd7cd0b8a800e7247cb.png" alt="公共最小祖先结点"></p><h3 id="33-求树的左叶子节点之和"><a href="#33-求树的左叶子节点之和" class="headerlink" title="33.求树的左叶子节点之和"></a>33.求树的左叶子节点之和</h3><p>思路：递归遍历，无论是前序、中序、还是后序，关键是如何判断一个结点是左叶子结点</p><p><img src="https://pic.rmb.bdstatic.com/bjh/624a75d5ef4e86748db3f5a87b9c25c8.png" alt="左子树之和"></p><h3 id="34-非递归遍历"><a href="#34-非递归遍历" class="headerlink" title="34.非递归遍历"></a>34.非递归遍历</h3><p><strong>前序遍历：</strong></p><p>1.先将根节点入栈<br>2.访问根节点<br>3.如果根节点存在右孩子，则将右孩子入栈<br>4.如果根节点存在左孩子，则将左孩子入栈（<strong>注意：一定是右孩子先入栈，然后左孩子入栈</strong>）<br>5.重复2-4</p><p><img src="https://pic.rmb.bdstatic.com/bjh/f1f0607c09c8dee2066575aa5bd41f43.png" alt="二叉树非递归前序遍历"></p><p><strong>中序遍历：</strong></p><p>1.先将根节点入栈<br>2.将当前节点的所有左孩子入栈，直到左孩子为空<br>3.访问栈顶元素，如果栈顶元素存在右孩子，则继续第2步<br>4.重复第2、3步，直到栈为空并且所有的节点都被访问</p><p><img src="https://pic.rmb.bdstatic.com/bjh/fbd0e8f47e2c1ad73085390b635ea0ce.png" alt="二叉树非递归中序遍历"></p><p><strong>后序遍历：</strong></p><ol><li>根节点入栈，并定一个pre指针指向上一次访问的结点，初始为null</li><li>获取栈顶元素，如果栈顶元素的左右儿子同时为空或者pre指针为栈顶元素的左右儿子之一（即已被访问过的结点），则访问栈顶元素，并设置pre指针为刚刚的栈顶元素</li><li>如果栈顶元素不同时为空，则先判断右子树入栈，只有判断左子树入栈</li><li>循环直至栈为空</li></ol><p><img src="https://pic.rmb.bdstatic.com/bjh/14c6145bafead415b55caeba15bf1f92.png" alt="非递归后序遍历"></p><h3 id="35-之字形遍历二叉树"><a href="#35-之字形遍历二叉树" class="headerlink" title="35.之字形遍历二叉树"></a>35.之字形遍历二叉树</h3><p><strong>思路一：广度优先，两个双端队列（可以直接用LinkedList来实现），定义一个变量判断，该层是从左到右还是从右到左遍历，在队列中插入null结点来分隔每层的遍历情况。</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/63c23493e755faca7ccc2f27d9f522ed.png" alt="之字形遍历二叉树"></p><h2 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h2><h3 id="36-求组合数"><a href="#36-求组合数" class="headerlink" title="36.求组合数"></a>36.求组合数</h3><p>思路一：递归回溯，通过判断path中元素是否足够来结束递归</p><p><img src="https://pic.rmb.bdstatic.com/bjh/396424e90da19390359ce46e6709314e.png" alt="求组合数"></p><p>思路二：递归，search（n,k）可以分为选择第n个元素即search(n-1,k-1)，和不选择第n个元素即search(n-1,k)两种路径方式，当k=0或者n==k时表示递归走到了终点，结束递归</p><p><img src="https://pic.rmb.bdstatic.com/bjh/e61d4b34c05e0bcb3a4cd10f2e3f7394.png" alt="求组合数2"></p><p>37.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;h3 id=&quot;1-二分查找&quot;&gt;&lt;a href=&quot;#1-二分查找&quot; class=&quot;headerlink&quot; title=&quot;1.二分查找&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Summary" scheme="http://www.kongkongbai.com/categories/Algorithm/Summary/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>排序算法整理</title>
    <link href="http://www.kongkongbai.com/Algorithm/Summary/sortAlgorithm/"/>
    <id>http://www.kongkongbai.com/Algorithm/Summary/sortAlgorithm/</id>
    <published>2020-05-13T07:36:37.000Z</published>
    <updated>2020-06-03T03:15:14.572Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/ll409546297/p/10956960.html" target="_blank" rel="noopener">参考博客</a>（非常详细）</p><p><a href="https://blog.csdn.net/IBLiplus/article/details/81056945" target="_blank" rel="noopener">快速排序参考博客</a></p><p><a href="https://blog.csdn.net/qq_36442947/article/details/81612870" target="_blank" rel="noopener">归并排序参考博客</a></p><p><a href="https://blog.csdn.net/TangXiaoPang/article/details/87896297" target="_blank" rel="noopener">堆排序参考博客</a></p><h3 id="排序算法的比较"><a href="#排序算法的比较" class="headerlink" title="排序算法的比较"></a>排序算法的比较</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/4b7db2324210849024eb9192f4de6fa6.png" alt="排序算法的比较"></p><ul><li>冒泡排序：相邻两个数比较，将最大数移动到最后</li><li>选择排序：用需要排序序列的第一个数与其他数进行比较，找到每次循环的最小数与第一个数交换</li><li>插入排序：默认前面是已排序好的序列，通过比较将下一个数插入到合适位置</li><li>希尔排序：原理和插入排序一致，只是每次间隔步长不一样</li><li>归并排序：将序列分成两个子序列，然后子序列继续分化，直到每个子序列都为1，之后按序合并子序列</li><li>快速排序：选取一个数partion（一般第一个数），定义left和right指针，通过指针移动，直至指针相遇，将数组分为大于partion的序列和小于partion的序列；再对两部分进行递归，直到排序完成。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ll409546297/p/10956960.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考博客&lt;/a&gt;（非常详细）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Summary" scheme="http://www.kongkongbai.com/categories/Algorithm/Summary/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
</feed>
