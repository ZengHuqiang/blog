<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空空白的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kongkongbai.com/"/>
  <updated>2020-05-15T14:07:48.857Z</updated>
  <id>http://www.kongkongbai.com/</id>
  
  <author>
    <name>kongkongbai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL语法模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLGrammar/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLGrammar/</id>
    <published>2020-05-13T08:18:34.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<p><strong>三张表实例：</strong></p><ul><li>course：course_id、course_name</li><li>student：studen_id、student_name</li><li>score：student_id、course_id、score</li></ul><h4 id="1-Group-By"><a href="#1-Group-By" class="headerlink" title="1.Group By"></a>1.Group By</h4><ul><li>满足“Select子句中的列名必须满足为分组列（group by中的列名）或列函数”（只针对需要聚合的一个表）</li><li>列函数对于group by子句定义的每个组各返回一个结果</li></ul><p>例1：查询所有同学的学号、选课数、总成绩</p><p>例2：查询所有同学的学号、姓名、选课数、总成绩</p><p>select s.student_id, stu.name, count(s.course_id), sum(s.score)<br>from score s, student stu<br>group by s.student_id;</p><h4 id="2-Having"><a href="#2-Having" class="headerlink" title="2.Having"></a>2.Having</h4><ul><li>通常与Group by 子句一起使用</li><li>where过滤行，Having过滤组</li><li>出现在同一sql的顺序：Where&gt;Group by &gt;Having</li></ul><p>例1：查询平均成绩大于60分的同学的学号和平均成绩</p><p>select student_id, avg(score)<br>from score<br>group by student_id<br>having avg(score) &gt; 60;</p><p>例2：取出student_id为1学生的学生情况</p><p>select * from score having student_id = 1;</p><p>例3：查询没有学全所有课的同学的学号和姓名</p><p>select student_id, name<br>from score, course,</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;三张表实例：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;course：course_id、course_name&lt;/li&gt;
&lt;li&gt;student：studen_id、student_name&lt;/li&gt;
&lt;li&gt;score：student_id、cours
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLTransaction/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLTransaction/</id>
    <published>2020-05-13T08:18:15.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySql只有InnoDB支持事务系统"><a href="#MySql只有InnoDB支持事务系统" class="headerlink" title="MySql只有InnoDB支持事务系统"></a>MySql只有InnoDB支持事务系统</h3><ul><li><strong>MySQL</strong>默认隔离级别为：<strong>Repeatable Read</strong></li><li><strong>Oracle</strong>默认隔离级别为：<strong>Read Commited</strong></li></ul><h3 id="1-数据库的四大特性——ACID"><a href="#1-数据库的四大特性——ACID" class="headerlink" title="1.数据库的四大特性——ACID"></a>1.数据库的四大特性——ACID</h3><ul><li><strong>Atomicity</strong>（原子性）：一个事务中的操作要么全部执行，要么全部不执行</li><li><strong>Consistency</strong>（一致性）：指事务开始之前和结束之后，数据库的完整性约束没有被破坏</li><li><strong>Isolation</strong>（隔离性）：指多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果</li><li><strong>Durability</strong>（持久性）：事务完成之后对数据库的修改是持久性的，不会被回滚</li></ul><h3 id="2-事务的隔离性"><a href="#2-事务的隔离性" class="headerlink" title="2.事务的隔离性"></a>2.事务的隔离性</h3><p><a href="https://blog.csdn.net/CoderBruis/article/details/102692753" target="_blank" rel="noopener">参考博客</a></p><h4 id="2-1事务的隔离级别"><a href="#2-1事务的隔离级别" class="headerlink" title="2.1事务的隔离级别"></a>2.1事务的隔离级别</h4><ul><li><strong>Read uncommitted</strong>:一个事务可以读取另一个未提交事务的数据<strong>（无法避免脏读）</strong></li><li><strong>Read committed</strong>:一个事务要等另一个事务提交后才能读取数据（<strong>无法避免update和insert操作带来的幻读问题</strong>）</li><li><strong>Repeatable read:</strong>就是在开始读取数据（事务开启）时，不再允许修改操作(<strong>无法避免insert操作带来的幻读问题</strong>)</li><li><strong>Serializable:</strong>事务串行化顺序执行</li></ul><h4 id="2-2事务并发访问可能导致的问题"><a href="#2-2事务并发访问可能导致的问题" class="headerlink" title="2.2事务并发访问可能导致的问题"></a>2.2事务并发访问可能导致的问题</h4><p>[<img src="https://pic.rmb.bdstatic.com/bjh/88cc8399da5f90a0be2a5630f426d15f.jpeg" alt="事务隔离级别"></p><ul><li><strong>脏读</strong>：脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。</li><li><strong>不可重复读</strong>：（同时操作，事务一分别读取事务二操作时和提交后的数据，读取的记录内容不一致）不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。</li><li><strong>幻读</strong>：和可重复读类似，但是事务二的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致</li><li>InnoDB Repeatable read级别下可以避免幻读</li></ul><h4 id="2-3InnoDB-Repeatable-read级别下如何避免幻读"><a href="#2-3InnoDB-Repeatable-read级别下如何避免幻读" class="headerlink" title="2.3InnoDB Repeatable read级别下如何避免幻读"></a>2.3InnoDB <strong>Repeatable read级别下如何避免幻读</strong></h4><p><a href="https://blog.csdn.net/xifeijian/article/details/20313977#t10" target="_blank" rel="noopener">（参考博客）</a></p><ul><li>表象：快照读（非阻塞读）——伪MVCC（多版本的并发控制）</li><li>内在：next-key锁（行锁+gap锁）</li></ul><h5 id="2-3-1当前读和快照读"><a href="#2-3-1当前读和快照读" class="headerlink" title="2.3.1当前读和快照读"></a>2.3.1当前读和快照读</h5><ul><li>当前读：加了锁的增删改查操作(select…lock in share mode;select…for update; update 、delete、insert)</li><li>快照读：不加锁的非阻塞读，select</li></ul><p><strong>区别：</strong></p><ul><li>read committed级别下。当前读与快照读读取的版本一样。</li><li>repeatable read 级别下，当前读返回的是数据的最新版本，<strong>快照读返回的可能数据未修改前的版本也可能是最新的数据版本</strong>。因为在RR级别下，事务调用快照读的时机很重要，创建快照的时机决定了读取的版本。</li></ul><h5 id="2-3-2RC、RR级别下InnoDB的非阻塞读-快照读-如何实现"><a href="#2-3-2RC、RR级别下InnoDB的非阻塞读-快照读-如何实现" class="headerlink" title="2.3.2RC、RR级别下InnoDB的非阻塞读(快照读)如何实现"></a>2.3.2RC、RR级别下InnoDB的非阻塞读(快照读)如何实现</h5><ul><li>数据行里的<strong>DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID</strong>字段</li></ul><p>1.DB_TRX_ID—-该字段标明最近一次对数据做修改（事务ID）<br>2.DB_ROLL_PTR—-回滚指针，写入<strong>回滚段的undo日志</strong><br>3.DB__ROW_ID —-行号 随着新行出现单调递增的id</p><ul><li>undo日志：主要分为<strong>insert undo</strong>日志（事务回滚涉及）和<strong>uodate undo</strong>日志（事务回滚和快照读都涉及）对事务变更就会产生undo记录，存储的是老版数据，事务回滚需要</li><li>read view：可见性判断来决定当前看的是哪个版本数据</li></ul><p><strong>实现的具体过程：</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/0eb3675fe478e80f6681717c2ed10aec.png" alt="快照读的实现"></p><p>比如现在有一个记录Field1、Field2、Field3数据分别为11、12、13，现在事务要修改该记录，将Field2修改为32。则这条记录首先会加载X锁，首先undo log中会拷贝一条修改前的记录，并赋值DB_ROW_ID。此时被X锁锁住的记录的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID分别进行赋值，并且DB_ROLL_PTR的记录会指向undo log中的DB_ROW_ID的值。</p><p><strong>RR的快照读出现旧数据的原因：</strong></p><p>如果在数据更新之前进行了一次快照读，事务会保存数据库的快照在undo log中，如果此时其他事务更新了数据，那么快照读依旧会沿用undo log中的数据，此时数据不再是最新数据。</p><h5 id="2-3-3内在：next-key锁（行锁-Gap锁）"><a href="#2-3-3内在：next-key锁（行锁-Gap锁）" class="headerlink" title="2.3.3内在：next-key锁（行锁+Gap锁）"></a>2.3.3内在：next-key锁（行锁+Gap锁）</h5><h5 id="2-3-3Gap锁"><a href="#2-3-3Gap锁" class="headerlink" title="2.3.3Gap锁"></a>2.3.3Gap锁</h5><p><strong>什么时候会用到Gap锁？</strong></p><ul><li>只有在RR和Serializable级别下</li><li>如果<strong>where条件全部命中</strong>，<strong>则不会用Gap锁</strong>，只会加行锁（因为如果条件全部命中，记录就存在唯一性，新增的记录不会产生幻读现象）</li><li>如果<strong>where条件部分命中或者全不命中，则会加Gap锁</strong></li><li>Gap锁会用在<strong>非唯一索引或者不走索引的当前读</strong>中</li></ul><ol><li>非唯一索引：加锁范围为与相邻非唯一键的区间中，左边&lt;=gap&lt;=右边，还与主键的字母排序有关（<strong>本质是与B+数的排列有关</strong>）</li><li>不走索引：会锁住所有的键</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MySql只有InnoDB支持事务系统&quot;&gt;&lt;a href=&quot;#MySql只有InnoDB支持事务系统&quot; class=&quot;headerlink&quot; title=&quot;MySql只有InnoDB支持事务系统&quot;&gt;&lt;/a&gt;MySql只有InnoDB支持事务系统&lt;/h3&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLLock/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLLock/</id>
    <published>2020-05-13T08:18:00.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-常见问题"><a href="#0-常见问题" class="headerlink" title="0.常见问题"></a>0.常见问题</h4><ul><li>MyISAM与InnoDB关于锁方面的区别是什么？</li><li>数据库事务的四大特性</li><li>事务隔离级别以及各级别下的并发访问问题</li><li>InnoDB可重复度隔离级别下如何避免幻读</li><li>RC、RR级别下的InnoDB的非阻塞读如何实现</li></ul><h3 id="1-MyISAM与InnoDB关于锁方面的区别"><a href="#1-MyISAM与InnoDB关于锁方面的区别" class="headerlink" title="1.MyISAM与InnoDB关于锁方面的区别"></a>1.MyISAM与InnoDB关于锁方面的区别</h3><p><a href="https://blog.csdn.net/xifeijian/article/details/20313977#t10" target="_blank" rel="noopener">（参考博客）！非常详细</a></p><ul><li>MyISAM默认用的表级锁，不支持行级锁</li><li>InnoDB默认用的行级锁，也支持表级锁</li></ul><h4 id="1-1MyISAM：表级锁"><a href="#1-1MyISAM：表级锁" class="headerlink" title="1.1MyISAM：表级锁"></a>1.1MyISAM：表级锁</h4><ul><li>在对数据表进行select操作时，MyISAM会为该表加上一个表的<strong>读锁（共享锁）</strong>，在对数据表进行增删改时，MyISAM会为该表叫上一个<strong>写锁（排它锁）</strong></li><li><strong>两个锁互斥</strong>，必须等另一种锁释放之后，才能加上不同种类的锁</li><li>读锁与读锁之间不互斥，<strong>写锁与写锁之间会发生互斥</strong></li><li>显式的加锁：<strong>lock table</strong> XXX <strong>read</strong>(或者<strong>write</strong>) ；解锁：unlock table</li></ul><h4 id="1-2InnoDB：索引时用行级锁，非索引时用表级锁"><a href="#1-2InnoDB：索引时用行级锁，非索引时用表级锁" class="headerlink" title="1.2InnoDB：索引时用行级锁，非索引时用表级锁"></a>1.2InnoDB：索引时用行级锁，非索引时用表级锁</h4><ul><li>相对于表级锁，<strong>行级锁只对操作的行数进行加锁操作</strong>，其锁的行为与表级锁一致</li><li>显式的对某行加锁：在末尾加<strong>lock in share mode（加读锁）</strong>；<strong>for update（加写锁）</strong></li></ul><h4 id="如何加表锁？"><a href="#如何加表锁？" class="headerlink" title="如何加表锁？"></a><strong>如何加表锁？</strong></h4><ul><li>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</li><li>在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。<strong>这也正是MyISAM表不会出现死锁（Deadlock Free）的原因</strong>。</li></ul><h4 id="如何加行锁？"><a href="#如何加行锁？" class="headerlink" title="如何加行锁？"></a>如何加行锁？</h4><ul><li><p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><p>¡ 共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。</p><p>¡ 排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。</p></li><li><p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的</strong>，这一点MySQL与Oracle不同，后者是<strong>通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p></li></ul><h4 id="1-3MyISAM适合的场景"><a href="#1-3MyISAM适合的场景" class="headerlink" title="1.3MyISAM适合的场景"></a>1.3MyISAM适合的场景</h4><ul><li>频繁执行全表count语句（<strong>MyISAM会保存一个表行数的变量</strong>，InnoDB则需要重新扫描全表）</li><li>对数据进行增删改的频率不高，查询非常频繁（MyISAM增删改会涉及锁表操作，InnoDB只会锁行）</li><li>没有事务</li></ul><h4 id="1-4InnoDB适合的场景"><a href="#1-4InnoDB适合的场景" class="headerlink" title="1.4InnoDB适合的场景"></a>1.4InnoDB适合的场景</h4><ul><li>数据增删改查都相当频繁（InnoDB只锁行，避免很多操作的阻塞）</li><li>可靠性要求比较高，要求支持事务</li></ul><h4 id="1-5数据库锁的分类"><a href="#1-5数据库锁的分类" class="headerlink" title="1.5数据库锁的分类"></a>1.5数据库锁的分类</h4><ul><li>按锁的粒度划分，可分为<strong>表级锁、行级锁、页级锁</strong>（介于两者之间）</li><li>按锁级别划分，可分为<strong>共享锁、排它锁</strong></li><li>按加锁方式划分，可分为<strong>自动锁、显式锁</strong></li><li>按操作划分，可分为<strong>DML锁</strong>（对数据上的锁）、<strong>DDL锁</strong>（对表结构上的锁）</li><li>按使用方式划分，可分为<strong>乐观锁</strong>（通过加版本号或时间戳来实现，更新提交时检查版本号是否对应）<strong>、悲观锁</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;0-常见问题&quot;&gt;&lt;a href=&quot;#0-常见问题&quot; class=&quot;headerlink&quot; title=&quot;0.常见问题&quot;&gt;&lt;/a&gt;0.常见问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;MyISAM与InnoDB关于锁方面的区别是什么？&lt;/li&gt;
&lt;li&gt;数据库事务的四大特性&lt;/l
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引模块</title>
    <link href="http://www.kongkongbai.com/MySQL/MySQLIndex/"/>
    <id>http://www.kongkongbai.com/MySQL/MySQLIndex/</id>
    <published>2020-05-13T08:17:43.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-解决的问题"><a href="#0-解决的问题" class="headerlink" title="0.解决的问题"></a>0.解决的问题</h3><ul><li>为什么要使用索引–&gt;<strong>因为索引可以避免全表扫描,提升查找数据的效率,</strong></li><li>什么样的信息能成为索引–&gt;<strong>主键、唯一键以及普通键等能够让数据存在区分的字段</strong></li><li>索引的数据结构–&gt;<strong>主流:B+树</strong></li><li>密集索引和稀疏索引的区别–&gt;看下面解答</li></ul><h3 id="1-索引实现数据结构之间的比较"><a href="#1-索引实现数据结构之间的比较" class="headerlink" title="1.索引实现数据结构之间的比较"></a>1.索引实现数据结构之间的比较</h3><h4 id="1-1二叉查找树"><a href="#1-1二叉查找树" class="headerlink" title="1.1二叉查找树"></a>1.1二叉查找树</h4><p>查找效率一般情况较高，如果出现线性情况，效率会很低</p><h4 id="1-2B-B-树"><a href="#1-2B-B-树" class="headerlink" title="1.2B/B+树"></a>1.2B/B+树</h4><p><strong>////引用</strong></p><h3 id="3-2索引的实现"><a href="#3-2索引的实现" class="headerlink" title="3.2索引的实现"></a>3.2索引的实现</h3><h3 id="3-2-0相关数据结构的区别"><a href="#3-2-0相关数据结构的区别" class="headerlink" title="3.2.0相关数据结构的区别"></a>3.2.0相关数据结构的区别</h3><ul><li>二叉树与B/B+树的区别：二叉树<strong>优化比较次数</strong>，B/B+树<strong>优化磁盘读写次数</strong></li><li>B树与B+树的区别：B+树的数据都存放在叶子结点中</li><li>B树和二叉搜索树（如红黑树）的区别：B树的每一个结点可以存放多个数据，这样可以优化硬盘的读写速度</li></ul><h3 id="3-2-1-B树"><a href="#3-2-1-B树" class="headerlink" title="3.2.1 B树"></a>3.2.1 B树</h3><h4 id="定义（m阶B树）："><a href="#定义（m阶B树）：" class="headerlink" title="定义（m阶B树）："></a>定义（m阶B树）：</h4><ul><li>每个非叶子节点（除根外）至多有m个子结点，至少有向上取整【m/2】个子结点</li><li>根节点（如果不是叶子）至少有两个子结点</li><li>所有叶子节点在同一层</li><li>每个非根结点都包含k个元素（关键字），这里m/2≤k&lt;m，这里m/2向下取整。</li></ul><h4 id="实例：如何插入-删除一颗B树"><a href="#实例：如何插入-删除一颗B树" class="headerlink" title="实例：如何插入/删除一颗B树"></a>实例：<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">如何插入/删除一颗B树</a></h4><p>插入总体思路：先将元素直接按大小插入对应结点中，如果结点中元素数量&gt;=m-1，则进行分裂（向上分裂）</p><p>删除总体思路：将元素删除后，如果结点中元素数量&lt;m/2(向下取整)，则进行合并操作</p><h3 id="3-2-2-B-树"><a href="#3-2-2-B-树" class="headerlink" title="3.2.2 B+树"></a>3.2.2 B+树</h3><h4 id="定义（m阶B-树，在B树上的优化）："><a href="#定义（m阶B-树，在B树上的优化）：" class="headerlink" title="定义（m阶B+树，在B树上的优化）："></a>定义（m阶B+树，在B树上的优化）：</h4><ul><li>非叶子节点只做索引，不存储实际信息</li><li>所有的叶子结点中包含了全部元素的实际信息</li><li>所有叶子节点之间都有一个链指针</li></ul><h4 id="实例：如何插入-删除一颗B-树"><a href="#实例：如何插入-删除一颗B-树" class="headerlink" title="实例：如何插入/删除一颗B+树"></a>实例：<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">如何插入/删除一颗B+树</a></h4><p>总体思路与B树差不多，只是在分裂结点时，只是将关键元素复制一遍后分裂</p><h3 id="3-2-3为什么B-Tree更适合用来做存储索引"><a href="#3-2-3为什么B-Tree更适合用来做存储索引" class="headerlink" title="3.2.3为什么B+Tree更适合用来做存储索引"></a>3.2.3为什么B+Tree更适合用来做存储索引</h3><ul><li>B+树的磁盘读写代价更低</li><li>B+树的查询效率更加稳定</li><li>B+树更有利于对数据库的扫描（叶子节点有链表指针链接）</li></ul><p><strong>////////引用</strong></p><h4 id="1-3Hash索引"><a href="#1-3Hash索引" class="headerlink" title="1.3Hash索引"></a>1.3Hash索引</h4><p>优点：</p><ul><li><strong>查找效率高</strong></li></ul><p>缺点：</p><ul><li>仅能满足“=”，<strong>不能使用范围查询</strong></li><li>无法被用来避免数据的<strong>排序操作</strong></li><li>不能利用部分索引键？查询（B+树支持）</li><li>不能避免表扫描？</li><li>遇到大量Hash值相等的情况后性能并不一定就会比B-Tree高</li></ul><h4 id="1-4BitMap"><a href="#1-4BitMap" class="headerlink" title="1.4BitMap"></a>1.4BitMap</h4><h3 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2.索引分类"></a>2.索引分类</h3><h4 id="2-1密集索引和稀疏索引的区别"><a href="#2-1密集索引和稀疏索引的区别" class="headerlink" title="2.1密集索引和稀疏索引的区别"></a>2.1密集索引和稀疏索引的区别</h4><ul><li>密集索引文件中的每个搜索码都对应一个索引值(这就可以理解为<strong>叶子结点不但需要保存键值,还保存位于同一行记录的其他列信息</strong>。由于密集索引决定了表的物理排列顺序，<strong>一个表只有一个物理排列顺序</strong>，所以一个表只能创建一个密集索引)</li><li>稀疏索引文件只为索引码的某些值建立索引项(这可以理解为<strong>叶子结点只保存了键位信息以及该行数据的地址</strong>，有的稀疏索引只保存了键位信息主键)</li></ul><h4 id="2-1MySQL中InnoDB和MyISAM索引的区别"><a href="#2-1MySQL中InnoDB和MyISAM索引的区别" class="headerlink" title="2.1MySQL中InnoDB和MyISAM索引的区别"></a>2.1MySQL中InnoDB和MyISAM索引的区别</h4><p><strong>InnoDB:聚簇表分布</strong></p><ul><li>只有一个<strong>主键索引为密集索引,其他都是稀疏索引</strong></li></ul><p>主键索引(密集索引)的选取</p><ul><li>若一个主键被定义,该主键为密集索引</li><li>若没有主键被定义,该表的第一个唯一非空索引作为密集索引</li><li>若不满足以上条件,innoDB内部会生成一个隐藏主键(密集索引)</li><li>非主键索引存储 <strong>相关键位与其对应的主键值</strong>,之后查找主键索引来获取数据,<strong>包含两次查找</strong></li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/e8c6cc75986aa242aa67426e2d7dcd1c.jpeg" alt="InnoDB的密集索引"></p><p>非主键索引的两次查找</p><ul><li>在<strong>非主键稀疏索引</strong>中查找出该行数据对应的主键</li><li>将该主键在<strong>主键的密集索引</strong>中查出整行的所有信息</li></ul><p><strong>MyISAM:非聚簇分布</strong></p><ul><li>无论主键还是什么都是<strong>稀疏索引</strong></li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/c976d0ec57537f269f37b43d62e78bca.jpeg" alt="MyISAM稀疏索引"></p><ul><li>主键索引和辅助键索引没有区别,只是存储的键值不一样</li><li><strong>索引和数据分开存储</strong></li><li>稀疏索引查找后会得到一个数据的存储地址,对应查询的结果</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/0944b3986fd7e6ecfe21e80d7813965c.png" alt="InnoDB和MyISAM文件存储区别"></p><h3 id="3-如何定位并优化MySQL"><a href="#3-如何定位并优化MySQL" class="headerlink" title="3.如何定位并优化MySQL"></a>3.如何定位并优化MySQL</h3><p><strong>大致思路:</strong></p><ul><li>根据<strong>慢日志</strong>定位慢查询sql</li><li>使用explain等工具分析sql</li><li>修改sql或者尽量让sql走索引</li></ul><p><strong>慢日志:</strong></p><ul><li>默认慢日志关闭,可以通过命令(改变参数)开启慢日志,慢日志会记录所有被认为是慢查询的记录</li><li>修改<strong>long_query_time</strong> : 超过这个阀值会被判定为慢查询</li><li><strong>slow_queries</strong> : 本次会话中的慢查询次数</li></ul><p><strong>explain工具(在sql语句前加explain字段,用于分析sql语句):</strong></p><ul><li>type字段 : <strong>index、all</strong>表示全表查询,可能需要优化</li><li>extra字段 :</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/80e1fcabc5972452605b4168769a1198.jpeg" alt="extra字段"></p><p><strong>修改优化sql:</strong></p><ul><li>添加索引 : <strong>alter table</strong> person_info <strong>add inedex</strong> idx_name(name)</li><li>选择最优索引 : 有时候InnoDB优化器选择的索引方式不一定最优,需要根据实际情况调优</li></ul><h3 id="4-联合索引"><a href="#4-联合索引" class="headerlink" title="4.联合索引"></a>4.联合索引</h3><p><strong>定义:对多个字段同时建立的索引</strong></p><h4 id="4-1最左匹配原则"><a href="#4-1最左匹配原则" class="headerlink" title="4.1最左匹配原则"></a>4.1最左匹配原则</h4><ul><li>mysql会一直向右匹配直到<strong>遇到范围查询</strong>（&gt;、&lt;、beteewn、like）就<strong>停止匹配</strong>（比如建立索引(a,b,c,d),那么a=1 and b=2 and c&gt;5 and d=6中d就用不到索引<strong>,其中a和b的顺序是任意的</strong>）</li></ul><h4 id="4-2联合索引的最左匹配原则的成因"><a href="#4-2联合索引的最左匹配原则的成因" class="headerlink" title="4.2联合索引的最左匹配原则的成因"></a>4.2联合索引的最左匹配原则的成因</h4><ul><li>mysql在创建联合索引时, 会先对最左边第一个字段进行排序, 在第一个字段排序的基础上再一次比较第二个字段以及后面的字段, 最后得到索引的数据</li><li>因此如果不从最左边的开始匹配, 就无法得到后面排序的结果</li></ul><h4 id="4-3索引建立得越多越好吗"><a href="#4-3索引建立得越多越好吗" class="headerlink" title="4.3索引建立得越多越好吗?"></a>4.3索引建立得越多越好吗?</h4><ul><li><strong>数据量小</strong>的表不需要建立索引，建立<strong>会增加额外的索引开销</strong></li><li>数据变更需要维护索引，因此更多的索引意味着<strong>更多的维护成本</strong></li><li>更多的索引意味着也需要<strong>更多的空间</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-解决的问题&quot;&gt;&lt;a href=&quot;#0-解决的问题&quot; class=&quot;headerlink&quot; title=&quot;0.解决的问题&quot;&gt;&lt;/a&gt;0.解决的问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;为什么要使用索引–&amp;gt;&lt;strong&gt;因为索引可以避免全表扫描,提升查找数据的效率,
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.kongkongbai.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.kongkongbai.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>7.机器人运动-DFS和BFS</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer07/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer07/</id>
    <published>2020-05-13T08:05:53.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：<strong>DFS，沿着一条路径一直深入，到头了就回溯</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/a653464eddfcf92bbf2c7208f2f9da3e.png" alt="机器人的运动范围DFS"></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/36e3d306fa001189881037ede28cec30.png" alt="机器人的运动范围"></p><p>思路二：<strong>BFS，一层一层的遍历，直到到达最后一层（运用队列）</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/7a6ae481304e73c4c62299ceab3a2e91.png" alt="机器人的运动范围BFS"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>6.矩阵中的路径-DFS</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer06/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer06/</id>
    <published>2020-05-13T08:04:10.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：深度优先遍历+回溯。从第一个字符开始遍历，如果等于目标字符，则遍历它的上下左右四个位置是否也满足条件，如果满足就继续向下搜寻，如果不满足，则回溯</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/94c78d13aa12308d5bb7eeb906ef5bc8.png" alt="6.矩阵中的路径"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>5.斐波拉契-动态规划</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer05/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer05/</id>
    <published>2020-05-13T08:02:30.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><p>F(0) = 0,  F(1) = 1<br>F(N) = F(N – 1) + F(N – 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>[<img src="https://pic.rmb.bdstatic.com/bjh/3b54a4ce1a386fdb2e39819d540161d5.png" alt="斐波那契数列的动态规划"></p><p><strong>动态规划解析：</strong><br><strong>状态定义</strong>： 设 dp为一维数组，其中 dp[i] 的值代表 斐波那契数列第 ii 个数字 。<br><strong>转移方程</strong>： dp[i + 1] = dp[i] + dp[i – 1]，即对应数列定义 f(n + 1) = f(n) + f(n – 1) ；<br><strong>初始状态</strong>： dp[0]=0, dp[1] = 1 ，即初始化前两个数字；<br><strong>返回值</strong>： dp[n] ，即斐波那契数列的第 nn 个数字。</p><p><a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">动态规划算法参考博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：&lt;/p&gt;
&lt;p&gt;F(0) 
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>4.使用双栈实现队列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer04/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer04/</id>
    <published>2020-05-13T08:00:57.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路：插入时，先将s1栈中所有元素压入s2中，然后将value压入s1，最后将s2的元素压入s1；删除时，直接删除s1栈中的栈顶元素</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/34c0b15323f61b4cb83109f6904441b2.png" alt="双栈实现队列"></p><h3 id="3-实现队列的方式"><a href="#3-实现队列的方式" class="headerlink" title="3.实现队列的方式"></a>3.实现队列的方式</h3><ul><li>循环数组，注意双指针的取余操作</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/f890b44bf420a258f2282957f0b7e895.png" alt="循环数组实现队列"></p><p>增加元素：（rear+1）%size  删除元素（front+1）%size</p><ul><li>集合</li><li>双栈</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>3.二维数组查找</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer03/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer03/</id>
    <published>2020-05-13T07:59:39.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路：线性查找，从矩阵右上角或者左下角开始查找，因为右下角的数始终大于左上角的数</p><p>[<img src="https://pic.rmb.bdstatic.com/23e5e7abf6349ea6a4461bf879abc7bc.png" alt="二维数组查找"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>2.多数元素</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer02/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer02/</id>
    <published>2020-05-13T07:57:25.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：Hash表</p><p>思路二：排序，求下标为【n/2】的元素</p><p><strong>思路三：Boyer-Moore 投票算法</strong></p><p>如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 <code>0</code>，从结果本身我们可以看出众数比其他数多。</p><p>[<img src="https://pic.rmb.bdstatic.com/0f7b43191525c7c4e48918aa6ca56385.png" alt="Boyer-Moore 投票算法">]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。&lt;/p&gt;
&lt;p&gt;你
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>1.只出现一次的数字</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer01/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer01/</id>
    <published>2020-05-13T07:51:08.000Z</published>
    <updated>2020-05-15T14:07:48.853Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：Hash表存储数字出现次数"><a href="#思路一：Hash表存储数字出现次数" class="headerlink" title="思路一：Hash表存储数字出现次数"></a>思路一：Hash表存储数字出现次数</h5><p><strong>如何遍历Hash表？</strong></p><ol><li><p>迭代器：</p><p>Iterator iter = map.keySet().iterator();</p><p>while (iter.hasNext())</p><p><strong>Or</strong></p></li></ol><p>   Iterator iter = map.entrySet().iterator();</p><p>   while (iter.hasNext()) 【<strong>效率高</strong>】</p><ol start="2"><li><p>for each：<br>**for (String key : map.keySet())<br>OR<br>for (Entry entry : map.entrySet())</p><p>**</p></li></ol><h5 id="思路二：数学法，针对重复数字只出现两次；"><a href="#思路二：数学法，针对重复数字只出现两次；" class="headerlink" title="思路二：数学法，针对重复数字只出现两次；"></a>思路二：数学法，针对重复数字只出现两次；</h5><p><strong>2∗(a+b+c)−(a+a+b+b+c)=c</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return 2 * sum(set(nums)) - sum(nums)</span><br></pre></td></tr></table></figure><p><strong>思路三：位运算，异或操作</strong></p><p>如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位<br><strong>a⊕0=a</strong><br>如果我们对相同的二进制位做 XOR 运算，返回的结果是 0<br><strong>a⊕a=0</strong><br>XOR 满足交换律和结合律<br> <strong>a⊕b⊕a=(a⊕a)⊕b=0⊕b=b</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">    result = result ^ num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>编程技巧篇</title>
    <link href="http://www.kongkongbai.com/Algorithm/Summary/algorithmSkill01/"/>
    <id>http://www.kongkongbai.com/Algorithm/Summary/algorithmSkill01/</id>
    <published>2020-05-13T07:46:21.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数学归纳法"><a href="#1-数学归纳法" class="headerlink" title="1.数学归纳法"></a>1.数学归纳法</h2><p>数学归纳法时编码的依据</p><h4 id="用于证明断言对所有自然数成立"><a href="#用于证明断言对所有自然数成立" class="headerlink" title="用于证明断言对所有自然数成立"></a>用于证明断言对所有自然数成立</h4><ul><li>证明对于N=1成立</li><li>证明N&gt;1时：如果对于N-1成立，那么对于N成立</li></ul><h4 id="实例：证明1-2-3…-n-n-n-1-2成立"><a href="#实例：证明1-2-3…-n-n-n-1-2成立" class="headerlink" title="实例：证明1+2+3…+n = n(n+1)/2成立"></a>实例：证明1+2+3…+n = n(n+1)/2成立</h4><ul><li>当n=1时，1 = 1*2/2 成立</li><li>当n = n-1时，如果1+2+3+…+(n-1)=(n-1)n/2成立</li><li>那么1+2+3+…+n = 1+2+3+…+(n-1) + n</li><li>则1+2+3+…+n = (n-1)n/2 + n = n(n+1)/2成立</li><li>所以等式成立</li></ul><h4 id="类比编码：设计int-sum（int-n）：返回1-2-…-n的值"><a href="#类比编码：设计int-sum（int-n）：返回1-2-…-n的值" class="headerlink" title="类比编码：设计int sum（int n）：返回1+2+…+n的值"></a>类比编码：设计int sum（int n）：返回1+2+…+n的值</h4><ul><li>当n = 1时，if(n == 1) return 1;</li><li>当n = n-1时，else return sum(n-1) +n;</li></ul><h2 id="2-递归控制"><a href="#2-递归控制" class="headerlink" title="2.递归控制"></a>2.递归控制</h2><h4 id="如何证明递归函数正确执行？数学归纳法的数学语言–-gt-程序语言"><a href="#如何证明递归函数正确执行？数学归纳法的数学语言–-gt-程序语言" class="headerlink" title="如何证明递归函数正确执行？数学归纳法的数学语言–&gt;程序语言"></a>如何证明递归函数正确执行？数学归纳法的数学语言–&gt;程序语言</h4><h3 id="2-1递归书写方法"><a href="#2-1递归书写方法" class="headerlink" title="2.1递归书写方法"></a>2.1递归书写方法</h3><ul><li><strong>严格定义递归函数的作用</strong>，包括参数，返回值，Side-effect（附加影响，比如它改变的全局变量）</li><li><strong>先一般，后特殊</strong></li><li>每次调用必须<strong>缩小问题规模</strong></li><li>每次问题规模<strong>缩小程度必须为1</strong></li></ul><h3 id="2-2实战例题"><a href="#2-2实战例题" class="headerlink" title="2.2实战例题"></a>2.2实战例题</h3><h5 id="例1-链表创建-使用递归"><a href="#例1-链表创建-使用递归" class="headerlink" title="例1.链表创建(使用递归)"></a>例1.链表创建(使用递归)</h5><p>输入一个数组，将数组中的每个数据放在结点中，组成一个链表，并返回头指针</p><p>Node CreateLinkedList(List<Integer> values)</p><p>总体思路：将问题的规模减小1，从<strong>创建长度为n的链表，到创建长度为n-1的链表</strong>，然后将头结点与长度为n-1的链表组合起来。</p><p>创建结点类 ：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/55eab06880ed96dc42d0b9e250ae91a7.png" alt="createLinkedList01"></p><p>函数算法：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/e62f4bc39edc3cd4be1fff864771164f.png" alt="createLinkedList02"></p><h5 id="例2：链表反转"><a href="#例2：链表反转" class="headerlink" title="例2：链表反转"></a>例2：链表反转</h5><p>总体思路：将问题规模减少1，即<strong>从将长度为n的链表进行反转，转换为将长度为n-1的链表进行反转</strong>，再将第一个结点放置链表的尾部</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/b9c0007af0de086a2d2db16f3cabe501.png" alt="reverseLinkedList01"></p><p>实现过程：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/dfcdcb61d650abe73a13bec789959dc7.png" alt="reverseLinkedList02"></p><h5 id="例三：列出所有的组合（较难理解）"><a href="#例三：列出所有的组合（较难理解）" class="headerlink" title="例三：列出所有的组合（较难理解）"></a>例三：列出所有的组合（较难理解）</h5><ul><li>input：【1，2，3，4】，2</li><li>output：【1，2】、【1，3】、【1，4】、【2，3】、【2，4】、【3，4】列出所有两个数字组成的组合</li></ul><p>总体思路：将问题规模减少为选择第一个元素：combainations（data[m-1] , n-1 ) 和 不选择第一个元素：combainations (data[m-1],n)。每次只选择第一个元素，当n为0时，表示全部元素已选完，输出存放的元素。</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/d5448b1a780b3f703fa8ee99450b83e4.png" alt="combinations01"></p><h3 id="2-3递归的缺点"><a href="#2-3递归的缺点" class="headerlink" title="2.3递归的缺点"></a>2.3递归的缺点</h3><h5 id="Stack："><a href="#Stack：" class="headerlink" title="Stack："></a>Stack：</h5><ul><li>函数调用<strong>开销大</strong></li><li>Stack Overflow：递归过大时可能出现<strong>栈溢出</strong></li><li>问题规模大时，<strong>消耗资源过大</strong></li></ul><h2 id="3-循环控制"><a href="#3-循环控制" class="headerlink" title="3.循环控制"></a>3.循环控制</h2><h3 id="3-1写循环的基本思路"><a href="#3-1写循环的基本思路" class="headerlink" title="3.1写循环的基本思路"></a>3.1写循环的基本思路</h3><h5 id="数学归纳法运用于循环中"><a href="#数学归纳法运用于循环中" class="headerlink" title="数学归纳法运用于循环中"></a>数学归纳法运用于循环中</h5><h5 id="循环不变式（loop-invariant）、"><a href="#循环不变式（loop-invariant）、" class="headerlink" title="循环不变式（loop invariant）、"></a>循环不变式（loop invariant）、</h5><ul><li>是一句断言定义各变量所满足的条件</li></ul><p>var a,b;</p><p>while(){</p><p>}</p><p>a,b必须满足 <strong>进入循环之前满足条件，退出循环之后也要满足条件</strong></p><h5 id="循环书写方法："><a href="#循环书写方法：" class="headerlink" title="循环书写方法："></a>循环书写方法：</h5><ul><li>定义循环不变式，并在循环体每次结束后<strong>保持</strong>循环不变式</li><li>先<strong>一般</strong>，后<strong>特殊</strong></li><li>每次必须<strong>向前推进</strong>循环不变式中涉及的变量值</li><li>每次推进规模必须为1</li></ul><h3 id="3-2实战例题"><a href="#3-2实战例题" class="headerlink" title="3.2实战例题"></a>3.2实战例题</h3><h5 id="例一：链表反转"><a href="#例一：链表反转" class="headerlink" title="例一：链表反转"></a>例一：链表反转</h5><p>总体思路：定义循环不变式，定义两个变量：<strong>newHead指向已经成功反转链表的头指针，currentHead还未反转链表的头指针</strong>；通过不断推进两个变量（缩小规模），来完成所有结点反转</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/c63b2bed9df072a4f7f1fab9f753c5d4.png" alt="LinkedListReverser-loop01"></p><h5 id="例二：链表中delete-if"><a href="#例二：链表中delete-if" class="headerlink" title="例二：链表中delete_if"></a>例二：链表中delete_if</h5><p>总体思路：定义循环不变式，定义一个变量：prevHead指向已经成功处理完成链表的尾结点；通过不断推进该变量直至其getNext()==null时，所有链表处理完毕。</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/1b4461c6363f84490cd5a24f9fc4736b.png" alt="deleteIfEquals-loop"></p><h2 id="3-3边界控制"><a href="#3-3边界控制" class="headerlink" title="3.3边界控制"></a>3.3边界控制</h2><h5 id="例一：二分查找"><a href="#例一：二分查找" class="headerlink" title="例一：二分查找"></a>例一：二分查找</h5><ul><li>在有序数组中查找元素K，返回K所在下标</li><li>binarySearch（【1，2，10，15，100】，15） == 3</li></ul><p>二分查找思路：</p><ul><li>规定查找的值可能在数组arr内下标区间a，b</li><li>计算区间a，b的中间点m</li><li>若k&lt;arr【m】，将区间缩小为a，m，继续二分查找</li><li>若k&gt;arr【m】，将区间缩小为m，b，继续二分查找</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/7ea352c1c9eb805c61f435c2ce4c94b4.png" alt="binaruSearch01"></p><ul><li>b的边界控制可以为arr.length，也可以为arr.length-1(这里选择length)</li><li>考虑三种边界情况<br>//a == b : m = a –&gt;空集的时候<br>//b == a+1 : m = a –&gt;一个元素的时候<br>//b == a+2 : m = a+1 –&gt;多个元素的时候</li><li>int m = (a + b) / 2 可能会引起整数溢出</li></ul><h2 id="4-树"><a href="#4-树" class="headerlink" title="4.树"></a>4.树</h2><h3 id="4-1二叉树的遍历"><a href="#4-1二叉树的遍历" class="headerlink" title="4.1二叉树的遍历"></a>4.1二叉树的遍历</h3><ul><li>前序遍历：先遍历<strong>树根</strong>，然后前序遍历<strong>左子树</strong>，再前序遍历<strong>右子树</strong></li><li>中序遍历：先中序遍历<strong>左子树</strong>，然后中序遍历<strong>树根</strong>，再中序遍历<strong>右子树 【中序遍历的结果是顺序结果】</strong></li><li>后序遍历：先后序遍历<strong>左子树</strong>，然后后序遍历<strong>右子树</strong>，再后序遍历<strong>树根</strong></li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/782c366bb0f1702a81d19485d208332e.png" alt="树的遍历"></p><p>代码实现：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/57ccc49d5236d95048aa4f75cd81e9cc.png" alt="树的遍历02"></p><h3 id="4-2根据前序中序构造二叉树"><a href="#4-2根据前序中序构造二叉树" class="headerlink" title="4.2根据前序中序构造二叉树"></a>4.2根据前序中序构造二叉树</h3><p>总体思路：</p><ul><li>通过前序第一个结点–&gt;确定根节点</li><li>确认前序中左子树序号和中序中左子树序号，重新递归找左子树的根节点</li><li>右子树同上</li></ul><p>代码实现：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/f3c5b6cde772d1bb689a69c258b3d3a2.png" alt="通过前中序寻找后序"></p><p>细节：<strong>subString(startindex,endindex) –&gt;截取字符串 [startIndex，endIndex)</strong></p><h3 id="4-3寻找中序遍历的下一个结点"><a href="#4-3寻找中序遍历的下一个结点" class="headerlink" title="4.3寻找中序遍历的下一个结点"></a>4.3寻找中序遍历的下一个结点</h3><p>前提条件：这棵二叉树是双向的，子树存储了根的指针</p><p>总体实现：</p><ul><li>考虑N下一个结点为：左子树、根节点、右子树这三种情况</li><li>N的下一个结点不可能为左子树，因为中序遍历为：左根右</li><li>若N的右子树存在，返回右子树的<strong>第一个结点（中序遍历的第一个结点）</strong>；否则考虑根节点</li><li>若N的根节点存在，若N为根节点的左子树，则返回该根节点，否则一直往根节点走，指导是某个结点的左子树为止</li></ul><p>代码实现：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/86432d98799804379f0c1a0566dc4ba8.png" alt="中序遍历的下一个结点"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-数学归纳法&quot;&gt;&lt;a href=&quot;#1-数学归纳法&quot; class=&quot;headerlink&quot; title=&quot;1.数学归纳法&quot;&gt;&lt;/a&gt;1.数学归纳法&lt;/h2&gt;&lt;p&gt;数学归纳法时编码的依据&lt;/p&gt;
&lt;h4 id=&quot;用于证明断言对所有自然数成立&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Summary" scheme="http://www.kongkongbai.com/categories/Algorithm/Summary/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>面试高频算法题</title>
    <link href="http://www.kongkongbai.com/Algorithm/Summary/interviewAlgorithm/"/>
    <id>http://www.kongkongbai.com/Algorithm/Summary/interviewAlgorithm/</id>
    <published>2020-05-13T07:38:20.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><ul><li>用数组【start，end】中间的数与target比较，通过比较结果，二分的缩小下一次的比较范围</li></ul><p><img src="https://pic.rmb.bdstatic.com/bjh/793c33b9fdaf19d4c4f9fe022c520371.png" alt="二分查找"></p><h3 id="2-数组：将数组中0放后面，其他顺序不变"><a href="#2-数组：将数组中0放后面，其他顺序不变" class="headerlink" title="2.数组：将数组中0放后面，其他顺序不变"></a>2.数组：将数组中0放后面，其他顺序不变</h3><ul><li>思路：<a href="https://blog.csdn.net/weixin_42600072/article/details/88391582" target="_blank" rel="noopener">双指针策略</a>，定义一个指针指向新数组的有效信息末尾，遍历数组，将有效信息（除0外）按序排列到数组前面，最后再数组后面补0</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/2c869117b58e42f61bd4c564ba0a6ce5.png" alt="MoveZeros"></p><h3 id="3-数组：有序数组去重"><a href="#3-数组：有序数组去重" class="headerlink" title="3.数组：有序数组去重"></a>3.数组：有序数组去重</h3><ul><li><strong>双指针策略，定义一个慢指针slow，一个快指针fast</strong></li><li>如果num[slow] ==num[fast] ，将快指针向后移</li><li>如果num[slow] != num[fast], 将慢指针向后移，并且赋值num[slow] = num[fast]</li><li>直到快指针走到数组末尾，此时的慢指针即指向去重后的有序数组末尾</li><li><a href="https://www.cnblogs.com/zhanghongfeng/p/11771758.html" target="_blank" rel="noopener">参考</a></li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/3ba51664daaf41d107b1fb3d7d086345.png" alt="removeDuplicates"></p><h3 id="4-对仅有0，1，2的数组排序"><a href="#4-对仅有0，1，2的数组排序" class="headerlink" title="4.对仅有0，1，2的数组排序"></a>4.对仅有0，1，2的数组排序</h3><ul><li>双指针策略，定义一个指针zero，从前指向最后一个0元素的序号，定义一个指针two，从后指向最后一个2元素的序号</li><li>遍历数组，如果是1，则返回跳过往后判断，如果是0，则与num【zero+1】交换位置并zero++，如果是2，则与num【two-1】交换位置并two–</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/b9ef8ab0bc1d8ee84f01f82ec213b010.png" alt="对0、1、2排序"></p><h3 id="5-数组中第K大元素——堆排序（未完成）"><a href="#5-数组中第K大元素——堆排序（未完成）" class="headerlink" title="5.数组中第K大元素——堆排序（未完成）"></a>5.数组中第K大元素——堆排序（未完成）</h3><ol><li>思路一：维护K最小堆，剩下元素与顶堆比较，若大于则删除顶堆元素后插入，最后剩下的顶堆元素就是要找的元素</li><li>思路二：快速排序方法</li><li><a href="https://blog.csdn.net/qq_34538534/article/details/93377862" target="_blank" rel="noopener">参考博客</a></li></ol><h3 id="6-有序数组两个数和等于target"><a href="#6-有序数组两个数和等于target" class="headerlink" title="6.有序数组两个数和等于target"></a>6.有序数组两个数和等于target</h3><ul><li>思路一：用Hash表来做（<a href="http://39.107.124.120/2020/03/18/两数相加/" target="_blank" rel="noopener">参考</a>）</li><li>思路二：双指针，以前一后，夹逼</li></ul><h3 id="7-第一个缺失的正整数"><a href="#7-第一个缺失的正整数" class="headerlink" title="7.第一个缺失的正整数"></a>7.第一个缺失的正整数</h3><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数</p><p><strong>思路：</strong></p><ul><li>遍历第一遍，将正整数放到正确的索引中</li><li>遍历第二遍，将第一个缺失的正整数找出来</li></ul><p><strong>代码：</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/e1bd9f15cf363440aafd12b2e20bee52.png" alt="第一个缺失的正整数"></p><h3 id="8-三数之和为0"><a href="#8-三数之和为0" class="headerlink" title="8.三数之和为0"></a>8.三数之和为0</h3><p><strong>思路：</strong></p><p>固定一个数，将问题转化为在数组中找两数之和等于target，使用HashMap</p><p><strong>代码(未解决重复元素的情况)：</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/62141c76ba407151ee4b8cf9d9c2e363.png" alt="三数之和为0"></p><p><strong>代码（解决去重和重复元素</strong>）：</p><ul><li>重复元素：由exist判断进行自动规避</li><li>去重：对结果元素进行排序<strong>list.sort(Comparator.naturalOrder())</strong></li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/309aa4f700c89f48f73c2179a488de23.png" alt="三数之和（去重+处理重复元素）"></p><h3 id="9-循环有序数组二分查找"><a href="#9-循环有序数组二分查找" class="headerlink" title="9.循环有序数组二分查找"></a>9.循环有序数组二分查找</h3><p><strong>思路：</strong></p><p>相比于传统的二分查找，再判断target在mid左边还是右边时，加一个判断target和mid是否同时大于（当mid&gt;target时）或者小于（当mid&lt;target时）left</p><p><strong>代码：</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/d6a018a68878916d3f6ae56982ceca2c.png" alt="循环有序数组的二分查找"></p><h3 id="10-根据字符出现次数排序"><a href="#10-根据字符出现次数排序" class="headerlink" title="10.根据字符出现次数排序"></a><strong>10.根据字符</strong>出现次数排序</h3><p><strong>思路：</strong></p><ul><li>使用HashMap将字符串中各个字符的出现次数</li><li><strong>使用Collections.sort进行HashMap的排序，结果存在List&gt;中（较难）</strong></li><li>使用StringBuilder sb = new StringBuilder()进行字符串的拼接</li></ul><p><strong>代码：</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/c4ec845faf6193d59e0dba07e21d8cf2.png" alt="根据字符出现次数排序"></p><h3 id="11-子数组之和等于所给数的个数"><a href="#11-子数组之和等于所给数的个数" class="headerlink" title="11.子数组之和等于所给数的个数"></a>11.子数组之和等于所给数的个数</h3><p>数组为已排序数组，求有多少个这样的数组</p><p><strong>思路一：双指针思想，定义一个数组的起始指针start和end指针，如果数组总和大于target，start前移；如果小于，end后移；如果相等，则正确组数加1后，start和end均后移</strong></p><p><strong>思路二：创建数组sum[]，其中sum[n]表示数组前n个数之和，再二次遍历sum，计算sum[m]-sum[n]：表示n到m数字的和，与k进行比较（复杂，不推荐）</strong></p><p>变体：给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p><p><strong>思路一：思路一不行，可以延续思路二</strong></p><p><strong>思路二：使用HashMap+前缀+取模，存放sum%k的值，如果map中已经存在了sum%k这个value，判断数组中元素是否大于1，大于则存在</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/e1c40b7bdf8bd78865f9007ec7536144.png" alt="连续子数组之和"></p><h3 id="12-最大子序列之和"><a href="#12-最大子序列之和" class="headerlink" title="12.最大子序列之和"></a><strong>12.最大子序列之和</strong></h3><p><strong>思路：计算前n个数的和，若为负数则抛弃，若为正数，则与max进行比较，max为前面最大子序列之和</strong></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="13-根据x值划分链表"><a href="#13-根据x值划分链表" class="headerlink" title="13.根据x值划分链表"></a>13.根据x值划分链表</h3><p>-给定一个链表和一个值x,将链表划分成两 部分,使得划分后小于x的结点在前,大于 等于x的结点在后。在这两部分中要保持原 链表中的出现顺序。</p><p><strong>思路一：遍历的时候新建立两个链表，最后合并，需要建立4个新指针（左右各两个指向头尾），另外需要判断头结点为空的情况</strong>（<a href="https://www.jianshu.com/p/d37786e9d83e" target="_blank" rel="noopener">参考博客</a>）</p><p><strong>思路一改进：在思路一的基础上设计空头节点，保留头部信息，最后不需要进行非空判断。</strong></p><h3 id="14-调整单链表使得奇数位置的元素位于偶数位置元素之前"><a href="#14-调整单链表使得奇数位置的元素位于偶数位置元素之前" class="headerlink" title="14.调整单链表使得奇数位置的元素位于偶数位置元素之前"></a>14.调整单链表使得奇数位置的元素位于偶数位置元素之前</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个单链表，使得奇数位置的元素位于偶数位置元素之前。比如说：1-&gt;2-&gt;4-&gt;5-&gt;6-&gt;NULL，调整以后1-&gt;4-&gt;6-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>思路一：分为odd和even两个链表，设置三个指针(也可以理解为四个，因为odd链表头为本来链表的头结点)，指针odd指向奇数位置的元素，指针even指向偶数位置的元素，指针evenHead指向第一个偶数位置的元素按照奇数位置和偶数位置把链表划分为两部分，然后，奇数链表尾指针指向偶数位置首指针。时间复杂度也是o(n)。（<a href="https://blog.csdn.net/yang20141109/article/details/51287226?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">参考博客</a>）</strong></p><h3 id="15-删除有序链表中所有重复结点（简单）"><a href="#15-删除有序链表中所有重复结点（简单）" class="headerlink" title="15.删除有序链表中所有重复结点（简单）"></a>15.删除有序链表中所有重复结点（简单）</h3><p><strong>思路一：创建一个last指针，判断last.val与last.next.val是否相等，如果相等则删除last.next指针</strong></p><h3 id="16-根据指针删除结点"><a href="#16-根据指针删除结点" class="headerlink" title="16.根据指针删除结点"></a>16.根据指针删除结点</h3><p><strong>思路一：正常思路是我们要删除一个结点，需要让这个结点的前一个节点指向这个结点的下一个结点。</strong></p><p><strong>思路二：我们将这个结点的下一个结点的val赋值给当前结点，然后跳过下一个结点即可。即保存下一个结点的信息，然后跳过下一个结点</strong></p><h3 id="17-删除倒数第n个结点"><a href="#17-删除倒数第n个结点" class="headerlink" title="17.删除倒数第n个结点"></a>17.删除倒数第n个结点</h3><p><strong>思路一：遍历一遍确定位置，然后在删除指定位置的结点（可以考虑hashmap）</strong></p><p><strong>思路二：双指针思路，两个指针start和end同时指向head，然后end向后移动n位，之后start和end同时向后移动，直到end指向null</strong></p><h3 id="18-判断链表是否为回文"><a href="#18-判断链表是否为回文" class="headerlink" title="18.判断链表是否为回文"></a>18.判断链表是否为回文</h3><p><strong>思路一：用数组存储链表的数据，然后通过数组进行判断（不满足空间复杂度）</strong></p><p><strong>思路二：全部反转链表后，与原链表进行比较</strong></p><p><strong>思路三：通过快慢指针找到中间结点，然后翻转后面一半的链表后，从head和中间结点以后比较</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/05b6fa761d3e74a90fc09327fb39fd63.png" alt="快慢指针找中间结点"></p><h3 id="19-找到两条单向链表的交点"><a href="#19-找到两条单向链表的交点" class="headerlink" title="19.找到两条单向链表的交点"></a>19.找到两条单向链表的交点</h3><p><strong>思路一：Hash法，将第一个链表结点地址存入hash表中，然后遍历第二条链表查看是否有相同的结点</strong></p><p><strong>思路二：回环法，遍历第一个链表到链尾，然后将其指向第二个链表头部，如果形成了回环则表示两个链表相交</strong></p><p><strong>思路三：尾结点判断法，遍历两个链表到尾部，如果相等则代表相交</strong></p><h3 id="20-找到环形链表的交点"><a href="#20-找到环形链表的交点" class="headerlink" title="20.找到环形链表的交点"></a>20.找到环形链表的交点</h3><p><a href="https://blog.csdn.net/jiary5201314/article/details/50990349" target="_blank" rel="noopener">参考博客</a></p><p><strong>思路：这是一种特殊情况，首先清楚一个单向链表和一个有环链表是不可能相交的，所以如果有环链表相交，必定公用同一个环，所以我们将第一个链表的换解开后，判断第二个链表是否回环即可判断是否相交</strong></p><p><strong>判断是否有环：快慢指针、hash表存放</strong></p><p><strong>判断环点：hash表存放</strong></p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="21-给定n，求最少需要几个完全平方数组成"><a href="#21-给定n，求最少需要几个完全平方数组成" class="headerlink" title="21.给定n，求最少需要几个完全平方数组成"></a>21.给定n，求最少需要几个完全平方数组成</h3><p><strong>思路一：（推荐）动态规划，一个数最少等于前面所有可能数最少加上一个完全平方数。创建一个一维数组来存储中间（<a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">动态规划算法博客</a>）</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/09367e1840a2fd0bea2cbd6da7dbc62e.png" alt="动态规划找完全平方"></p><p><strong>思路二：贪心枚举，维护一个完全平方数表（HashSet），我们定义一个is_divided（int n,int count）函数来确定n是否可以被分解count次后满足条件，我们只需要返回true or false 而不需要知道确切是那些组合。之后我们从count=1开始枚举，直到找到最小的count</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/other/97a1554e71a47ee316d902a7c3452263.png" alt="贪心枚举找完全平方"></p><h3 id="22-给定数组，求前k个频率最高的数"><a href="#22-给定数组，求前k个频率最高的数" class="headerlink" title="22.给定数组，求前k个频率最高的数"></a>22.给定数组，求前k个频率最高的数</h3><p><strong>思路一：使用HashMap存放数字以及其频率，然后根据Value进行排序，使用java的Collections.sort()对Map.Entry进行排序**</strong>，具体实现参考第10题**</p><p><strong>思路二：（<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/" target="_blank" rel="noopener">参考</a>）改进，在排序上可以对HashMap进行堆排序，维护k个最小优先队列</strong></p><p><a href="https://www.cnblogs.com/gnivor/p/4841191.html" target="_blank" rel="noopener">优先队列的使用</a></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/2c2e37693d70e4b943e375e59f5a9b1c.png" alt="求前K个频率最高的数_优先队列"></p><h3 id="23-合并K个已排序链表"><a href="#23-合并K个已排序链表" class="headerlink" title="23.合并K个已排序链表"></a>23.合并K个已排序链表</h3><p><strong>思路一：优先队列，对每次的首节点进行排序，维护一个优先队列，注意每次指针的向后移动，确保堆中维护的是当前位置的首节点</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/320304c0a26f1147c0ceb6b7acbe6f4c.png" alt="合并k个已排序链表_优先队列"></p><h3 id="24-O-1-时间实现栈内max"><a href="#24-O-1-时间实现栈内max" class="headerlink" title="24.O(1)时间实现栈内max"></a>24.O(1)时间实现栈内max</h3><p><strong>思路一：创建一个maxStack辅助栈，每次入栈时判断x与顶部元素大小，若x大于栈顶，则进入辅助栈，否则将栈顶元素再次加入maxStack中；出栈时同时出。</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/09e20c0ac904c72a3396fd62c57abe82.png" alt="max栈的创建"></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="25-二叉树的最大-最小深度"><a href="#25-二叉树的最大-最小深度" class="headerlink" title="25.二叉树的最大/最小深度"></a>25.二叉树的最大/最小深度</h3><ul><li>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</li></ul><p><strong>思路一：递归</strong></p><p>最小深度：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/d7a9fb81459a9b722058afea438979fd.png" alt="二叉树最小深度"></p><p>最大深度不用考虑根节点的有一个子树为空的情况。</p><h3 id="26-二叉树翻转左右孩子"><a href="#26-二叉树翻转左右孩子" class="headerlink" title="26.二叉树翻转左右孩子"></a>26.二叉树翻转左右孩子</h3><p><strong>思路一：递归，先翻转左右两个子树，然后让子树进行翻转</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/6a27dcd4b6f864c711a6b4f521cb1c3c.png" alt="左右翻转二叉树"></p><h3 id="27-求完全二叉树的节点个数"><a href="#27-求完全二叉树的节点个数" class="headerlink" title="27.求完全二叉树的节点个数"></a>27.求完全二叉树的节点个数</h3><p><strong>思路一：递归，用求二叉树的方式求完全二叉树的节点数，没有用到二叉树的特性</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/4eea51be13e7f06ca2b45485cec42729.png" alt="二叉树的节点数"></p><p><strong>思路二：完全二叉树的节点数=底部+除底部以外的完全满二叉树</strong>，计算底部时：使用helper()函数计算最后一层节点的数量，传入的depth是下面最多还有的深度，所以depth == 0也就是深度遍历终止的地方，此处有节点返回1，无节点返回0。<br>关键的剪枝操作：当左子树的最后一层的节点没有充满时，直接返回左子树中的最后一层的节点数（右子树最后一层一定没有节点）。（<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/ji-bai-100zhong-de-fang-fa-zhong-zui-hao-li-jie-de/" target="_blank" rel="noopener">参考</a>）</p><h3 id="28-根节点到叶子结点和为sum的路径"><a href="#28-根节点到叶子结点和为sum的路径" class="headerlink" title="28.根节点到叶子结点和为sum的路径"></a>28.根节点到叶子结点和为sum的路径</h3><p><strong>思路一：递归，如果当前节点和不为sum，通过sum=sum-root.val向下遍历子节点。回溯，定义一个LinkedList的path存放路径。</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/ac711b0d9c10b30a9de9ed850971e62c.png" alt="路径和为sum的路径"></p><h3 id="29-路径和为sum的总条数"><a href="#29-路径和为sum的总条数" class="headerlink" title="29.路径和为sum的总条数"></a>29.路径和为sum的总条数</h3><p><strong>思路一：可以去掉对叶子节点的判断</strong></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="30-判断BST"><a href="#30-判断BST" class="headerlink" title="30.判断BST"></a>30.判断BST</h3><p>思路一：如果只是判断左子树&lt;根&lt;右子树是不够的，还需要判断左边子树所有的节点小于根，以及右边的所有节点大于根，<strong>所以需要有一个上届和下届</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/other/8e3f72d0ce1890e72879982bdf5cb1c2.png" alt="判断BST"></p><p><strong>思路二：中序遍历</strong></p><h3 id="31-有序数组转二叉平衡搜索树"><a href="#31-有序数组转二叉平衡搜索树" class="headerlink" title="31.有序数组转二叉平衡搜索树"></a>31.有序数组转二叉平衡搜索树</h3><p>思路一：二分法</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/92c1aa0bc855fbf91911a93a1bf5a5a0.png" alt="有序数组转二叉平衡树"></p><h3 id="32-普通二叉树中两个节点的最小公共祖先"><a href="#32-普通二叉树中两个节点的最小公共祖先" class="headerlink" title="32.普通二叉树中两个节点的最小公共祖先"></a>32.普通二叉树中两个节点的最小公共祖先</h3><p>思路一：递归，定义mid判断根节点是否有目标结点，left判断左子树是否有目标结点，right判断右子树是否有目标结点。如果<strong>mid+left+right=2则表示当前节点就是公共最小祖先</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/1d11f23b84305fd7cd0b8a800e7247cb.png" alt="公共最小祖先结点"></p><h3 id="33-求树的左叶子节点之和"><a href="#33-求树的左叶子节点之和" class="headerlink" title="33.求树的左叶子节点之和"></a>33.求树的左叶子节点之和</h3><p>思路：递归遍历，无论是前序、中序、还是后序，关键是如何判断一个结点是左叶子结点</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/624a75d5ef4e86748db3f5a87b9c25c8.png" alt="左子树之和"></p><h3 id="34-非递归遍历"><a href="#34-非递归遍历" class="headerlink" title="34.非递归遍历"></a>34.非递归遍历</h3><p><strong>前序遍历：</strong></p><p>1.先将根节点入栈<br>2.访问根节点<br>3.如果根节点存在右孩子，则将右孩子入栈<br>4.如果根节点存在左孩子，则将左孩子入栈（<strong>注意：一定是右孩子先入栈，然后左孩子入栈</strong>）<br>5.重复2-4</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/f1f0607c09c8dee2066575aa5bd41f43.png" alt="二叉树非递归前序遍历"></p><p><strong>中序遍历：</strong></p><p>1.先将根节点入栈<br>2.将当前节点的所有左孩子入栈，直到左孩子为空<br>3.访问栈顶元素，如果栈顶元素存在右孩子，则继续第2步<br>4.重复第2、3步，直到栈为空并且所有的节点都被访问</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/fbd0e8f47e2c1ad73085390b635ea0ce.png" alt="二叉树非递归中序遍历"></p><p><strong>后序遍历：</strong></p><ol><li>根节点入栈，并定一个pre指针指向上一次访问的结点，初始为null</li><li>获取栈顶元素，如果栈顶元素的左右儿子同时为空或者pre指针为栈顶元素的左右儿子之一（即已被访问过的结点），则访问栈顶元素，并设置pre指针为刚刚的栈顶元素</li><li>如果栈顶元素不同时为空，则先判断右子树入栈，只有判断左子树入栈</li><li>循环直至栈为空</li></ol><p>[<img src="https://pic.rmb.bdstatic.com/bjh/14c6145bafead415b55caeba15bf1f92.png" alt="非递归后序遍历"></p><h3 id="35-之字形遍历二叉树"><a href="#35-之字形遍历二叉树" class="headerlink" title="35.之字形遍历二叉树"></a>35.之字形遍历二叉树</h3><p><strong>思路一：广度优先，两个双端队列（可以直接用LinkedList来实现），定义一个变量判断，该层是从左到右还是从右到左遍历，在队列中插入null结点来分隔每层的遍历情况。</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/63c23493e755faca7ccc2f27d9f522ed.png" alt="之字形遍历二叉树"></p><h2 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h2><h3 id="36-求组合数"><a href="#36-求组合数" class="headerlink" title="36.求组合数"></a>36.求组合数</h3><p>思路一：递归回溯，通过判断path中元素是否足够来结束递归</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/396424e90da19390359ce46e6709314e.png" alt="求组合数"></p><p>思路二：递归，search（n,k）可以分为选择第n个元素即search(n-1,k-1)，和不选择第n个元素即search(n-1,k)两种路径方式，当k=0或者n==k时表示递归走到了终点，结束递归</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/e61d4b34c05e0bcb3a4cd10f2e3f7394.png" alt="求组合数2"></p><p>37.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;h3 id=&quot;1-二分查找&quot;&gt;&lt;a href=&quot;#1-二分查找&quot; class=&quot;headerlink&quot; title=&quot;1.二分查找&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Summary" scheme="http://www.kongkongbai.com/categories/Algorithm/Summary/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>排序算法整理</title>
    <link href="http://www.kongkongbai.com/Algorithm/Summary/sortAlgorithm/"/>
    <id>http://www.kongkongbai.com/Algorithm/Summary/sortAlgorithm/</id>
    <published>2020-05-13T07:36:37.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/ll409546297/p/10956960.html" target="_blank" rel="noopener">参考博客</a>（非常详细）</p><p><a href="https://blog.csdn.net/IBLiplus/article/details/81056945" target="_blank" rel="noopener">快速排序参考博客</a></p><p><a href="https://blog.csdn.net/qq_36442947/article/details/81612870" target="_blank" rel="noopener">归并排序参考博客</a></p><p><a href="https://blog.csdn.net/TangXiaoPang/article/details/87896297" target="_blank" rel="noopener">堆排序参考博客</a></p><h3 id="排序算法的比较"><a href="#排序算法的比较" class="headerlink" title="排序算法的比较"></a>排序算法的比较</h3><p>[<img src="https://pic.rmb.bdstatic.com/bjh/4b7db2324210849024eb9192f4de6fa6.png" alt="排序算法的比较"></p><ul><li>冒泡排序：相邻两个数比较，将最大数移动到最后</li><li>选择排序：用需要排序序列的第一个数与其他数进行比较，找到每次循环的最小数与第一个数交换</li><li>插入排序：默认前面是已排序好的序列，通过比较将下一个数插入到合适位置</li><li>希尔排序：原理和插入排序一致，只是每次间隔步长不一样</li><li>归并排序：将序列分成两个子序列，然后子序列继续分化，直到每个子序列都为1，之后按序合并子序列</li><li>快速排序：选取一个数partion（一般第一个数），定义left和right指针，通过指针移动，直至指针相遇，将数组分为大于partion的序列和小于partion的序列；再对两部分进行递归，直到排序完成。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ll409546297/p/10956960.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考博客&lt;/a&gt;（非常详细）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Summary" scheme="http://www.kongkongbai.com/categories/Algorithm/Summary/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JMM内存模型</title>
    <link href="http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM02/"/>
    <id>http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM02/</id>
    <published>2020-05-13T05:53:50.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a><a href="https://zhuanlan.zhihu.com/p/38348646" target="_blank" rel="noopener">参考博客</a></h5><h3 id="1-内存简介"><a href="#1-内存简介" class="headerlink" title="1.内存简介"></a>1.内存简介</h3><p>[<img src="https://pic.rmb.bdstatic.com/bjh/13297e07270c3f512206b4441cd8ca18.jpeg" alt="内存管理简介"></p><h4 id="1-1地址空间的划分"><a href="#1-1地址空间的划分" class="headerlink" title="1.1地址空间的划分"></a>1.1地址空间的划分</h4><ul><li>内核空间：是主要的操作系统空间和C运行时的空间</li><li>用户空间：Java实际运行时的空间</li></ul><h3 id="2-JVM内存结构"><a href="#2-JVM内存结构" class="headerlink" title="2.JVM内存结构"></a>2.JVM内存结构</h3><p>[<img src="https://pic.rmb.bdstatic.com/bjh/0a5ec30149244284bfad8dc1a1539308.png" alt="JVM内存模型"></p><h4 id="2-1线程私有"><a href="#2-1线程私有" class="headerlink" title="2.1线程私有"></a>2.1线程私有</h4><p>程序计数器、虚拟机栈、本地方法栈</p><h5 id="2-1-1程序计数器"><a href="#2-1-1程序计数器" class="headerlink" title="2.1.1程序计数器"></a>2.1.1程序计数器</h5><ul><li>当前线程所执行的字节码行号指示器（逻辑）</li><li>改变计数器的值来选取<strong>下一条</strong>需要执行的<strong>字节码指令</strong></li><li>和线程是一对一的关系即“<strong>线程私有</strong>”</li><li>对Java方法计数，如果是Native方法则计数器值为Undefined</li><li>不会发生内存泄漏</li></ul><h5 id="2-1-2虚拟机栈"><a href="#2-1-2虚拟机栈" class="headerlink" title="2.1.2虚拟机栈"></a>2.1.2虚拟机栈</h5><ul><li><strong>Java方法</strong>执行的内存模型</li><li>包含多个<strong>栈帧</strong></li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/6619bb90982e09ce9b228f0de026449e.jpeg" alt="JVM虚拟机栈"></p><ol><li>局部变量表：包含方法执行过程中的所有变量</li><li>操作数栈：入栈、出栈、复制、交换、产生消费变量</li><li>动态连接</li><li>返回地址</li></ol><p><strong>栈帧解析实例：</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/09235bc215f539dabe975b79bed99ecb.png" alt="JVM字节码例子"></p><ul><li>descriptor：指示返回值类型</li><li>flags：stack指示操作数栈的大小；locals指示局部变量总数；args_size指示传入参数个数</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/067d44de5843a674a3cd32cdb7ce295f.jpeg" alt="JVM栈帧解析"></p><ul><li>iconst_0：定义局部变量0压入操作数栈中</li><li>istore_2：将操作数栈中的数<strong>pop()</strong>，放入局部变量表中的<strong>第2个</strong>位置</li><li>iload_0：将局部变量表第0个参数<strong>push()</strong>到操作数栈中</li><li>iadd：将操作数栈中数进行加法运算后压入栈中</li></ul><p><strong>递归为什么会引发java.lang.StackOverflowError异常？</strong></p><ul><li>递归过深，栈帧数超出虚拟栈的深度</li></ul><h5 id="2-1-3本地方法栈"><a href="#2-1-3本地方法栈" class="headerlink" title="2.1.3本地方法栈"></a>2.1.3本地方法栈</h5><p>任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。然而当它调用的是本地方法时，<strong>虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法</strong>。</p><h4 id="2-2线程共享部分"><a href="#2-2线程共享部分" class="headerlink" title="2.2线程共享部分"></a>2.2线程共享部分</h4><p>MetaSpace、Java堆</p><h5 id="2-2-1MetaSpace"><a href="#2-2-1MetaSpace" class="headerlink" title="2.2.1MetaSpace"></a>2.2.1MetaSpace</h5><p><strong>元空间（MetaSpace）与永久代（PermGen）的区别</strong></p><ul><li>JDK8元空间替代了永久代</li><li>元空间和永久代都是用于<strong>存储类的信息</strong></li><li><strong>元空间使用本地内存，而永久代使用的是JVM的内存（主要区别）</strong></li></ul><p><strong>Meta Space相比PermGen的优势：</strong></p><ul><li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代会为GC带来不必要的复杂性</li><li>方便HotSpot与其他JVM如Jrockit的集成</li></ul><h5 id="2-2-2Java堆（Heap）"><a href="#2-2-2Java堆（Heap）" class="headerlink" title="2.2.2Java堆（Heap）"></a>2.2.2Java堆（Heap）</h5><ul><li><strong>对象实例</strong>的分配区域</li><li><strong>GC</strong>管理的主要区域</li></ul><h3 id="3-面试问题"><a href="#3-面试问题" class="headerlink" title="3.面试问题"></a>3.面试问题</h3><h4 id="3-1JVM三大性能调优参数-Xms-Xmx-Xss的含义"><a href="#3-1JVM三大性能调优参数-Xms-Xmx-Xss的含义" class="headerlink" title="3.1JVM三大性能调优参数 -Xms -Xmx -Xss的含义"></a>3.1JVM三大性能调优参数 -Xms -Xmx -Xss的含义</h4><ul><li>-Xss：规定每个线程<strong>虚拟机栈</strong>（堆栈）的大小</li><li>-Xms：堆的<strong>初始大小</strong></li><li>-Xmx：堆能够达到的最大值（一般Xms和Xmx设置为一样，因为当堆不够用时进行拓展会引起内存抖动，影响程序运行时的稳定性）</li></ul><h4 id="3-2Java内存模型中堆和栈的区别——内存分配策略"><a href="#3-2Java内存模型中堆和栈的区别——内存分配策略" class="headerlink" title="3.2Java内存模型中堆和栈的区别——内存分配策略"></a>3.2Java内存模型中堆和栈的区别——内存分配策略</h4><ul><li>静态存储：<strong>编译时确定</strong>每个数据目标在运行时的存储空间需求</li><li>栈式存储：数据区需求在编译时未知，运行时模块入口前确定</li><li>堆式存储：编译时或运行时模块入口都无法确定，<strong>动态分配</strong></li></ul><p><strong>联系：</strong></p><ul><li>引用对象、数组时，栈里定义变量保存堆中目标首地址</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/438afc12bc4fbb64fcb2f2950dc49dfc.jpeg" alt="JVM栈与堆的联系"></p><p><strong>区别：</strong></p><ul><li>栈内存自动释放，堆内存需要GC</li><li>空间大小：栈空间比堆小</li><li>碎片相关：栈产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高，但灵活程度不够</li></ul><h4 id="3-3不同JDK版本之间的intern-方法的区别——JDK6-vs-JDK6之后"><a href="#3-3不同JDK版本之间的intern-方法的区别——JDK6-vs-JDK6之后" class="headerlink" title="3.3不同JDK版本之间的intern()方法的区别——JDK6 vs JDK6之后"></a>3.3不同JDK版本之间的intern()方法的区别——JDK6 vs JDK6之后</h4><ul><li><strong>JDK6</strong>：当调用intern方法时，如果字符串常量池先去已创建出该字符串对象，则返回池中的该字符串引用。否则，将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用。（<strong>常量池受永久代的限制</strong>）</li><li>JDK6+：当调用intern方法时，如果字符串常量池先前已经创建出该字符串对象，则返回池中的该字符串的引用。否则，<strong>如果该字符串对象已经存在于Java堆中，则将堆中对此对象的引用添加到字符串常量池中，并且返回该引用</strong>；如果堆中不存在，则在池中创建该字符串并返回引用（<strong>常量池受元空间限制</strong>）</li></ul><p>例子：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/be73ab34fd6d6362b62894b3ee15a116.jpeg" alt="internDifference"></p><p><strong>JDK6结果：false  false</strong></p><p>JDK6:</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/b4115c436c194fd6dc118c0715f4baf7.jpeg" alt="JDK6的intern方法"></p><ul><li>String s = new String （“a”)：<strong>将“a”字符串对象存放在常量池中，并在堆中new String创建了一个String对象的引用</strong>，<strong>s指向堆中的引用</strong>；</li><li>s2 = “a”：由于常量池中存在“a”，直接<strong>返回常量池中的引用</strong></li><li>所以 s ！=s2</li></ul><p><strong>JDK6+结果：false  true</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/a261242b553dbd5f404ce1d1ef84181c.jpeg" alt="JDK6+的intern方法"></p><ul><li><p>s 与 s2判断与JDK6一致</p></li><li><p>String s3 = new String(“a”) + new String (“a”):在**堆中创建“aa”对象，s3是堆中“aa”的引用</p><p>**</p></li><li><p>String s4 = “aa”：<strong>由于Java堆存在“aa”字符串对象，先将该对象的引用添加到常量池中，然后返回常量池中的引用，此时两个对象的引用指向同一个对象</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;参考博客&quot;&gt;&lt;a href=&quot;#参考博客&quot; class=&quot;headerlink&quot; title=&quot;参考博客&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38348646&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="Java基础知识" scheme="http://www.kongkongbai.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://www.kongkongbai.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载原理</title>
    <link href="http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM01/"/>
    <id>http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM01/</id>
    <published>2020-05-13T05:53:32.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-谈谈对Java的理解"><a href="#1-谈谈对Java的理解" class="headerlink" title="1.谈谈对Java的理解"></a>1.谈谈对Java的理解</h3><ul><li>平台无关性</li><li>GC</li><li>语言特性</li><li>面向对象</li><li>类库</li><li>异常处理</li></ul><h3 id="2-java如何实现平台无关性"><a href="#2-java如何实现平台无关性" class="headerlink" title="2.java如何实现平台无关性"></a>2.java如何实现平台无关性</h3><ul><li><strong>java的编译过程</strong></li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/4f9786d8230886631faf4c083dd52d55.png" alt="Java编译过程"></p><p>Java源码首先呗编译为字节码，再有不同平台的<strong>JVM进行解析</strong>，Java语言在不同的平台上运行时，不需要进行重新编译，Java虚拟机在执行字节码的时候，把<strong>字节码转换成具体平台上的机器指令</strong></p><ul><li><strong>Java字节码</strong></li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/ae2f19b9049a3ba5d7c7d67fb16ab1b2.png" alt="Java字节码"></p><ol><li>查看字节码：先编译（javac）、然后javap -c 查看字节码</li></ol><ul><li><strong>为什么JVM不直接将源码解析成机器码去执行</strong></li></ul><ol><li>如果直接转换成机器码，每次在解析源码的时候都要对源码进行编译检查（<strong>引入中间字节码，可以多次执行程序，而不需要校验</strong>）</li><li>兼容性：也可以将别的语言（比如Ruby）解析成字节码</li></ol><h3 id="3-JVM如何加载-class文件"><a href="#3-JVM如何加载-class文件" class="headerlink" title="3.JVM如何加载.class文件"></a>3.JVM如何加载.class文件</h3><h4 id="3-1JVM架构"><a href="#3-1JVM架构" class="headerlink" title="3.1JVM架构"></a>3.1JVM架构</h4><p>[<img src="https://pic.rmb.bdstatic.com/bjh/80b88a69f2fbf420805095eca1140b7f.png" alt="JVM结构"></p><ul><li>Class Loader：依据特定格式，<strong>加载class文件</strong>到内存</li><li>Execution Engine：对<strong>命令</strong>进行<strong>解析</strong></li><li>Native Interface：融合不同开发语言的原生库为Java所用</li><li>Runtime Data Area：JVM内存空间结构模型</li></ul><h3 id="4-反射"><a href="#4-反射" class="headerlink" title="4.反射"></a>4.反射</h3><p>定义：JAVA反射机制实在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种<strong>动态获取信息以及动态调用对象方法</strong>的功能称为java语言的反射机制</p><p>理解：反射就是将Java类中各个成分，映射成一个个的java对象</p><p><strong>写一个反射的例子：</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/90f82fe5362174d85d73cce23c75cd06.png" alt="反射的例子"></p><p><strong>常用方法：</strong></p><ul><li><strong>Class.forName(类的路径)</strong>：创建一个类对象</li><li>类对象.<strong>newInstance()</strong>：创建一个类的实例</li><li>Method  类实例.<strong>getDeclaredMethod（方法名，接受参数的Class对象）</strong>:能够获取类所有方法，不能获取继承和实现接口的方法</li><li>Method  类实例.<strong>getMethod</strong>（<strong>方法名，接受参数的Class对象</strong>）：只能获取public方法，可以获取继承和接口实现的方法</li><li><strong>setAccessible</strong>(true)：调用私有方法或者属性时，需要设置访问权限为true</li><li>方法对象.<strong>invoke</strong>（类实例，参数）：调用方法对象映射的类的方法</li><li>Field  类实例.<strong>getDeclaredField</strong>（参数名）：获取属性实例</li><li>Field对象.<strong>set</strong>（类实例，参数）：给Filed对象映射的属性设置值</li></ul><h3 id="5-ClassLoader"><a href="#5-ClassLoader" class="headerlink" title="5.ClassLoader"></a>5.ClassLoader</h3><h4 id="5-1类从编译到执行的过程"><a href="#5-1类从编译到执行的过程" class="headerlink" title="5.1类从编译到执行的过程"></a><strong>5.1类从编译到执行的过程</strong></h4><ul><li>编译器将Robot.java源文件编译为Robot.class字节码文件</li><li>ClassLoader将字节码转换为JVM中的Class<Robot>对象</li><li>JVM利用CLass<Robot>对象实例化为Robot对象</li></ul><h4 id="5-2ClassLoader的工作"><a href="#5-2ClassLoader的工作" class="headerlink" title="5.2ClassLoader的工作"></a>5.2ClassLoader的工作</h4><p>CLassLoader的主要工作再Class装载的加载阶段，其主要作用是从系统外部获得Class二进制数据流。它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，<strong>ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作</strong>。</p><h4 id="5-3ClassLoader的种类"><a href="#5-3ClassLoader的种类" class="headerlink" title="5.3ClassLoader的种类"></a>5.3ClassLoader的种类</h4><ul><li>BootStrapClassLoader：C++编写，加载核心库java.*（java.lib.dir）</li><li>ExtClassLoader：Java编写，加载拓展库javax.*（java.ext.dir）</li><li>AppClassLoader：Java编写，加载程序所在目录，加载用户类路径(CLASSPATH)下的类库</li><li>自定义ClassLoader：Java编写，定制化加载：</li></ul><p>关键函数：</p><p>1.<strong>findClass</strong>（String name）：用于寻找类文件，将类文件从二进制字节码转换为Class对象</p><p>2.<strong>defineClass</strong>（byte[]，int off，int len）：传入class文件的二进制字节码，返回类对象</p><p>3<strong>.loadClass</strong>（String name）：加载类文件，它会调用我们实现的findClass方法</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/bc6b9abb863af1cbe251946a06db3025.png" alt="自定义ClassLoader">)[<img src="https://pic.rmb.bdstatic.com/bjh/d4742eaee2bf3c931cf6a4e15e1191d2.png" alt="自定义ClassLoader02"></p><h4 id="5-4ClassLoader的双亲委派机制"><a href="#5-4ClassLoader的双亲委派机制" class="headerlink" title="5.4ClassLoader的双亲委派机制"></a>5.4ClassLoader的双亲委派机制</h4><p>[<img src="https://pic.rmb.bdstatic.com/bjh/b94a6f99c0feb05951ec6d40bfdf91be.png" alt="类加载器的双亲委派机制"></p><ul><li>第一遍自底而上（从自定义ClassLoader到BootstrpClassLoader）：检查各个加载器是否已经加载了该类</li><li>第二遍自上到底：从各个加载器目录中尝试加载该类</li></ul><p><strong>为什么要使用双亲委派机制去加载类？</strong></p><ul><li><strong>避免多份同样字节码的加载</strong>：如果该类之前已经被ClassLoader加载过，在检查时就不会由新的ClassLoader加载两次</li></ul><h4 id="5-5类的加载方式"><a href="#5-5类的加载方式" class="headerlink" title="5.5类的加载方式"></a>5.5类的加载方式</h4><ul><li>隐式加载：new</li><li>显式加载：loadClass、forName等（创建实例必须使用newInstance（），并且不支持传入参数，只能使用反射来设置参数的值）</li></ul><h4 id="5-7类的装载过程："><a href="#5-7类的装载过程：" class="headerlink" title="5.7类的装载过程："></a><strong>5.7类的装载过程：</strong></h4><ul><li><strong>加载</strong>：通过ClassLoader加载class文件字节码，生成Class对象</li><li><strong>链接</strong>：</li></ul><ol><li>校验：检查加载的class的正确性和安全性</li><li>准备：为类变量分配存储空间并设置类变量初始值</li><li>解析：JVM将常量池内的符号引用转换为直接引用</li></ol><ul><li><strong>初始化</strong>：执行类变量赋值和静态代码块</li></ul><h4 id="5-6loadClass和forName的区别"><a href="#5-6loadClass和forName的区别" class="headerlink" title="5.6loadClass和forName的区别"></a>5.6loadClass和forName的区别</h4><ul><li>Class.forName得到的class是已经<strong>完成初始化</strong>（第三步）的</li><li>ClassLoader.loadClass得到的class是还没链接的（<strong>还未完成第二步</strong>）</li></ul><p>ClassLoader的使用例子：在<strong>Spring IOC容器</strong>中，资源加载器读取bean的配置文件时，如果要使用<strong>classpath的方式加载</strong>，则需要ClassLoader。这与Spring IOC的lazyLoading（<strong>延迟加载</strong>）有关，Spring IOC<strong>为了加快初始化速度</strong>，大量使用延迟加载</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-谈谈对Java的理解&quot;&gt;&lt;a href=&quot;#1-谈谈对Java的理解&quot; class=&quot;headerlink&quot; title=&quot;1.谈谈对Java的理解&quot;&gt;&lt;/a&gt;1.谈谈对Java的理解&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;平台无关性&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Java基础知识" scheme="http://www.kongkongbai.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://www.kongkongbai.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JMM的可见性</title>
    <link href="http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM03/"/>
    <id>http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM03/</id>
    <published>2020-05-13T05:53:21.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-JMM简介"><a href="#1-JMM简介" class="headerlink" title="1.JMM简介"></a>1.JMM简介</h3><p>[<img src="https://pic.rmb.bdstatic.com/bjh/88652a11e96b574703cf35d6ccbd54e3.png" alt="JMM内存模型"></p><p>Java内存模型JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式</p><p><strong>理解：每个线程都有自己的工作内存，相互独立；线程之间的共享资源都是存储在主内存中，线程要想获取共享资源，只能获取其在主内存的副本，修改完后返回至主内存以达到通信的目的。</strong></p><h4 id="1-1JMM中的主内存"><a href="#1-1JMM中的主内存" class="headerlink" title="1.1JMM中的主内存"></a>1.1JMM中的主内存</h4><ul><li>存储Java<strong>实例对象</strong></li><li>包括<strong>成员变量、类信息、常量、静态变量</strong>等</li><li>属于<strong>数据共享的区域</strong>，多线程并发操作时会引发线程安全问题</li></ul><h4 id="1-2JMM中的工作内存"><a href="#1-2JMM中的工作内存" class="headerlink" title="1.2JMM中的工作内存"></a>1.2JMM中的工作内存</h4><ul><li>存储当前方法的所有本地变量信息，本地变量对其他线程不可见</li><li>字节码行号指示器、Native方法信息</li><li>属于线程<strong>私有数据区域</strong>，不存在线程安全问题</li></ul><h4 id="1-3JMM与Java内存区域的概念区别"><a href="#1-3JMM与Java内存区域的概念区别" class="headerlink" title="1.3JMM与Java内存区域的概念区别"></a>1.3JMM与Java内存区域的概念区别</h4><ul><li>内存区域是指 Jvm 运行时将数据分区域存储，<strong>强调对内存空间的划分</strong></li><li>内存模型（Java Memory Model，简称 JMM ）是定义了<strong>线程的工作内存和主内存之间的抽象关系</strong>，即 <strong>JMM 定义了 JVM 在计算机内存(RAM)中的工作方式</strong></li></ul><h4 id="1-4主内存与工作内存的数据存储类型以及操作方式归纳"><a href="#1-4主内存与工作内存的数据存储类型以及操作方式归纳" class="headerlink" title="1.4主内存与工作内存的数据存储类型以及操作方式归纳"></a>1.4主内存与工作内存的数据存储类型以及操作方式归纳</h4><ul><li>方法里的<strong>基本数据类型</strong>的本地变量将直接存储在工作内存的栈帧结构中</li><li><strong>引用类型</strong>的本地变量：引用存储在工作内存中，实例存储在主内存中</li><li><strong>成员变量、static变量、类信息</strong>均会被存储在主内存中</li><li>主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存</li></ul><h3 id="2-JMM如何解决可见性问题"><a href="#2-JMM如何解决可见性问题" class="headerlink" title="2.JMM如何解决可见性问题"></a>2.JMM如何解决可见性问题</h3><h4 id="2-1指令重排序"><a href="#2-1指令重排序" class="headerlink" title="2.1指令重排序"></a>2.1指令重排序</h4><p>JVM为了提高程序运行速度，一般都会对指令重排序</p><p><strong>条件：</strong></p><ul><li>在单线程环境下不能改变程序运行的结果</li><li>存在数据依赖关系的不允许重排序</li><li>无法通过<strong>happens-before原则</strong>推导出来的，才能进行指令重排序</li></ul><h4 id="2-2happens-before原则"><a href="#2-2happens-before原则" class="headerlink" title="2.2happens-before原则"></a>2.2happens-before原则</h4><p>A操作的结果需要对B操作可见，则A与B存在happens-before关系</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/fd3bef59c906055fc8146164b88fdc9e.jpeg" alt="happens-before八大原则"></p><p><strong>概念：</strong></p><ul><li>如果两个操作不满足上述任意一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序</li><li>如果操作A happens-before 操作B，那么操作A在内存上所做的操作对操作B都是可见的</li></ul><h4 id="2-3volatile：JVM提供的轻量级同步机制"><a href="#2-3volatile：JVM提供的轻量级同步机制" class="headerlink" title="2.3volatile：JVM提供的轻量级同步机制"></a>2.3volatile：JVM提供的轻量级同步机制</h4><ul><li>保证被volatile修饰的共享变量对所有线程总是可见</li><li>禁止指令重排序优化</li></ul><h5 id="2-3-1volatile的可见性理解："><a href="#2-3-1volatile的可见性理解：" class="headerlink" title="2.3.1volatile的可见性理解："></a><strong>2.3.1volatile的可见性理解：</strong></h5><p>[<img src="https://pic.rmb.bdstatic.com/bjh/51163ab7384797c7d1da63721184fbed.jpeg" alt="volatile的可见性01"></p><p>value++的操作不具备原子性（<strong>原子操作</strong>：是指<strong>不会被线程调度机制打断</strong>的操作）：如果在读取value值和返回新value值期间另一个线程获取了久的value就会导致线程安全问题</p><p>为了避免线程安全问题，需要使用sychronized进行同步限制，此时就没有必要使用volatile修饰</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/fabbf9b6b8675562647a822510ffe010.jpeg" alt="volatile的可见性02"></p><p>shutdown的操作具备原子性，使用volatile修饰比较合理</p><h5 id="2-3-2volatile变量的机制"><a href="#2-3-2volatile变量的机制" class="headerlink" title="2.3.2volatile变量的机制"></a>2.3.2volatile变量的机制</h5><ul><li>当写一个volatile变量时，JMM会把该线程对应的工作内存中共享变量值刷新到主内存中</li><li>当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效</li></ul><h5 id="2-3-3volatile如何进行重排优化？"><a href="#2-3-3volatile如何进行重排优化？" class="headerlink" title="2.3.3volatile如何进行重排优化？"></a>2.3.3volatile如何进行重排优化？</h5><ul><li><strong>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排优化</strong></li><li>强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本</li></ul><p><strong>内存屏障</strong>（Memory Barrier）</p><ol><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ol><h5 id="2-3-4单例的双重检测实现中的问题"><a href="#2-3-4单例的双重检测实现中的问题" class="headerlink" title="2.3.4单例的双重检测实现中的问题"></a>2.3.4单例的双重检测实现中的问题</h5><p>[<img src="https://pic.rmb.bdstatic.com/bjh/cb621d85d6104e69887c99e3a14ea28a.jpeg" alt="单例的双重检测实现01"></p><p>instance = new Singleton（）这一步中分为三个阶段，其中1、2阶段有可能会被重排优化而导致线程安全问题</p><p>解决：</p><p>private <strong>volatile</strong> static Singleton instance：给实例对象添加volatile字段，使之初始化过程不能被重排序</p><h5 id="2-3-5volatile与sychronized的区别"><a href="#2-3-5volatile与sychronized的区别" class="headerlink" title="2.3.5volatile与sychronized的区别"></a>2.3.5volatile与sychronized的区别</h5><ul><li>volatile本质是告诉JVM当前变量在寄存器（工作内存）中的值时不确定的，需要从主存中读取；sychronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止</li><li>volatile仅能使用在变量级别；sychronized则可以使用在变量、方法和类级别</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而sychronized则可以保证变量修改的可变性和原子性</li><li>volatile不会造成线程的阻塞；sychronized可能会造成线程的阻塞</li><li>volatile标记的变量不会被编译器优化；sychronized标记的变量可以被编译器优化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-JMM简介&quot;&gt;&lt;a href=&quot;#1-JMM简介&quot; class=&quot;headerlink&quot; title=&quot;1.JMM简介&quot;&gt;&lt;/a&gt;1.JMM简介&lt;/h3&gt;&lt;p&gt;[&lt;img src=&quot;https://pic.rmb.bdstatic.com/bjh/88652a
      
    
    </summary>
    
    
      <category term="Java基础知识" scheme="http://www.kongkongbai.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://www.kongkongbai.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JavaAnnotation/"/>
    <id>http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JavaAnnotation/</id>
    <published>2020-05-13T05:52:40.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><p><strong>提供一种为程序元素设置元数据的方法</strong></p><ul><li>元数据是添加到程序元素如 <strong>方法、字段、类和包</strong>上额外信息</li><li><strong>注解</strong>是一种<strong>分散式</strong>的元数据设置方式，<strong>XML</strong>是<strong>集中式</strong>的设置方式</li><li>注解不能直接干扰程序代码的运行</li></ul><h3 id="2-注解的功能"><a href="#2-注解的功能" class="headerlink" title="2.注解的功能"></a>2.注解的功能</h3><ul><li>作为<strong>特定的标记</strong>，用于告诉编译器一些信息</li><li><strong>编译时动态处理</strong>，如动态生成代码</li><li><strong>运行时动态处理</strong>，作为额外信息的载体，如获取注解信息</li></ul><h3 id="3-注解的分类"><a href="#3-注解的分类" class="headerlink" title="3.注解的分类"></a>3.注解的分类</h3><ul><li>标准注解：@Override、@Deprecated（表示元素使用有风险）、@SuppressWarnings（表示需要忽略某些warning）</li><li>元注解：@Retention、@Target、@Inherited、@Documented</li><li>自定义注解</li></ul><h4 id="3-1元注解"><a href="#3-1元注解" class="headerlink" title="3.1元注解"></a>3.1元注解</h4><p><strong>用于修饰注解的注解，通常用在注解的定义上</strong></p><ul><li>@Target：注解的作用目标</li><li>@Rentation：注解的生命周期</li><li>@Documented：注解是否应当被包含在JavaDoc文档中</li><li>@Inherited：是否允许子类继承该注解</li></ul><h5 id="3-1-1-Target"><a href="#3-1-1-Target" class="headerlink" title="3.1.1.@Target"></a>3.1.1.@Target</h5><p><strong>描述所修饰的注解的使用范围</strong></p><p>使用：</p><p><strong>ElementType</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/89af4f95075d5f8f37bab7d3502392b2.png" alt="@Target注解的作用范围"></p><ul><li>packages、types（类、接口、枚举、Annotation类型）</li><li>类型成员（方法、构造函数、成员变量、枚举值）</li><li>方法参数和本地变量（如循环变量、catch参数）</li></ul><h5 id="3-1-2-Retention"><a href="#3-1-2-Retention" class="headerlink" title="3.1.2@Retention"></a>3.1.2@Retention</h5><p><strong>标记注解被保留时间的长短（生命周期）</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/0569c6ee974b5509b0920efae6f40178.png" alt="@Retention的使用"></p><ul><li>SOURCE：只出现在源代码中，编译后的class文件中不出现</li><li>CLASS：可以出现在编译后的class文件中</li><li>RUNTIME：运行时也会保留，<strong>可以在运行时通过反射从注解中获取有效信息</strong></li></ul><h5 id="3-1-3其他元注解"><a href="#3-1-3其他元注解" class="headerlink" title="3.1.3其他元注解"></a>3.1.3其他元注解</h5><ul><li>@Documented：注解是否应当被包含在<strong>JavaDoc</strong>文档中</li><li>@Inherited：是否允许子类<strong>继承</strong>该注解</li></ul><h4 id="3-2自定义注解"><a href="#3-2自定义注解" class="headerlink" title="3.2自定义注解"></a>3.2自定义注解</h4><ul><li>自动继承java.lang.annotation.Annotation</li><li>使用<strong>public</strong> <strong>@interface</strong>标识修饰</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/aeb50553dd33e2211c5959e1d8269955.jpeg" alt="自定义注解的格式"></p><h5 id="3-2-1注解属性支持的类型"><a href="#3-2-1注解属性支持的类型" class="headerlink" title="3.2.1注解属性支持的类型"></a>3.2.1注解属性支持的类型</h5><ul><li>所有基本数据类型</li><li>String类型</li><li>Class类型</li><li>Enum类型</li><li>Annotation类型</li><li>以上这些类型的数组</li></ul><h5 id="3-2-2实例"><a href="#3-2-2实例" class="headerlink" title="3.2.2实例"></a>3.2.2实例</h5><p><strong>声明：</strong></p><ul><li>一种类似方法的定义方式，修饰符只能为<strong>default或者public</strong></li><li>如果有默认值，则<strong>使用default添加默认值</strong></li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/ca2a26282186aa21ce59a15b22732f79.png" alt="自定义注解的使用01">)<img src="https://pic.rmb.bdstatic.com/bjh/47dad0e275d116889c302e44137d65fd.png" alt="自定义注解的使用02"></p><p><strong>使用：</strong></p><ul><li>根据注解的使用范围@Target可以在合适位置使用注解，<strong>默认属性名可以不赋值，其余均需赋值</strong></li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/656e68642e5268e09ddf075d5a5f81c3.png" alt="自定义注解的使用05"></p><p><strong>获取注解：</strong></p><ul><li><strong>获取的注解生命周期必须为@Rentation：RUNTIME</strong></li><li>获取类的注解：通过反射获取类实例–&gt;调用getAnnotations（）方法获取所有的注解实例</li><li>获取成员变量/方法的注解：通过反射获取类实例–&gt;getFields获取方法实例–&gt;判断成员变量中isAnnotationParent（注解.class）是否存在该注解–&gt;调用getAnnotation（）获取注解</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/b7ad38902c67344cf825c1865e00faa6.png" alt="自定义注解的使用03"></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/5f8f2059ddc8d4d91199f30dc51fce44.png" alt="自定义注解的使用04"></p><h3 id="4-注解的底层实现"><a href="#4-注解的底层实现" class="headerlink" title="4.注解的底层实现"></a>4.注解的底层实现</h3><p><strong>JVM会为注解生成代理对象</strong></p><p>注解的工作原理：</p><ul><li>通过<strong>键值对的形式</strong>为注解属性赋值</li><li>编译器检查注解的使用范围，将注解信息写入元素属性表</li><li>运行时JVM将<strong>RUNTIME的所有注解属性取出最终存入map里</strong>（单个项目中生命周期为RUNTIME的注解）</li><li>创建AnnotationInvocationHandler实例并传入前面的map</li><li>JVM使用<strong>JDK动态代理</strong>为注解生成<strong>代理类</strong>，并初始化处理器</li><li>调用invoke方法，通过传入方法名返回注解对应的属性值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本介绍&quot;&gt;&lt;a href=&quot;#1-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.基本介绍&quot;&gt;&lt;/a&gt;1.基本介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;提供一种为程序元素设置元数据的方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元数据是添加
      
    
    </summary>
    
    
      <category term="Java基础知识" scheme="http://www.kongkongbai.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://www.kongkongbai.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JavaThreadPool/"/>
    <id>http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JavaThreadPool/</id>
    <published>2020-05-13T05:52:28.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-线程池Executors的创建"><a href="#1-线程池Executors的创建" class="headerlink" title="1.线程池Executors的创建"></a>1.线程池Executors的创建</h3><h4 id="1-1newFixedThreadPool（int-n）"><a href="#1-1newFixedThreadPool（int-n）" class="headerlink" title="1.1newFixedThreadPool（int n）"></a>1.1newFixedThreadPool（int n）</h4><p><strong>创建指定工作线程数量的线程池</strong>，如果池中线程数到达初始值n，则将任务提交给线程池，如果没有，则创建新的线程补上</p><h4 id="1-2newCachedThreadPool（）"><a href="#1-2newCachedThreadPool（）" class="headerlink" title="1.2newCachedThreadPool（）"></a>1.2newCachedThreadPool（）</h4><p><strong>处理大量短时间工作任务的线程池</strong></p><ul><li>试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程</li><li>如果<strong>线程闲置的时间超过阀值，则会终止并移出缓存</strong></li><li>系统长时间闲置时，不会消耗什么资源</li></ul><h4 id="1-3newSingleThreadExecutor（）"><a href="#1-3newSingleThreadExecutor（）" class="headerlink" title="1.3newSingleThreadExecutor（）"></a>1.3newSingleThreadExecutor（）</h4><p><strong>创建唯一的工作线程来执行任务</strong>，如果线程异常结束，会有另一个线程代替它（保证顺序执行任务，单线程执行）</p><h4 id="1-4newSingleThreadScheduledExecutor（）与newScheduleThreadPool（int-corePoolSize）"><a href="#1-4newSingleThreadScheduledExecutor（）与newScheduleThreadPool（int-corePoolSize）" class="headerlink" title="1.4newSingleThreadScheduledExecutor（）与newScheduleThreadPool（int corePoolSize）"></a>1.4newSingleThreadScheduledExecutor（）与newScheduleThreadPool（int corePoolSize）</h4><p><strong>定时或者周期性的工作调度</strong>，两者区别在于单一工作线程还是多个线程</p><h4 id="1-5newWorkStealingPool（）"><a href="#1-5newWorkStealingPool（）" class="headerlink" title="1.5newWorkStealingPool（）"></a>1.5newWorkStealingPool（）</h4><p>内部会构建ForkJoinPool，利用working-stealing算法，并行地处理任务，不保证处理顺序</p><p><strong>Fork/Join框架：</strong></p><ul><li>把大任务分割成若干个小任务并行执行，最终汇总每个小任务结果后得到大任务结果框架</li></ul><h4 id="2-为什么使用线程池"><a href="#2-为什么使用线程池" class="headerlink" title="2.为什么使用线程池"></a>2.为什么使用线程池</h4><ul><li>降低资源消耗</li><li>提高线程的可管理性</li></ul><h3 id="3-Executor的框架"><a href="#3-Executor的框架" class="headerlink" title="3.Executor的框架"></a>3.Executor的框架</h3><p>[<img src="https://pic.rmb.bdstatic.com/bjh/e4f6ac53572bc0abc394775d57e42759.png" alt="Executor框架"></p><p><strong>三个Executor接口：</strong></p><ul><li><strong>Executor</strong>：运行新任务的简单接口，将任务提交和任务执行细节解耦</li></ul><p>Thread t = new Thread();t.start();</p><p><strong>Thread t = new Thread();executor.execute(t);</strong></p><ul><li><strong>ExecutorService</strong>：具备管理执行器和任务生命周期的方法，提交任务机制更加完善</li><li><strong>ScheduledExecutorService</strong>：支持Future和定期执行任务</li></ul><h3 id="4-ThreadPoolExecutor"><a href="#4-ThreadPoolExecutor" class="headerlink" title="4.ThreadPoolExecutor"></a>4.ThreadPoolExecutor</h3><p>[<img src="https://pic.rmb.bdstatic.com/bjh/95746467515b924a73a71a9d27081db0.jpeg" alt="ThreadPoolExecutor的工作流程"></p><p><strong>ThreadPoolExecutor的构造函数：</strong></p><ul><li>corePoolSize：核心线程数量</li><li>maximumPoolSize：线程不够用时能够创建的最大线程数</li><li>workQueue：任务等待队列</li><li>keepAliveTime：线程池空闲时维护的时间（核心线程外的线程）</li><li>threadFactory：创建新线程，Executors.defaultThreadFactory()</li><li>handler：线程池的饱和策略（如果阻塞队列满了，且没有空闲的线程时的策略）</li></ul><ol><li>AbortPolicy：直接抛出异常，这是<strong>默认的策略</strong></li><li>CallerRunsPolicy：用调用者所在的线程来执行任务</li><li>DiscardOldestPolicy：丢弃队列中靠最前的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务</li><li>实现RejectedExecutionHandler接口的自定义handler</li></ol><p><strong>新任务提交Executor执行后的判断：</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/436980d852a1eeb03fb94b27ee01aa98.png" alt="Executor执行后的判断流程"></p><ul><li>如果运行的线程少于corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的</li><li>如果线程池中的线程数量大于等于corePoolSize且小于maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务</li><li>如果设置的corePoolSize和maximumPoolSize相同，则创建的线程池的大小固定，这时如果有新任务提交，若workQueue未满则将请求放入workQueue中，等待有空闲线程去从workQueue中取任务并处理</li><li>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务</li></ul><h3 id="5-线程池的状态"><a href="#5-线程池的状态" class="headerlink" title="5.线程池的状态"></a>5.线程池的状态</h3><p>[<img src="https://pic.rmb.bdstatic.com/bjh/3ca0384881de22691fd03476d8000d99.jpeg" alt="线程池的状态转换"></p><ul><li>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务</li><li>SHUTDOWN：不再接受新提交的任务，但能处理存量的任务</li><li>STOP：不再接受新提交的任务，也不处理存量任务</li><li>TIDYING：所有任务都已终止，线程数为0</li><li>TERMINATED：terminated（）方法执行完后进入该状态</li></ul><h3 id="6-线程池的大小如何选定"><a href="#6-线程池的大小如何选定" class="headerlink" title="6.线程池的大小如何选定"></a>6.线程池的大小如何选定</h3><ul><li>CPU密集型：线程数 = 按照核数+1设定</li><li>I/O密集型：线程数 = CPU核数*（1+平均等待时间/平均工作时间）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-线程池Executors的创建&quot;&gt;&lt;a href=&quot;#1-线程池Executors的创建&quot; class=&quot;headerlink&quot; title=&quot;1.线程池Executors的创建&quot;&gt;&lt;/a&gt;1.线程池Executors的创建&lt;/h3&gt;&lt;h4 id=&quot;1-1ne
      
    
    </summary>
    
    
      <category term="Java基础知识" scheme="http://www.kongkongbai.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://www.kongkongbai.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java类库基础知识</title>
    <link href="http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JavaBaseLirary/"/>
    <id>http://www.kongkongbai.com/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JavaBaseLirary/</id>
    <published>2020-05-13T05:52:10.000Z</published>
    <updated>2020-05-15T14:07:48.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-String-StringBuffer与StringBuilder的区别"><a href="#1-String-StringBuffer与StringBuilder的区别" class="headerlink" title="1.String,StringBuffer与StringBuilder的区别"></a>1.String,StringBuffer与StringBuilder的区别</h3><h4 id="1-1String类的空间浪费问题"><a href="#1-1String类的空间浪费问题" class="headerlink" title="1.1String类的空间浪费问题"></a>1.1String类的空间浪费问题</h4><ul><li>String str = “hello”;</li><li>str = str + “world”</li></ul><p>这两句代码会在堆中创建三个字符串常量对象：“hello”、“world”、“helloworld”，极大的浪费内存空间</p><h4 id="1-2三者区别"><a href="#1-2三者区别" class="headerlink" title="1.2三者区别"></a>1.2三者区别</h4><ul><li>String类：不可变序列对象</li><li>StringBuffer：可变序列对象、效率低、但线程安全</li><li>StringBuilder：可变序列对象、效率高、但线程不安全</li></ul><p>StringBuffer通过给实现方法加<strong>sychronized锁来实现线程安全</strong></p><p><strong>使用场景：</strong></p><ul><li>如果要操作少量的数据用 String</li><li><strong>多线程</strong>操作字符串缓冲区下操作大量数据 StringBuffer；</li><li><strong>单线程</strong>操作字符串缓冲区下操作大量数据 StringBuilder。</li></ul><h3 id="2-Java异常体系"><a href="#2-Java异常体系" class="headerlink" title="2.Java异常体系"></a>2.Java异常体系</h3><p>[<img src="https://pic.rmb.bdstatic.com/bjh/821027c9550bf00548648ab1f854ec22.png" alt="Java异常体系"></p><h4 id="2-1Error和Exception的区别"><a href="#2-1Error和Exception的区别" class="headerlink" title="2.1Error和Exception的区别"></a>2.1Error和Exception的区别</h4><ul><li>Error：程序无法处理的系统错误，编译器不做检查</li><li>Exception：程序可以处理的异常，捕获后可能恢复</li><li>总结：Error是程序<strong>无法处理</strong>的错误，Exception是<strong>可以处理</strong>的异常</li></ul><p><strong>从责任的角度看：</strong></p><ul><li>Error属于JVM需要担负的责任</li><li>RuntimeException是程序应该负担的责任</li><li>Checked Exception可检查异常时Java编译器应该负担的责任（必须要追踪的异常）</li></ul><h4 id="2-2常见的Error以及Exception"><a href="#2-2常见的Error以及Exception" class="headerlink" title="2.2常见的Error以及Exception"></a>2.2常见的Error以及Exception</h4><p><strong>RuntimeException：</strong></p><ul><li>NullPointerException-空指针异常</li><li>ClassCastException-类型强制转换异常</li><li>IllegalArgumentException-传递非法参数异常</li><li>IndexOutOfBoundsException-下标越界异常</li><li>NumberFormatException-数字格式异常</li></ul><p>非RuntimeException：</p><ul><li>ClassNotFoundException-找不到指定class定义异常</li><li>IOException-IO操作异常</li></ul><p>Error：</p><ul><li>NoClassDefFoundError-找不到class定义异常</li><li>StackOverflowError-深递归导致栈耗尽而抛出的异常</li><li>OuntOfMemoryError-内存溢出异常</li></ul><h4 id="2-3Java的异常处理机制"><a href="#2-3Java的异常处理机制" class="headerlink" title="2.3Java的异常处理机制"></a>2.3Java的异常处理机制</h4><ul><li>抛出异常：创建异常对象，交由运行时系统处理</li><li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行</li></ul><p><strong>异常处理原则：</strong></p><ul><li>具体明确：抛出的异常应能通过异常类名和Message准确说明异常的类型和产生异常的原因</li><li>提早抛出：应尽可能早的发现并抛出异常，便于准确定位问题</li><li>延迟捕获：异常的捕获和处理应尽可能延迟，让掌握更多信息的作用域来处理异常</li></ul><h4 id="2-4高效主流的异常处理框架"><a href="#2-4高效主流的异常处理框架" class="headerlink" title="2.4高效主流的异常处理框架"></a>2.4高效主流的异常处理框架</h4><p>在用户看来，应用系统发生的所有异常都是应用系统内部产生的异常</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/d2417a9d76d6c6be651f044fc755ca11.jpeg" alt="异常处理框架"></p><ul><li>设计一个通用的继承自RuntimeException的异常来同一处理</li><li>其余异常都统一转译为上述异常AppException</li><li>在catch之后，抛出上述异常的子类，并提供足以定位的信息</li><li>由前端接受AppException做统一处理</li></ul><h4 id="2-5try-catch的性能"><a href="#2-5try-catch的性能" class="headerlink" title="2.5try-catch的性能"></a>2.5try-catch的性能</h4><p>Java异常处理消耗性能的地方：</p><ul><li>try-catch块影响JVM的优化</li><li>异常对象实例需要保护栈快照等信息，开销较大</li></ul><h3 id="3-Java集合框架"><a href="#3-Java集合框架" class="headerlink" title="3.Java集合框架"></a>3.Java集合框架</h3><p><a href="http://39.107.124.120/2020/03/13/java后端面试-java知识/" target="_blank" rel="noopener">结合文章参考</a></p><h4 id="3-1List和Set"><a href="#3-1List和Set" class="headerlink" title="3.1List和Set"></a>3.1List和Set</h4><p>[<img src="https://pic.rmb.bdstatic.com/bjh/4bbde0c7ecfecc721be12c7bbf4e6452.jpeg" alt="List和Set"></p><ul><li>ArrayList：线程不安全、效率高、由数组实现</li><li>LinkedList：线程不安全、效率高、由链表实现</li><li><strong>Vector：线程安全（by sychronized）、效率低</strong></li><li>HashSet：保证元素的唯一性，由hash算法实现，hashCode()、equals()</li><li>TreeSet：由二叉树实现，保证元素的排序（1.自然排序，让对象所属类去实现<strong>comparable接口</strong>，无参构造；2.比较器接口（优先）<strong>comparator</strong>，带参构造）</li></ul><h5 id="3-1-1-ArrayList和LinkList的区别"><a href="#3-1-1-ArrayList和LinkList的区别" class="headerlink" title="3.1.1.ArrayList和LinkList的区别"></a>3.1.1.ArrayList和LinkList的区别</h5><p><strong>数组查改方便，链表增删效率高</strong></p><ul><li>List操作：add（e），size（），get（i），remove（i），itr.remove()…</li><li>ArrayList操作复杂度：add -O(N) , <strong>size -O(1) , get -O(1)</strong>, remove-O(N), itr.remove -O(N)</li><li>LinkedList操作复杂度：<strong>add -O(1) , size -O(1）</strong>[可以依靠外部的辅助字段]，get -O(N) , remove – O(N), <strong>itr.remove -O(1)</strong></li></ul><p><strong>回答：List是一个接口，ArrayList和LinkedList是它的实现，ArrayList是由数组来实现，LinkedList是由链表来实现。</strong></p><h4 id="3-2-Map"><a href="#3-2-Map" class="headerlink" title="3.2 Map"></a>3.2 Map</h4><h4 id="3-2-1HashMap、HashTable、ConccurentHashMap区别"><a href="#3-2-1HashMap、HashTable、ConccurentHashMap区别" class="headerlink" title="3.2.1HashMap、HashTable、ConccurentHashMap区别"></a>3.2.1HashMap、HashTable、ConccurentHashMap区别</h4><p><strong>1.HashMap（<a href="https://www.cnblogs.com/yuanfy008/p/11073246.html" target="_blank" rel="noopener">参考博客</a>）</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/21e47175a597e8eb795ede00f0ad6a04.jpeg" alt="HashMap原理01"></p><ul><li>实现：数组+链表（+<strong>红黑树Java8及以后</strong>）</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/bf2b4c189991e0fa6b0c479f7de942b8.jpeg" alt="HashMap原理02"></p><ul><li>分析：如果一个桶中的链表存储了过多元素，会导致HashMap性能降低，<strong>Java8以后定义了一个TREEIFY_THRESHOLD（默认为8，超过8会被改造，如果又低于6则会转回链表）常量来判断是否将链表转换为红黑树结构</strong></li></ul><p><strong>HashMap的延迟创建：</strong></p><ul><li>第一次进行put方法时，HashMap会判断table（桶）是否为空，<strong>如果为空则调用resize()进行初始化</strong></li></ul><p><strong>HashMap：put方法的逻辑</strong></p><ol><li>若HashMap未被初始化，则进行初始化操作（延迟创建）</li><li>对Key求Hash值，依据Hash值计算下标</li><li>若未发生碰撞，则直接放入桶中</li><li>若发生碰撞，则以链表的方式链接到后面</li><li><strong>若链表长度超过阀值，且HashMap桶数超过最低树化容量（默认64），则转化成红黑树；否则直接扩容</strong></li><li>若<strong>元素个数超过阀值</strong>（<strong>默认16*扩容因子0.75</strong>），<strong>如果超过则使用resize()扩容桶数两倍</strong></li><li>若节点已经存在，则用新值替换旧值</li></ol><p><strong>HashMap：从获取hash到散列的过程：</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/8fd715e49e4e8e90f4bf92836fda1397.jpeg" alt="HashMap原理03"></p><ul><li>n-1作为最后的获取桶值的参数，<strong>设置table容量时都是2的倍数</strong></li></ul><p><strong>HashMap：如何有效减少碰撞？</strong></p><ul><li><strong>扰动函数：</strong>促使元素位置分布均匀，减少碰撞几率</li><li>使用final对象（不可变性），并采用合适的equals()和hashCode()方法</li></ul><p><strong>HashMap：扩容的问题</strong></p><ul><li><strong>什么时候进行扩容？当hashmap中的元素个数超过数组大小*loadFactor扩容因子时</strong></li><li>多线程环境下，调整大小会存在条件竞争，<strong>容易造成死锁</strong></li><li>rehashing重新定位是一个比较<strong>耗时</strong>的过程</li></ul><p><strong>HashMap的线程安全问题解决</strong></p><ul><li>Map safeHashMap = <strong>Collections.sychronizedMap（hashMap）</strong>对hashMap进行安全改造</li><li>原理：在原来HashMap的基础上加上<strong>mutex对象</strong>，对此对象进行<strong>sychronized同步加锁</strong>来对其他方法进行控制</li></ul><p><strong>为什么HashMap允许null键，而HashTable、ConcurrentHashMap不允许</strong></p><ul><li><strong>Hashtable存入的value为null时，抛出NullPointerException异常。如果value不为null，而key为空，在执行到int hash = key.hashCode()时同样会抛出NullPointerException异常</strong></li><li>HashMap在put的时候会调用hash()方法来<strong>计算key的hashcode值</strong>，可以从hash算法中看出<strong>当key==null时返回的值为0</strong>。因此key为null时，hash算法返回值为0，不会调用key的hashcode方法</li><li>因为hashtable,concurrenthashmap它们是用于多线程的，并发的 ，如果map.get(key)得到了null，不能判断到底是映射的value是null,还是因为没有找到对应的key而为空，而用于单线程状态的hashmap却可以用containKey（key） 去判断到底是否包含了这个null</li></ul><p><strong>2.Hashtable和ConcurrentHashMap</strong></p><ul><li>Hashtable是<strong>遗留产物</strong>（从Java1），如今基本不使用</li><li>Hashtable<strong>不允许null</strong>，HashMap可以放null</li><li>Hashtable是<strong>线程安全</strong>，因为所有危险函数都加了synchronized</li></ul><p><strong>如何对Hashtable优化？ –&gt;ConccurentHashMap（不允许插入null键）</strong></p><ul><li>早期：通过锁细粒度化，<strong>将整锁拆解成多个锁进行优化</strong></li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/0c1ee941c8898c4b7ce512bdde87d9b2.jpeg" alt="ConcurrentHashMap早期原理"></p><p>理解：将桶数组分为多个段，每个段使用一个锁（<strong>segment分段锁</strong>），在并发处理不同段的数据时，线程之间互不影响</p><ul><li>Java8及之后：<strong>CAS+sychronized</strong>使锁更细化</li></ul><p>**ConcurrentHashMap的put方法逻辑：</p><p>**</p><ol><li>判断Node[ ] 数组是否初始化，没有则进行初始化</li><li>通过hash定位数组的索引坐标，是否有Node节点，如果没有则使用<strong>CAS进行添加</strong>（链表的头节点），添加失败则进行下一次循环</li><li>检查到内部正在扩容，则调用helptransfer（）帮助它一起扩容</li><li>如果头节点f!=null，则<strong>使用sychronized锁住f元素</strong>，然后进行添加操作</li><li>判断链表长度已经达到临界值（默认为8），则将链表转换为红黑树结构</li></ol><p><strong>ConcurrentHashMap总结：</strong></p><ul><li>首先<strong>使用无锁操作CAS插入头节点</strong>，失败则循环重试</li><li>若头节点存在，尝试<strong>获取头节点的同步锁</strong>，在进行操作</li></ul><h4 id="三者区别总结："><a href="#三者区别总结：" class="headerlink" title="三者区别总结："></a>三者区别总结：</h4><ol><li><strong>HashMap线程不安全，数组+链表+红黑树</strong></li><li><strong>Hashtable线程安全，锁住整个对象，数组+链表</strong></li><li><strong>ConcurrentHashMap线程安全，CAS+同步锁，数组+链表+红黑树</strong></li><li><strong>HashMap的key、value均可为null，而其他的两个类都不支持</strong></li></ol><h3 id="4-J-U-C知识点梳理"><a href="#4-J-U-C知识点梳理" class="headerlink" title="4.J.U.C知识点梳理"></a>4.J.U.C知识点梳理</h3><p><strong>java.util.current：提供并发编程的解决方案</strong></p><ul><li>CAS是java.util.concurrent.atomic包的基础</li><li>AQS是java.util.concurrent.locks包以及一些常用类比如Semophore，Reentrantlock等类的基础</li></ul><p><strong>J.U.C包的分类</strong></p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/048eee00c41d3591d0627d36ee4964ca.jpeg" alt="JUC包的分类"></p><ul><li>线程执行器executor</li><li>锁locks</li><li>原子变量类atomic</li><li>并发工具类tools</li><li>并发集合collections</li></ul><h4 id="4-1并发工具类"><a href="#4-1并发工具类" class="headerlink" title="4.1并发工具类"></a>4.1并发工具类</h4><h5 id="4-1-1闭锁CountDownLatch：让主线程等待一组事件发生后继续执行"><a href="#4-1-1闭锁CountDownLatch：让主线程等待一组事件发生后继续执行" class="headerlink" title="4.1.1闭锁CountDownLatch：让主线程等待一组事件发生后继续执行"></a>4.1.1闭锁CountDownLatch：让主线程等待一组事件发生后继续执行</h5><ul><li>事件指的的是CountDownLatch里的countDown()方法；每次countDonw()方法会使cnt参数减1</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/313ad5604b8716d8618aa9272bdbd20a.jpeg" alt="CountDownLatch01"></p><p>使用：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/e23025026885387e6911bd6ebab10eea.jpeg" alt="CountDownLatch02"></p><h5 id="4-1-2栅栏CyclicBarrier：阻塞当前线程等待其他线程"><a href="#4-1-2栅栏CyclicBarrier：阻塞当前线程等待其他线程" class="headerlink" title="4.1.2栅栏CyclicBarrier：阻塞当前线程等待其他线程"></a>4.1.2栅栏CyclicBarrier：阻塞当前线程等待其他线程</h5><ul><li>等待其他线程，且会阻塞当前线程，所有线程必须同时到达栅栏位置后，才能继续执行</li><li>所有线程到达栅栏处，可以触发执行另外一个预先设定的线程</li></ul><p>[<img src="https://pic.rmb.bdstatic.com/bjh/800fefdfa3fa60f5355fe3691775743f.jpeg" alt="CyclicBarrier01"></p><p><strong>与CountDownLatch的区别：一个阻塞当前线程，一个阻塞主线程</strong></p><p>使用：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/564288a05dd3598f8e02598f7addc7d7.png" alt="CyclicBarrier02"></p><h5 id="4-1-3信号量Semaphore：控制某个资源可被同时访问的线程个数"><a href="#4-1-3信号量Semaphore：控制某个资源可被同时访问的线程个数" class="headerlink" title="4.1.3信号量Semaphore：控制某个资源可被同时访问的线程个数"></a>4.1.3信号量Semaphore：控制某个资源可被同时访问的线程个数</h5><p>[<img src="https://pic.rmb.bdstatic.com/bjh/94fcc61ce85784cf0fb532dac8d38c46.png" alt="Semaphore的使用"></p><h5 id="4-1-4交换器Exchanger：两个线程到达同步点后，相互交换数据"><a href="#4-1-4交换器Exchanger：两个线程到达同步点后，相互交换数据" class="headerlink" title="4.1.4交换器Exchanger：两个线程到达同步点后，相互交换数据"></a>4.1.4交换器Exchanger：两个线程到达同步点后，相互交换数据</h5><p>[<img src="https://pic.rmb.bdstatic.com/bjh/2f1b0979bde776130649cf459128ef32.jpeg" alt="Exchanger"></p><p>使用：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/09c54c8fb9c8c00ddfbd157410337dd6.jpeg" alt="Exchanger的使用"></p><ul><li>当两个线程都到达同步点，即<strong>同时运行到exchange()方法</strong>时，两个线程交换数据然后继续运行</li></ul><h5 id="4-1-5阻塞队列BlockingQueue：提供可阻塞的入队和出队操作"><a href="#4-1-5阻塞队列BlockingQueue：提供可阻塞的入队和出队操作" class="headerlink" title="4.1.5阻塞队列BlockingQueue：提供可阻塞的入队和出队操作"></a>4.1.5阻塞队列BlockingQueue：提供可阻塞的入队和出队操作</h5><p>[<img src="https://pic.rmb.bdstatic.com/bjh/85f6536bafc605aeffc27451355a8b5b.jpeg" alt="BlockingQueue01"></p><ul><li>主要用于<strong>生产者-消费者模式</strong>，在多线程场景时生产者线程在队列尾部添加元素，而消费者线程则在队列头部消费元素，通过这种方式能够达到将任务的生成和消费进行隔离的目的</li></ul><p>实现方式：</p><p>[<img src="https://pic.rmb.bdstatic.com/bjh/68bb1c83cd8a1094606e477b162e9e5d.jpeg" alt="BlockingQueue02"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-String-StringBuffer与StringBuilder的区别&quot;&gt;&lt;a href=&quot;#1-String-StringBuffer与StringBuilder的区别&quot; class=&quot;headerlink&quot; title=&quot;1.String,StringB
      
    
    </summary>
    
    
      <category term="Java基础知识" scheme="http://www.kongkongbai.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://www.kongkongbai.com/tags/Java/"/>
    
  </entry>
  
</feed>
