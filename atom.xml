<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空空白的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kongkongbai.com/"/>
  <updated>2020-07-20T16:59:47.037Z</updated>
  <id>http://www.kongkongbai.com/</id>
  
  <author>
    <name>kongkongbai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>21.数组中的逆序对</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer21/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer21/</id>
    <published>2020-07-12T14:29:39.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p>示例 1:</p><p>输入: [7,5,6,4]<br>输出: 5</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：归并分治</p><p>我们知道归并排序是将一个数组分为不同的两个部分，分别对子数组进行排序，然后再将子数组归并为有序数组。</p><p>同样我们可以将这个思路引进，在归并过程中计算产生的逆序对</p><p><img src="https://pic.rmb.bdstatic.com/bjh/f9774e570479b5b3539e06c7680ace5e.png" alt="image-20200712223344729"></p><p><strong>总结来说，就是在归并排序基础上，在比较左右子数组指针时，当 左指针&gt;右指针 时，会产生有规律的逆序对，即此时左指针右边的数都会与这个右指针产生逆序对，所以我们只需要在这种情况下计算产生的逆序对即可。</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        copy[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">return</span> reversePairs(copy,<span class="number">0</span>,len-<span class="number">1</span>,temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> leftPairs = reversePairs(num,start,mid,temp);</span><br><span class="line">    <span class="keyword">int</span> rightPairs = reversePairs(num,mid+<span class="number">1</span>,end,temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num[mid]&lt;=num[mid+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> leftPairs+rightPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> crossPairs = mergeAndCount(num,start,mid,end,temp);</span><br><span class="line">    <span class="keyword">return</span> leftPairs+rightPairs+crossPairs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mergeAndCount</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> start,<span class="keyword">int</span> mid,<span class="keyword">int</span> end,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">        temp[i] = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p1 = start;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> key = start;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp[p1]&gt;temp[p2])&#123;</span><br><span class="line">            count+=mid-p1+<span class="number">1</span>;</span><br><span class="line">            num[key++] = temp[p2++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num[key++] = temp[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=mid) num[key++] = temp[p1++];</span><br><span class="line">    <span class="keyword">while</span>(p2&lt;=end) num[key++] = temp[p2++];</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>spring自研框架IoC03实现容器的依赖注入</title>
    <link href="http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC03/"/>
    <id>http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC03/</id>
    <published>2020-06-29T08:04:15.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-4-实现容器的依赖注入"><a href="#2-4-实现容器的依赖注入" class="headerlink" title="2.4.实现容器的依赖注入"></a>2.4.实现容器的依赖注入</h3><p><strong>Bean容器管理实例的作用域：singleton</strong></p><p><strong>目前容器存在的问题：容器管理的Bean实例不完备</strong>：</p><ul><li>实例里面某些必须的成员变量还没有被创建出来，比如某个Controller依赖某个Service成员，但是获取的Controller实例中的Service成员并没有被创建</li></ul><p><strong>实现思路（支持成员变量级别的注入）：</strong></p><ul><li>定义相关的注解标签</li><li>实现创建被注解标记的成员变量实例，并将其注入到成员变量里</li><li>依赖注入的使用</li></ul><h4 id="2-4-1-定义相关的注解标签"><a href="#2-4-1-定义相关的注解标签" class="headerlink" title="2.4.1 定义相关的注解标签"></a>2.4.1 定义相关的注解标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Autowired目前仅支持成员变量注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-实现创建被注解标记的成员变量实例，并将其注入到成员变量里"><a href="#2-4-2-实现创建被注解标记的成员变量实例，并将其注入到成员变量里" class="headerlink" title="2.4.2 实现创建被注解标记的成员变量实例，并将其注入到成员变量里"></a>2.4.2 实现创建被注解标记的成员变量实例，并将其注入到成员变量里</h4><p><strong>实现思路：</strong></p><ul><li>遍历获取所有的Class对象</li><li>遍历获取Class对象中所有成员变量</li><li>获取成员变量中被@Autowired标记的成员变量</li><li>获取这些成员变量的类型</li><li>先从容器中尝试能否获取该实例，如果不可以，那证明是其接口或者超类，则获取其接口的实现类</li><li>最后通过反射将创建的实例注入到成员变量中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行Ioc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIoc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ValidationUtil.isEmpty(beanContainer.getClasses()))&#123;</span><br><span class="line">        log.warn(<span class="string">"empty classset in BeanContainer"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.遍历Bean容器中所有的Class对象</span></span><br><span class="line">    <span class="keyword">for</span>(Class&lt;?&gt; clazz : beanContainer.getClasses())&#123;</span><br><span class="line">        <span class="comment">//2.遍历Class对象的所有成员变量</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">if</span> (ValidationUtil.isEmpty(fields))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">            <span class="comment">//3.找出被Autowired标记的成员变量</span></span><br><span class="line">            <span class="keyword">if</span>(field.isAnnotationPresent(Autowired<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                Autowired autowired = field.getAnnotation(Autowired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                String autowiredValue = autowired.value();</span><br><span class="line">                <span class="comment">//4.获取这些成员变量的类型</span></span><br><span class="line">                Class&lt;?&gt; fieldClass = field.getType();</span><br><span class="line">                <span class="comment">//5.获取这些成员变量的类型在容器里对应的实例</span></span><br><span class="line">                Object fieldValue = getFieldInstance(fieldClass, autowiredValue);</span><br><span class="line">                <span class="keyword">if</span>(fieldValue == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"unable to inject relevant type，target fieldClass is:"</span> + fieldClass.getName() + <span class="string">" autowiredValue is : "</span> + autowiredValue);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//6.通过反射将对应的成员变量实例注入到成员变量所在类的实例里</span></span><br><span class="line">                    Object targetBean =  beanContainer.getBean(clazz);</span><br><span class="line">                    ClassUtil.setField(field, targetBean, fieldValue, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>根据Class在beanContainer里获取其实例或者实现类</strong></li><li>如果成员变量接口对应多个实现类，用户需要指定是哪个实现类，<strong>所以还需要再Autowired注解中添加value属性</strong></li><li>同时需要将获取的属性值传入方法中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Autowired目前仅支持成员变量注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//默认值为空串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据class在beanContainer中获取其实例或者实现类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getFieldInstance</span><span class="params">(Class&lt;?&gt; fieldClass,String autowiredValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先看该成员变量的实例是否存在于该容器</span></span><br><span class="line">        Object fieldValue = beanContainer.getBean(fieldClass);</span><br><span class="line">        <span class="keyword">if</span>(fieldValue!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> fieldValue;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//获取接口的实现类</span></span><br><span class="line">            Class&lt;?&gt; implementedClass = getImplementClass(fieldClass,autowiredValue);</span><br><span class="line">            <span class="keyword">if</span>(implementedClass!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> beanContainer.getBean(implementedClass);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取接口的实现类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; getImplementClass(Class&lt;?&gt; fieldClass,String autowiredValue) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = beanContainer.getClassesBySuper(fieldClass);</span><br><span class="line">        <span class="keyword">if</span>(!ValidationUtil.isEmpty(classSet))&#123;</span><br><span class="line">            <span class="comment">//如果用户没有告诉我们是哪个实现类</span></span><br><span class="line">            <span class="keyword">if</span>(ValidationUtil.isEmpty(autowiredValue))&#123;</span><br><span class="line">                <span class="comment">//并且只有一个实现类</span></span><br><span class="line">                <span class="keyword">if</span>(classSet.size()==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> classSet.iterator().next();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果有多个实现类,我们不知道是哪个实现类，抛出异常</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"multiple implemented classes for"</span>+fieldClass.getName()+<span class="string">"please set @Autowired value to pick one"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果设置上了相关实现类值,找出与之对应的实现类即可</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(Class&lt;?&gt; clazz:classSet)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(autowiredValue.equals((clazz.getSimpleName())))&#123;</span><br><span class="line">                        <span class="keyword">return</span> clazz;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3-依赖注入的使用"><a href="#2-4-3-依赖注入的使用" class="headerlink" title="2.4.3 依赖注入的使用"></a>2.4.3 依赖注入的使用</h4><p> <strong>一个简单的UT</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInjectorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"依赖注入doIoc"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIocTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BeanContainer beanContainer = BeanContainer.getInstance();</span><br><span class="line">        beanContainer.loadBeans(<span class="string">"com.imooc"</span>);</span><br><span class="line">        Assertions.assertEquals(<span class="keyword">true</span>,beanContainer.isLoaded());</span><br><span class="line">        MainPageController mainPageController = (MainPageController)beanContainer.getBean(MainPageController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Assertions.assertEquals(<span class="keyword">true</span>,mainPageController <span class="keyword">instanceof</span> MainPageController);</span><br><span class="line">        Assertions.assertEquals(<span class="keyword">null</span>,mainPageController.getHeadLineShopCategoryCombineService());</span><br><span class="line">        <span class="keyword">new</span> DependencyInjector().doIoc();</span><br><span class="line">        Assertions.assertNotEquals(<span class="keyword">null</span>,mainPageController.getHeadLineShopCategoryCombineService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2-4-实现容器的依赖注入&quot;&gt;&lt;a href=&quot;#2-4-实现容器的依赖注入&quot; class=&quot;headerlink&quot; title=&quot;2.4.实现容器的依赖注入&quot;&gt;&lt;/a&gt;2.4.实现容器的依赖注入&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Bean容器管理实例的作用域：sin
      
    
    </summary>
    
    
      <category term="spring框架篇" scheme="http://www.kongkongbai.com/categories/spring%E6%A1%86%E6%9E%B6%E7%AF%87/"/>
    
    
      <category term="spring框架" scheme="http://www.kongkongbai.com/tags/spring%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>spring自研框架IoC02实现Bean容器</title>
    <link href="http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC02/"/>
    <id>http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC02/</id>
    <published>2020-06-29T08:03:57.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-3-实现容器"><a href="#2-3-实现容器" class="headerlink" title="2.3 实现容器"></a>2.3 实现容器</h3><h4 id="2-3-1-枚举单例容器"><a href="#2-3-1-枚举单例容器" class="headerlink" title="2.3.1 枚举单例容器"></a>2.3.1 枚举单例容器</h4><p>在框架中Bean容器需要保证唯一，适合采用<strong>单例模式</strong></p><p>但是一般的单例模式容易受到<strong>反射和序列化的攻击</strong>，采用<strong>枚举单例</strong>，能有效避免</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE) <span class="comment">//定义一个无参私有构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanContainer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取单例容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanContainer <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ContainerHolder.HOLDER.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> ContainerHolder&#123;</span><br><span class="line">        HOLDER;</span><br><span class="line">        <span class="keyword">private</span> BeanContainer instance;</span><br><span class="line">        ContainerHolder()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> BeanContainer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-实现容器"><a href="#2-3-2-实现容器" class="headerlink" title="2.3.2 实现容器"></a>2.3.2 实现容器</h4><ul><li>保存Class对象及其实例载体</li><li>容器的加载：定义并获取目标对象</li><li>容器的操作方式：对外提供操作</li></ul><h4 id="2-3-2-1-保存Class对象及其实例载体"><a href="#2-3-2-1-保存Class对象及其实例载体" class="headerlink" title="2.3.2.1 保存Class对象及其实例载体"></a>2.3.2.1 保存Class对象及其实例载体</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  存放所有被配置标记的目标对象的Map</span></span><br><span class="line"><span class="comment"> *  采用ConcurrentHashMap，因为它的并发性能较好</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;,Object&gt; beanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="2-3-2-2-容器的加载"><a href="#2-3-2-2-容器的加载" class="headerlink" title="2.3.2.2 容器的加载"></a>2.3.2.2 容器的加载</h4><p>1.定义loaded变量 private boolean loaded = false，加载前判断容器是否已经被加载</p><p>2.扫描包下的所有class文件：运用包装好的ClassUtil.extractPackageClass(packageName)</p><p>3.将获取的classSet进行遍历，判断是否被 <strong>加载bean的注解列表</strong> 所注释，有则利用反射创建实例放入map中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描并加载所有的Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadBeans</span><span class="params">(String packageName)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断bean容器是否被加载过</span></span><br><span class="line">    <span class="keyword">if</span>(isLoaded())&#123;</span><br><span class="line">        log.warn(<span class="string">"Bean Container is already loaded"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提取包下的所有class对象</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.extractPackageClass(packageName);</span><br><span class="line">    <span class="keyword">if</span>(classSet==<span class="keyword">null</span>||classSet.isEmpty())&#123;</span><br><span class="line">        log.warn(<span class="string">"extract nothing from package:"</span>+packageName);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历classSet</span></span><br><span class="line">    <span class="keyword">for</span>(Class&lt;?&gt; clazz:classSet)&#123;</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;? extends Annotation&gt; annotation:BEAN_ANNOTATION)&#123;</span><br><span class="line">            <span class="comment">//如果类上面标记了上面的注解</span></span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(annotation))&#123;</span><br><span class="line">                <span class="comment">//将目标本身作为key，目标类的实例作为值，放入beanMap中</span></span><br><span class="line">                beanMap.put(clazz,ClassUtil.newInstance(clazz,<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加载bean的注解列表：即容器需要扫描那些注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载bean的注解列表:即容器需要扫描那些注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? extends Annotation&gt;&gt; BEAN_ANNOTATION</span><br><span class="line">        = Arrays.asList(Component<span class="class">.<span class="keyword">class</span>, <span class="title">Controller</span>.<span class="title">class</span>, <span class="title">Service</span>.<span class="title">class</span>, <span class="title">Repository</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>简单的一个UT：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BeanContainer beanContainer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在UT开始之前会进行初始化</span></span><br><span class="line"><span class="meta">@BeforeAll</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    beanContainer = BeanContainer.getInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeansTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Assertions.assertEquals(<span class="keyword">false</span>,beanContainer.isLoaded());</span><br><span class="line">    beanContainer.loadBeans(<span class="string">"com.imooc"</span>);</span><br><span class="line">    Assertions.assertEquals(<span class="number">6</span>,beanContainer.size());</span><br><span class="line">    Assertions.assertEquals(<span class="keyword">true</span>,beanContainer.isLoaded());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-3-容器的操作方式"><a href="#2-3-2-3-容器的操作方式" class="headerlink" title="2.3.2.3 容器的操作方式"></a>2.3.2.3 容器的操作方式</h4><p><strong>涉及容器的CRUD</strong>：</p><ul><li>增加、删除操作</li><li>根据Class获取对应实例</li><li>获取所有的Class和实例</li><li>通过注解来获取被注解标注的Class</li><li>通过超类获取对应的子类Class</li><li>获取容器载体保存的Class的数量</li></ul><h5 id="1-增加、删除操作"><a href="#1-增加、删除操作" class="headerlink" title="1.增加、删除操作"></a>1.增加、删除操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz Class对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean  Class对象对应的Bean实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  原有的Bean实例，没有则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">addBean</span><span class="params">(Class&lt;?&gt; clazz,Object bean)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanMap.put(clazz, bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz 需要删除的Class键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除的Bean实例，没有则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">removeBean</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanMap.remove(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-根据Class获取对应实例"><a href="#2-根据Class获取对应实例" class="headerlink" title="2.根据Class获取对应实例"></a>2.根据Class获取对应实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据Class对象获取Bean实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz Class对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Class对象对应的Bean实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanMap.get(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-获取所有的Class和实例"><a href="#3-获取所有的Class和实例" class="headerlink" title="3.获取所有的Class和实例"></a>3.获取所有的Class和实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bean容器里的所有Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClasses()&#123;</span><br><span class="line">    <span class="keyword">return</span> beanMap.keySet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bean容器的所有实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">getBeans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(beanMap.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-通过注解来获取被注解标注的Class"><a href="#4-通过注解来获取被注解标注的Class" class="headerlink" title="4.通过注解来获取被注解标注的Class"></a>4.通过注解来获取被注解标注的Class</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过注解来获取被注解标记过的Class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotation 注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Class集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClassesByAnnotation(Class&lt;? extends Annotation&gt; annotation)&#123;</span><br><span class="line">    <span class="comment">//1.获取beanMap的所有class对象</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; keySet = getClasses();</span><br><span class="line">    <span class="keyword">if</span>(keySet==<span class="keyword">null</span>||keySet.isEmpty())&#123;</span><br><span class="line">        log.warn(<span class="string">"keySet is Empty!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.通过注解筛选被注解标记的Class对象，并添加到classSet里</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Class&lt;?&gt; clazz:keySet)&#123;</span><br><span class="line">        <span class="comment">//类是否有相关注解标记</span></span><br><span class="line">        <span class="keyword">if</span>(clazz.isAnnotationPresent(annotation))&#123;</span><br><span class="line">            classSet.add(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classSet.size()&gt;<span class="number">0</span>?classSet:<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-通过超类获取对应的子类Class"><a href="#5-通过超类获取对应的子类Class" class="headerlink" title="5.通过超类获取对应的子类Class"></a>5.通过超类获取对应的子类Class</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过接口或者父类获取实现类或者子类的Class集合，不包括其本身</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaceOrClass 接口Class或者弗雷Class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Class集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClassesBySuper(Class&lt;?&gt; interfaceOrClass )&#123;</span><br><span class="line">    <span class="comment">//1.获取beanMap的所有class对象</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; keySet = getClasses();</span><br><span class="line">    <span class="keyword">if</span>(keySet==<span class="keyword">null</span>||keySet.isEmpty())&#123;</span><br><span class="line">        log.warn(<span class="string">"keySet is Empty!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.判断keySet里的元素是否是传入的接口或者类的子类，是则添加到classSet里</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Class&lt;?&gt; clazz:keySet)&#123;</span><br><span class="line">        <span class="comment">//判断keySet里的元素是否是传入的接口或者类的子类，并排除等于自己本身</span></span><br><span class="line">        <span class="keyword">if</span>(interfaceOrClass.isAssignableFrom(clazz)&amp;&amp;!clazz.equals(interfaceOrClass))&#123;</span><br><span class="line">            classSet.add(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classSet.size()&gt;<span class="number">0</span>?classSet:<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充：class1.isAssignableFrom(class2)函数</strong></p><ul><li>如果class1表示的类或接口与class2表示的<strong>类或接口相同</strong>，返回true</li><li>如果class1表示class2的<strong>超类或者超接口或者实现类</strong>（隔代也可以），返回true</li></ul><h5 id="6-获取容器载体保存的Class的数量"><a href="#6-获取容器载体保存的Class的数量" class="headerlink" title="6.获取容器载体保存的Class的数量"></a>6.获取容器载体保存的Class的数量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Bean实例的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanMap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2-3-实现容器&quot;&gt;&lt;a href=&quot;#2-3-实现容器&quot; class=&quot;headerlink&quot; title=&quot;2.3 实现容器&quot;&gt;&lt;/a&gt;2.3 实现容器&lt;/h3&gt;&lt;h4 id=&quot;2-3-1-枚举单例容器&quot;&gt;&lt;a href=&quot;#2-3-1-枚举单例容器&quot; cla
      
    
    </summary>
    
    
      <category term="spring框架篇" scheme="http://www.kongkongbai.com/categories/spring%E6%A1%86%E6%9E%B6%E7%AF%87/"/>
    
    
      <category term="spring框架" scheme="http://www.kongkongbai.com/tags/spring%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>spring自研框架IoC01创建注解并提取标记对象</title>
    <link href="http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC01/"/>
    <id>http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC01/</id>
    <published>2020-06-29T08:03:15.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-总结嗷"><a href="#0-总结嗷" class="headerlink" title="0.总结嗷"></a>0.总结嗷</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/1bfbdfddb9ee63e5a80eb160f1f270cb.jpeg" alt="0001"></p><h3 id="1-先来了解下IoC"><a href="#1-先来了解下IoC" class="headerlink" title="1.先来了解下IoC"></a>1.先来了解下IoC</h3><h4 id="1-1控制反转"><a href="#1-1控制反转" class="headerlink" title="1.1控制反转"></a>1.1控制反转</h4><ul><li>依托一个类似工厂的IoC容器</li><li>将对象的创建、依赖关系的管理以及生命周期交由IoC容器管理</li><li>降低系统在实现上的复杂性和耦合度、易于拓展、满足开闭原则</li></ul><h4 id="1-2依赖注入—实现控制反转"><a href="#1-2依赖注入—实现控制反转" class="headerlink" title="1.2依赖注入—实现控制反转"></a>1.2依赖注入—实现控制反转</h4><ul><li><strong>把底层类作为参数传递给上层类</strong>，实现上层对下层的“控制”</li></ul><p>主流的依赖注入方式：</p><ol><li>By 构造函数</li><li>By setter方法</li><li>By 接口</li><li>By 注解</li></ol><h4 id="1-3为什么要依托IoC容器？"><a href="#1-3为什么要依托IoC容器？" class="headerlink" title="1.3为什么要依托IoC容器？"></a>1.3为什么要依托IoC容器？</h4><ul><li>避免在各处使用new来创建类，并且可以做到统一维护</li><li>创建实例的时候不需要知道具体的细节（通过读取配置文件，<u><em>用反射的机制来完成创建</em>？</u>）</li><li><strong>反射+工厂模式</strong>的合体，满足开闭原则</li></ul><h4 id="1-4框架具备的最基本功能"><a href="#1-4框架具备的最基本功能" class="headerlink" title="1.4框架具备的最基本功能"></a>1.4框架具备的最基本功能</h4><ul><li>解析配置：项目中采用注解</li><li>定位与注册对象</li><li>注入对象：在用户需要使用对象时，返回正确对象</li><li>提供通用的工具类</li></ul><h3 id="2-IoC容器的实现"><a href="#2-IoC容器的实现" class="headerlink" title="2.IoC容器的实现"></a>2.IoC容器的实现</h3><p><strong>基本步骤：</strong></p><ol><li>创建注解</li><li>提取标记对象</li><li>实现容器（项目中采用键值对）</li><li>依赖注入</li></ol><h4 id="2-1-创建注解"><a href="#2-1-创建注解" class="headerlink" title="2.1 创建注解"></a>2.1 创建注解</h4><table><thead><tr><th></th><th>作用</th><th>作用对象</th><th>生命周期</th><th></th></tr></thead><tbody><tr><td>Controller</td><td>标记Controller层</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime(因为要通过反射创建对象)</td><td></td></tr><tr><td>Service</td><td>标记Service层</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr><tr><td>Repository</td><td>用于标记Dao层中的实现类</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr><tr><td>Component</td><td>用于标记通用的需要容器管理的组件</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr></tbody></table><h4 id="2-2-提取标记对象"><a href="#2-2-提取标记对象" class="headerlink" title="2.2 提取标记对象"></a>2.2 提取标记对象</h4><p><strong>实现思路：</strong></p><ol><li>指定范围，获取范围内的所有类</li><li>遍历所有类，获取被注解标记的类并加载进容器中</li></ol><h5 id="2-2-1-获取范围内的所有类"><a href="#2-2-1-获取范围内的所有类" class="headerlink" title="2.2.1 获取范围内的所有类"></a>2.2.1 获取范围内的所有类</h5><p><strong>实现思路：</strong></p><ol><li>获取类的加载器 –&gt;目的：获取项目发布的实际路径</li><li>通过类的加载器获取到加载的资源信息</li><li>依据不同的资源类型，采用不同的方式获取资源的集合</li></ol><p><strong>extractPackageClass(String packageName)</strong>：通过输入的包名，返回包下所有类的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包下的类集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 类集合Set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; extractPackageClass(String packageName)&#123;</span><br><span class="line">    <span class="comment">//1.获取类的加载器--&gt;目的：获取项目发布的实际路径</span></span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    <span class="comment">//2.通过类的加载器获取到加载的资源信息</span></span><br><span class="line">    <span class="comment">//getResource()方法 接受‘/’来隔开的名称，所以需要先将packageName中‘.'替换为’/‘</span></span><br><span class="line">    <span class="comment">//getResource()返回包含该类资源的url</span></span><br><span class="line">    URL url = classLoader.getResource(packageName.replace(<span class="string">"."</span>,<span class="string">"/"</span>));</span><br><span class="line">    <span class="keyword">if</span>(url==<span class="keyword">null</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">"unable to get anything from package:"</span>+packageName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.依据不同的资源类型，采用不同的方式获取资源的集合</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//过滤出文件类型的资源:我们需要获取的是协议为file，即本地的资源</span></span><br><span class="line">    <span class="keyword">if</span>(url.getProtocol().equalsIgnoreCase(FILE_PROTOCOL))&#123;</span><br><span class="line">        classSet = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        <span class="comment">//首先通过获取的path路径获取路径的File对象</span></span><br><span class="line">        File packageDirectory = <span class="keyword">new</span> File(url.getPath());</span><br><span class="line">        extractClassFile(classSet,packageDirectory,packageName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getClassLoader()</strong>：通过获取当前线程的类加载器获取加载该类的类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取ClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当前线程的内容加载器即该类的类加载器</span></span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：通过getResource（）返回的是URL数据，我们需要对返回的URL过滤，选出protocol为file类型（本地文件类型），并获取其中的Path路径信息，在提取该包路径中所有的Class类型文件</p><p><img src="https://pic.rmb.bdstatic.com/bjh/c4f8f523aae6d3d793ce6e0305142094.jpeg" alt="image-20200603194722808"></p><p><strong>extractClassFile(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName)</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归获取目标package里面的所有class文件（包括子package里面的class文件）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> emptyClassSet 装载目标类的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileSource 文件或者目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractClassFile</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件：当检索的不是文件夹时</span></span><br><span class="line">    <span class="keyword">if</span>(!fileSource.isDirectory()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果是一个文件夹，通过调用listFiles()获取这个文件夹中的所有文件或文件夹</span></span><br><span class="line">    <span class="comment">//并通过文件过滤器，留下文件夹类型，其余文件类型如果为class文件则直接加载</span></span><br><span class="line">    File[] files = fileSource.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果是文件夹类型，则通过</span></span><br><span class="line">            <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//获取文件的绝对值路径</span></span><br><span class="line">                String absoluteFilePath = file.getAbsolutePath();</span><br><span class="line">                <span class="keyword">if</span>(absoluteFilePath.endsWith(<span class="string">".class"</span>))&#123;</span><br><span class="line">                    <span class="comment">//若是class文件，则直接加载</span></span><br><span class="line">                    addToClassSet(absoluteFilePath);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToClassSet</span><span class="params">(String absoluteFilePath)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1.从class文件的绝对值路径里提取出包含了package的类名</span></span><br><span class="line">            <span class="comment">//比如：F:/simpleframework/simpleframwork/targt/classes/com/imooc/entity/dto/MainPage</span></span><br><span class="line">            <span class="comment">//提取为类名：com.imooc.entity.dto.MainPage</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//首先将绝对值路径中的分割符替换为“.”</span></span><br><span class="line">            absoluteFilePath = absoluteFilePath.replace(File.separator,<span class="string">"."</span>);</span><br><span class="line">                <span class="comment">//首先截取由包名开始的字段</span></span><br><span class="line">            String className = absoluteFilePath.substring(absoluteFilePath.indexOf(packageName));</span><br><span class="line">                <span class="comment">//之后再将最后“.”结尾的文件后缀去掉</span></span><br><span class="line">            className = className.substring(<span class="number">0</span>,className.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">            <span class="comment">//2.通过反射机制获取对应的Class对象并放入classSet中</span></span><br><span class="line">            Class targetCLass = loadClass(className);</span><br><span class="line">            emptyClassSet.add(targetCLass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            extractClassFile(emptyClassSet,file,packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>loadClass(className)</strong>：通过反射机制获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        log.error(<span class="string">"load class error:"</span>,e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单的做一个UT："><a href="#简单的做一个UT：" class="headerlink" title="简单的做一个UT："></a>简单的做一个UT：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtilTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"提取目标类方法：extractPackageClass"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extractPackageClassTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.extractPackageClass(<span class="string">"com.imooc.entity"</span>);</span><br><span class="line">        System.out.println(classSet);</span><br><span class="line">        Assertions.assertEquals(<span class="number">4</span>,classSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-总结嗷&quot;&gt;&lt;a href=&quot;#0-总结嗷&quot; class=&quot;headerlink&quot; title=&quot;0.总结嗷&quot;&gt;&lt;/a&gt;0.总结嗷&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://pic.rmb.bdstatic.com/bjh/1bfbdfddb9ee63e
      
    
    </summary>
    
    
      <category term="spring框架篇" scheme="http://www.kongkongbai.com/categories/spring%E6%A1%86%E6%9E%B6%E7%AF%87/"/>
    
    
      <category term="spring框架" scheme="http://www.kongkongbai.com/tags/spring%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>20.把数组排成最小的数</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer20/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer20/</id>
    <published>2020-06-27T09:36:31.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p>示例 1:</p><p>输入: [10,2]<br>输出: “102”<br>示例 2:</p><p>输入: [3,30,34,5,9]<br>输出: “3033459”</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：将数组进行”特殊的排序“</p><p>两个字符串 x，y；若拼接起来（x+y）&gt;（y+x）则 x&gt;y;反之小于</p><p>那么把数组进行重新排序，然后再按序拼接即可</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        strs[i] = String.valueOf(nums[i]);</span><br><span class="line">    <span class="comment">//使用内置的函数进行排序</span></span><br><span class="line">    Arrays.sort(strs,<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1,String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (o1+o2).compareTo(o2+o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//还有lamaba写法：Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));</span></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String s : strs)</span><br><span class="line">        res.append(s);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理论证明：</strong></p><p>为什么这样排个序就可以了呢？简单证明一下。根据算法，如果a &lt; b，那么a排在b前面，否则b排在a前面。可利用反证法，假设排成的最小数字为xxxxxx，并且至少存在一对字符串满足这个关系：a &gt; b，但是在组成的数字中a排在b前面。根据a和b出现的位置，分三种情况考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1）xxxxab，用ba代替ab可以得到xxxxba，这个数字是小于xxxxab，与假设矛盾。因此排成的最小数字中，不存在上述假设的关系。</span><br><span class="line"></span><br><span class="line">（2）abxxxx，用ba代替ab可以得到baxxxx，这个数字是小于abxxxx，与假设矛盾。因此排成的最小数字中，不存在上述假设的关系。</span><br><span class="line"></span><br><span class="line">（3）axxxxb，这一步证明麻烦了一点。可以将中间部分看成一个整体ayb，则有ay &lt; ya，yb &lt; by成立。将ay和by表示成10进制数字形式，则有下述关系式，这里a，y，b的位数分别为n，m，k。</span><br><span class="line"></span><br><span class="line">  关系1： ay &lt; ya &#x3D;&gt; a * 10^m + y &lt; y * 10^n + a &#x3D;&gt; a * 10^m - a &lt; y * 10^n - y &#x3D;&gt; a( 10^m - 1)&#x2F;( 10^n - 1) &lt; y</span><br><span class="line"></span><br><span class="line">  关系2： yb &lt; by &#x3D;&gt; y * 10^k + b &lt; b * 10^m + y &#x3D;&gt; y * 10^k - y &lt; b * 10^m - b &#x3D;&gt; y &lt; b( 10^m -1)&#x2F;( 10^k -1) </span><br><span class="line"></span><br><span class="line">  关系3： a( 10^m - 1)&#x2F;( 10^n - 1) &lt; y &lt; b( 10^m -1)&#x2F;( 10^k -1)  &#x3D;&gt; a&#x2F;( 10^n - 1)&lt; b&#x2F;( 10^k -1) &#x3D;&gt; a*10^k - a &lt; b * 10^n - b &#x3D;&gt;a*10^k + b &lt; b * 10^n + a &#x3D;&gt; a &lt; b</span><br><span class="line"></span><br><span class="line"> 这与假设a &gt; b矛盾。因此排成的最小数字中，不存在上述假设的关系。</span><br><span class="line"></span><br><span class="line"> 综上所述，得出假设不成立，从而得出结论：对于排成的最小数字，不存在满足下述关系的一对字符串：a &gt; b，但是在组成的数字中a出现在b的前面。从而得出算法是正确的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>19.数字序列中某一位的数字</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer19/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer19/</id>
    <published>2020-06-27T08:54:42.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：题目本身并不难，就是找规律</p><p>1.我们需要确定n对应的是哪个数中的数字：我们需要找到阈值，比如位数为1的最大值为9，位数为2的最大值为99，对应第n位数的阈值，即一位数9对应9，二位数99对应9+90*2（位数），依次三位数999对应9+90 *2+900 *3….</p><p>2.我们用（n-序列阈值）/位数+最大值即为对应的数</p><p>3.我们（n-序列阈值）%位数 可以找到其对应数的第几位数为我们所求</p><p><strong>4.Long.toString(num).charAt((n - 1) % digit) - ‘0’</strong> 使用字符串的方式来获取第几位数很关键！</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; count) &#123; <span class="comment">// 1.</span></span><br><span class="line">        n -= count;</span><br><span class="line">        digit += <span class="number">1</span>;</span><br><span class="line">        start *= <span class="number">10</span>;</span><br><span class="line">        count = digit * start * <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> num = start+(n-<span class="number">1</span>)/digit;</span><br><span class="line">    <span class="keyword">return</span> Long.toString(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>18.1到n整数中1出现的次数</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer18/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer18/</id>
    <published>2020-06-27T08:04:41.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：分析每个位数中1出现的次数</p><p><img src="https://pic.rmb.bdstatic.com/bjh/2ef71217b898f3efb7e4d9495042b6e1.png" alt="image-20200627160605354"></p><p><strong>分析当前位中1出现的次数：</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/fb310e4ca9b5c4f289685201c3d0aed8.png" alt="image-20200627160648387"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/59e5cae58ebee43372e873700e1efffd.png" alt="image-20200627160706406"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/0e0a7ed724090ac12aa74f1f7df62ff4.png" alt="image-20200627160720755"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n/<span class="number">10</span>, cur = n%<span class="number">10</span>, low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(high!=<span class="number">0</span>||cur!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="number">0</span>)&#123;</span><br><span class="line">            res+=high*digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">            res+=high*digit+low+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res+=(high+<span class="number">1</span>)*digit;</span><br><span class="line">        &#125;</span><br><span class="line">        low += cur * digit;</span><br><span class="line">        cur = high % <span class="number">10</span>;</span><br><span class="line">        high /= <span class="number">10</span>;</span><br><span class="line">        digit *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。&lt;/p&gt;
&lt;p&gt;例如，输入12，1～12这些整数中包含1 
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>17.寻找中位数_纪念第一次独立做出Hard题</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer17/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer17/</id>
    <published>2020-06-08T03:23:03.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p><strong>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</strong><br><strong>double findMedian() - 返回目前所有元素的中位数。</strong><br>示例 1：</p><p>输入：<br><code>[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</code><br><code>[[],[1],[2],[],[3],[]]</code><br><code>输出：[null,null,null,1.50000,null,2.00000]</code><br>示例 2：</p><p>输入：<br><code>[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</code><br><code>[[],[2],[],[3],[]]</code><br><code>输出：[null,null,2.00000,null,2.50000]</code></p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：采用两个堆维护中间数</p><p>较小的前半段用大顶堆，维护前面数字的最大值；较大的后半段用小顶堆，维护后面数字的最小值</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; p1 ;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; p2 ;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//大顶堆</span></span><br><span class="line">        p1 = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2-o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//小顶堆</span></span><br><span class="line">        p2 = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//偶数个时进入一个数</span></span><br><span class="line">        <span class="keyword">if</span>(size%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                p1.offer(num);</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;p2.peek())&#123;</span><br><span class="line">                p1.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p1.offer(p2.poll());</span><br><span class="line">                p2.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//奇数个时进入一个数</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;p1.peek())&#123;</span><br><span class="line">                p2.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p2.offer(p1.poll());</span><br><span class="line">                p1.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(p1.peek()+p2.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)p1.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>16.字符串的排列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer15/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer15/</id>
    <published>2020-06-07T02:42:01.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：递归回溯，dfs</p><p>从第一个字符开始向下递归，保证每层中的字符都不相同</p><p>排列方案数量： 对于一个长度为 nn 的字符串（假设字符互不重复），其排列共有 n \times (n-1) \times (n-2) … \times 2 \times 1n×(n−1)×(n−2)…×2×1 种方案。</p><p><strong>排列方案的生成方法：</strong> 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 11 位字符（ nn 种情况）、再固定第 22 位字符（ n-1n−1 种情况）、… 、最后固定第 nn 位字符（ 11 种情况）。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/b2b90a527d7d8aeb1bc3981c3634c791.png" alt="Picture1.png"></p><p><strong>重复方案与剪枝：</strong> 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/668302f70a8e3d11936ab655f0738225.png" alt="Picture2.png"></p><p>每次递归时，创建一个HashSet来保存当前层次中 已递归过的字符，当遇到重复时直接跳过。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"><span class="keyword">char</span>[] c;</span><br><span class="line"><span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    c = s.toCharArray();</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==c.length-<span class="number">1</span>)&#123;</span><br><span class="line">        res.add(String.valueOf(c));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;c.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>;</span><br><span class="line">        set.add(c[i]);</span><br><span class="line">        swap(i,x);</span><br><span class="line">        dfs(x+<span class="number">1</span>);</span><br><span class="line">        swap(x,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = c[i];</span><br><span class="line">    c[i] = c[x];</span><br><span class="line">    c[x] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一个字符串，打印出该字符串中字符的所有排列。&lt;/p&gt;
&lt;p&gt;你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>15.二叉树的序列与反序列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer15/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer15/</id>
    <published>2020-06-05T03:06:51.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>示例: </p><p>你可以将以下二叉树：</p><pre><code>  1 / \2   3   / \  4   5</code></pre><p>序列化为 “[1,2,3,null,null,4,5]” or “[1,2,3,null,null,4,5,null,null,null,null]”</p><p>如何序列化可以自己进行设计</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：通过层次遍历进行序列化，反序列化时利用队列（也是层次遍历的思想）</p><p>需要注意，字符串的处理细节</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.append(<span class="string">"null,"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(temp.val);</span><br><span class="line">            res.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(temp.left);</span><br><span class="line">        queue.add(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">    res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">    res.append(<span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="string">"[]"</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//将[x,x,x,x]数据提取为字符串数组</span></span><br><span class="line">    String[] subData = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>).split(<span class="string">","</span>);</span><br><span class="line">    <span class="comment">//将字符转换为数字</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(subData[<span class="number">0</span>]));</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(!subData[index].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">            temp.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(subData[index]));</span><br><span class="line">            queue.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(!subData[index].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">            temp.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(subData[index]));</span><br><span class="line">            queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;请实现两个函数，分别用来序列化和反序列化二叉树。&lt;/p&gt;
&lt;p&gt;示例: &lt;/p&gt;
&lt;p&gt;你可以将以下二叉树：&lt;/p&gt;
&lt;pr
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>14.搜索二叉树和双向链表</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer14/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer14/</id>
    <published>2020-06-04T11:15:40.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/76591cecc79c0ca89776fd6f5b84e552.png" alt="img"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p> <img src="https://pic.rmb.bdstatic.com/bjh/632c68e4611d23601d1bd6b2836b1f93.png" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p><strong>思路一：中序遍历</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node head,tail;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    head.left = tail;</span><br><span class="line">    tail.right = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    <span class="keyword">if</span>(tail!=<span class="keyword">null</span>) tail.right = root;</span><br><span class="line">    <span class="keyword">else</span> head = root;</span><br><span class="line">    root.left = tail;</span><br><span class="line">    tail = root;</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&lt;/p
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>13.复杂链表的深拷贝</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer13/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer13/</id>
    <published>2020-06-04T07:25:38.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p><strong>思路一：HashMap</strong></p><p>第一步 遍历链表，复制各个结点，用next串接链表，在这个过程中使用HashMap&lt;oldNode,newNode&gt;将新旧节点一一对应</p><p>第二步 再遍历链表，将原链表的random对应关系，使用HashMap映射到新链表中</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//创建HashMap集合</span></span><br><span class="line">    Node cur=head;</span><br><span class="line">    <span class="comment">//复制结点值</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//存储put:&lt;key,value1&gt;</span></span><br><span class="line">        map.put(cur,<span class="keyword">new</span> Node(cur.val)); <span class="comment">//顺序遍历，存储老结点和新结点(先存储新创建的结点值)</span></span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制结点指向</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//得到get:&lt;key&gt;.value2,3</span></span><br><span class="line">        map.get(cur).next = map.get(cur.next); <span class="comment">//新结点next指向同旧结点的next指向</span></span><br><span class="line">        map.get(cur).random = map.get(cur.random); <span class="comment">//新结点random指向同旧结点的random指向</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回复制的链表</span></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://www.kongkongbai.com/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/singleton/"/>
    <id>http://www.kongkongbai.com/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/singleton/</id>
    <published>2020-06-03T13:02:54.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><h4 id="1-1定义与类型"><a href="#1-1定义与类型" class="headerlink" title="1.1定义与类型"></a>1.1定义与类型</h4><ul><li>定义：保证一个类仅有一个实例，并提供一个全局访问点</li><li>类型：创建型</li></ul><h4 id="1-2使用场景"><a href="#1-2使用场景" class="headerlink" title="1.2使用场景"></a>1.2使用场景</h4><ul><li>想确保任何情况下都绝对只有一个实例</li></ul><h4 id="1-3优点"><a href="#1-3优点" class="headerlink" title="1.3优点"></a>1.3优点</h4><ul><li>在内存中只有一个实例，减小了内存开销</li><li>可以避免对资源的多重占用</li><li>设置全局访问点，严格的控制访问</li></ul><h4 id="1-4缺点"><a href="#1-4缺点" class="headerlink" title="1.4缺点"></a>1.4缺点</h4><ul><li>没有接口，拓展困难</li></ul><h4 id="1-5重点问题"><a href="#1-5重点问题" class="headerlink" title="1.5重点问题"></a>1.5重点问题</h4><ul><li><strong>私有构造器</strong></li><li><strong>线程安全问题</strong></li><li><strong>延迟加载</strong></li><li><strong>序列化和反序列化安全问题</strong></li><li><strong>反射</strong></li></ul><h4 id="1-6设计模式的结合"><a href="#1-6设计模式的结合" class="headerlink" title="1.6设计模式的结合"></a>1.6设计模式的结合</h4><ul><li>单例模式和工厂模式</li><li>单例模式和享元模式</li></ul><h3 id="2-三种单例模式的实现"><a href="#2-三种单例模式的实现" class="headerlink" title="2.三种单例模式的实现"></a>2.三种单例模式的实现</h3><h4 id="2-1懒汉式—延迟加载"><a href="#2-1懒汉式—延迟加载" class="headerlink" title="2.1懒汉式—延迟加载"></a>2.1懒汉式—延迟加载</h4><p><a href="http://39.107.124.120/wp-content/uploads/2020/04/懒汉式单例模式01.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/59c3f5111f1eac97c359a378d470ae7a.png" alt="懒汉式单例模式01"></a></p><p><strong>线程安全问题：</strong></p><ul><li>当多个线程同时运行到lazySingleton = new LazySingleton（）时，会创建不同的对象</li></ul><h4 id="2-1-1改进"><a href="#2-1-1改进" class="headerlink" title="2.1.1改进"></a>2.1.1改进</h4><p><strong>1.对这个静态方法上同步锁（即对这个类对象加锁）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazySingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺陷：由于上了同步类锁，上锁范围比较大，影响性能</strong></p><p><strong>2.双重检查机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式的双重检测机制改进</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckingSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckingSingleton lazyDoubleCheckingSingleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckingSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckingSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyDoubleCheckingSingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckingSingleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazyDoubleCheckingSingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazyDoubleCheckingSingleton = <span class="keyword">new</span> LazyDoubleCheckingSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyDoubleCheckingSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解：第一重空值检测，保证必须时单例为空的情况才能进入；加同步类锁，保证在单例为空的情况下，同一时间只有一个线程能够进入创建实例的代码段；第二重空值检测，保证进入了第一重检测的线程中后面进入同步代码块的线程不会再重新创建实例。</p><p><strong>双重检测机制中存在问题—指令重排序</strong></p><p><a href="http://39.107.124.120/wp-content/uploads/2020/03/单例的双重检测实现01.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/cb621d85d6104e69887c99e3a14ea28a.jpeg" alt="单例的双重检测实现01"></a></p><p><strong>解决1：使用volatile修饰实例，禁止重排序</strong></p><h4 id="2-2-基于类初始化的延迟加载解决方案（静态内部类）"><a href="#2-2-基于类初始化的延迟加载解决方案（静态内部类）" class="headerlink" title="2.2.基于类初始化的延迟加载解决方案（静态内部类）"></a><strong>2.2.基于类初始化的延迟加载解决方案（静态内部类）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleton staticInnerClassSingleton = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.staticInnerClassSingleton ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://39.107.124.120/wp-content/uploads/2020/04/静态内部类实现单例原理.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/5cd78a5b2ab0425e23c534ea06e163e8.jpeg" alt="静态内部类实现单例原理"></a></p><p><strong>延迟加载</strong>原理：加载一个类时，<strong>其内部类不会同时被加载</strong>。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。</p><p><strong>线程安全</strong>原理：Class对象在被初始化时，会加上<strong>Class对象初始化锁。</strong></p><p><strong>什么时候Java的类会被立刻初始化？</strong></p><p>1）T是一个类，而且一个T类型的<strong>实例被创建。</strong></p><p>2）T是一个类，且T中声明的一个<strong>静态方法被调用</strong>。</p><p>3）T中声明的一个<strong>静态字段被赋值</strong>。</p><p>4）T中声明的一个<strong>静态字段被使用</strong>，而且这个字段<strong>不是一个常量字段</strong>。</p><p>5）T是一个顶级类（Top Level Class，见Java语言规范的§7.6），而且一个断言语句（assert关键字修饰的语句）嵌套在T内部被执行（不常见）</p><h4 id="2-3饿汉式-–类加载时完成实例化"><a href="#2-3饿汉式-–类加载时完成实例化" class="headerlink" title="2.3饿汉式 –类加载时完成实例化"></a>2.3饿汉式 –类加载时完成实例化</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/11370a710100ca2ce46d02d775510759.png" alt="饿汉式"></p><ul><li>没有延迟加载，在类被加载时，实例就已经被加载</li><li>优点：简单，没有线程安全问题</li><li>缺点：如果该单例没有被使用，会增加内存负担</li></ul><h3 id="3-单例模式的安全问题"><a href="#3-单例模式的安全问题" class="headerlink" title="3.单例模式的安全问题"></a>3.单例模式的安全问题</h3><h4 id="3-1序列化与反序列化问题"><a href="#3-1序列化与反序列化问题" class="headerlink" title="3.1序列化与反序列化问题"></a>3.1序列化与反序列化问题</h4><ul><li><h5 id="序列化与反序列化破坏单例模式"><a href="#序列化与反序列化破坏单例模式" class="headerlink" title="序列化与反序列化破坏单例模式"></a>序列化与反序列化破坏单例模式</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将instance对象序列化写入oos中</span></span><br><span class="line">HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singleton_file"</span>));</span><br><span class="line">oos.writeObject(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再将其反序列化生成对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"singleton_file"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">HungrySingleton newInstance = (HungrySingleton) ois.readObject();</span><br></pre></td></tr></table></figure><ul><li><h5 id="为什么这两个对象不相同？"><a href="#为什么这两个对象不相同？" class="headerlink" title="为什么这两个对象不相同？"></a>为什么这两个对象不相同？</h5></li></ul><p>1.反序列化创建对象时，先调用<strong>isInstantialble()</strong>是否能生成对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>如果对象为serializable/externalizable并且可以在运行时可序列化，则返回true，否则返回false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns true if represented class is serializable&#x2F;externalizable and can</span><br><span class="line"> * be instantiated by the serialization runtime--i.e., if it is</span><br><span class="line"> * externalizable and defines a public no-arg constructor, or if it is</span><br><span class="line"> * non-externalizable and its first non-serializable superclass defines an</span><br><span class="line"> * accessible no-arg constructor.  Otherwise, returns false.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean isInstantiable() &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    return (cons !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.由于单例类实现了serializable，则通过<strong>desc.newInstance()*</strong><u>反射</u><em>的方式创建实例，这也是为什么序列化与反序列化可以破坏单例模式（*</em>一个是正常单例对象，一个是反射创建的对象**）</p><p>3.之后会进行<strong>hasReadResolveMethod()</strong>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    desc.hasReadResolveMethod())</span><br></pre></td></tr></table></figure><p>当class对象为serializable or externalizable，且定义了<strong>readResolve</strong>方法时，返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns true if represented class is serializable or externalizable and</span><br><span class="line"> * defines a conformant readResolve method.  Otherwise, returns false.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean hasReadResolveMethod() &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    return (readResolveMethod !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如果单例对象包含了readResolve方法，则通过<strong>反射调用readResolve方法</strong>来生成对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object rep = desc.invokeReadResolve(obj);</span><br></pre></td></tr></table></figure><p><strong>这也提供了解决序列化和反序列化破坏单例的方法：</strong>在单例类中添加readResolve方法，返回单例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决序列化与反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2反射攻击及其解决方案"><a href="#3-2反射攻击及其解决方案" class="headerlink" title="3.2反射攻击及其解决方案"></a>3.2反射攻击及其解决方案</h4><h5 id="对于类加载时创建单例对象（饿汉式-和-静态内部类）：在静态构造器中禁止反射加载"><a href="#对于类加载时创建单例对象（饿汉式-和-静态内部类）：在静态构造器中禁止反射加载" class="headerlink" title="对于类加载时创建单例对象（饿汉式 和 静态内部类）：在静态构造器中禁止反射加载"></a>对于类加载时创建单例对象（饿汉式 和 静态内部类）：在静态构造器中禁止反射加载</h5><p>饿汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//解决反射破坏单例</span></span><br><span class="line">    <span class="keyword">if</span>(hungrySingleton!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//禁止反射创建单例对象</span></span><br><span class="line">    <span class="keyword">if</span>(InnerClass.staticInnerClassSingleton!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的"><a href="#对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的" class="headerlink" title="对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的"></a>对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先反射创建对象，在调用getInstance创建对象时，无法触发设置在构造器中的保护代码</span></span><br><span class="line">LazySingleton newinstance = (LazySingleton)constructor.newInstance();</span><br><span class="line">LazySingleton instance = LazySingleton.getInstance();</span><br></pre></td></tr></table></figure><h5 id="可以再加一层保护"><a href="#可以再加一层保护" class="headerlink" title="可以再加一层保护"></a>可以再加一层保护</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加flag参数来保证构造器只被调用一次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这也并不是完美的，还可以通过反射改变flag的值后，在通过反射创建对象</p><h3 id="4-枚举单例"><a href="#4-枚举单例" class="headerlink" title="4.枚举单例"></a>4.枚举单例</h3><p><strong><a href="https://blog.csdn.net/javazejian/article/details/71333103#%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">参考博客</a></strong></p><ul><li><strong>为什么推荐使用枚举单例？</strong></li></ul><p>因为枚举单例不受序列化以及反射的影响，同时枚举类的特性（在类加载时通过静态代码块实例化单例）也很符合单例模式的要求</p><ul><li><h5 id="枚举单例的创建"><a href="#枚举单例的创建" class="headerlink" title="枚举单例的创建"></a>枚举单例的创建</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式的枚举单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumStarvingSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumStarvingSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumStarvingSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ContainerHolder.HOLDER.instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> ContainerHolder&#123;</span><br><span class="line">        HOLDER;</span><br><span class="line">        <span class="keyword">private</span> EnumStarvingSingleton instance;</span><br><span class="line">        ContainerHolder()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> EnumStarvingSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h5 id="为什么枚举单例不受序列化的影响？"><a href="#为什么枚举单例不受序列化的影响？" class="headerlink" title="为什么枚举单例不受序列化的影响？"></a>为什么枚举单例不受序列化的影响？</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TC_ENUM:</span><br><span class="line">    <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br></pre></td></tr></table></figure><p><strong>readEnum方法：</strong>通过调用Enum.valueOf()方法来获取枚举类，<strong>而枚举类中每个枚举常量具有唯一的name，所以反序列化的枚举类是唯一的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name = readString(<span class="keyword">false</span>);<span class="comment">//获取枚举常量的名称</span></span><br><span class="line">Enum&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line"><span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);<span class="comment">//通过获取的名称获得枚举类</span></span><br></pre></td></tr></table></figure><ul><li><strong>为什么枚举单例不受反射的影响？</strong></li></ul><ol><li>如果按默认方式反射获取构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line"><span class="comment">//会提示没有此构造器</span></span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.NoSuchMethodException: com.creational.singleton.EnumInstance.&lt;init&gt;()</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举的构造方法，只能由编译器调用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果我们传入参数类型呢，会报非法参数的异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = EnumInstance<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">EnumInstance instance = (EnumInstance)constructor.newInstance(<span class="string">"hello"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span></span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">417</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>为什么呢？</li></ol><p>在newInstance方法中，会进行是否为枚举类的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本介绍&quot;&gt;&lt;a href=&quot;#1-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.基本介绍&quot;&gt;&lt;/a&gt;1.基本介绍&lt;/h3&gt;&lt;h4 id=&quot;1-1定义与类型&quot;&gt;&lt;a href=&quot;#1-1定义与类型&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.kongkongbai.com/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.kongkongbai.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>spring自研框架-一-创建注解并提取目标对象</title>
    <link href="http://www.kongkongbai.com/Spring/SimpleframeWork01/"/>
    <id>http://www.kongkongbai.com/Spring/SimpleframeWork01/</id>
    <published>2020-06-03T12:10:20.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-先来了解下IoC"><a href="#1-先来了解下IoC" class="headerlink" title="1.先来了解下IoC"></a>1.先来了解下IoC</h3><h4 id="1-1控制反转"><a href="#1-1控制反转" class="headerlink" title="1.1控制反转"></a>1.1控制反转</h4><ul><li>依托一个类似工厂的IoC容器</li><li>将对象的创建、依赖关系的管理以及生命周期交由IoC容器管理</li><li>降低系统在实现上的复杂性和耦合度、易于拓展、满足开闭原则</li></ul><h4 id="1-2依赖注入—实现控制反转"><a href="#1-2依赖注入—实现控制反转" class="headerlink" title="1.2依赖注入—实现控制反转"></a>1.2依赖注入—实现控制反转</h4><ul><li><strong>把底层类作为参数传递给上层类</strong>，实现上层对下层的“控制”</li></ul><p>主流的依赖注入方式：</p><ol><li>By 构造函数</li><li>By setter方法</li><li>By 接口</li><li>By 注解</li></ol><h4 id="1-3为什么要依托IoC容器？"><a href="#1-3为什么要依托IoC容器？" class="headerlink" title="1.3为什么要依托IoC容器？"></a>1.3为什么要依托IoC容器？</h4><ul><li>避免在各处使用new来创建类，并且可以做到统一维护</li><li>创建实例的时候不需要知道具体的细节（通过读取配置文件，<u><em>用反射的机制来完成创建</em>？</u>）</li><li><strong>反射+工厂模式</strong>的合体，满足开闭原则</li></ul><h4 id="1-4框架具备的最基本功能"><a href="#1-4框架具备的最基本功能" class="headerlink" title="1.4框架具备的最基本功能"></a>1.4框架具备的最基本功能</h4><ul><li>解析配置：项目中采用注解</li><li>定位与注册对象</li><li>注入对象：在用户需要使用对象时，返回正确对象</li><li>提供通用的工具类</li></ul><h3 id="2-IoC容器的实现"><a href="#2-IoC容器的实现" class="headerlink" title="2.IoC容器的实现"></a>2.IoC容器的实现</h3><p><strong>基本步骤：</strong></p><ol><li>创建注解</li><li>提取标记对象</li><li>实现容器（项目中采用键值对）</li><li>依赖注入</li></ol><h4 id="2-1-创建注解"><a href="#2-1-创建注解" class="headerlink" title="2.1 创建注解"></a>2.1 创建注解</h4><table><thead><tr><th></th><th>作用</th><th>作用对象</th><th>生命周期</th><th></th></tr></thead><tbody><tr><td>Controller</td><td>标记Controller层</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime(因为要通过反射创建对象)</td><td></td></tr><tr><td>Service</td><td>标记Service层</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr><tr><td>Repository</td><td>用于标记Dao层中的实现类</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr><tr><td>Component</td><td>用于标记通用的需要容器管理的组件</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr></tbody></table><h4 id="2-2-提取标记对象"><a href="#2-2-提取标记对象" class="headerlink" title="2.2 提取标记对象"></a>2.2 提取标记对象</h4><p><strong>实现思路：</strong></p><ol><li>指定范围，获取范围内的所有类</li><li>遍历所有类，获取被注解标记的类并加载进容器中</li></ol><h5 id="2-2-1-获取范围内的所有类"><a href="#2-2-1-获取范围内的所有类" class="headerlink" title="2.2.1 获取范围内的所有类"></a>2.2.1 获取范围内的所有类</h5><p><strong>实现思路：</strong></p><ol><li>获取类的加载器 –&gt;目的：获取项目发布的实际路径</li><li>通过类的加载器获取到加载的资源信息</li><li>依据不同的资源类型，采用不同的方式获取资源的集合</li></ol><p><strong>extractPackageClass(String packageName)</strong>：通过输入的包名，返回包下所有类的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包下的类集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 类集合Set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; extractPackageClass(String packageName)&#123;</span><br><span class="line">    <span class="comment">//1.获取类的加载器--&gt;目的：获取项目发布的实际路径</span></span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    <span class="comment">//2.通过类的加载器获取到加载的资源信息</span></span><br><span class="line">    <span class="comment">//getResource()方法 接受‘/’来隔开的名称，所以需要先将packageName中‘.'替换为’/‘</span></span><br><span class="line">    <span class="comment">//getResource()返回包含该类资源的url</span></span><br><span class="line">    URL url = classLoader.getResource(packageName.replace(<span class="string">"."</span>,<span class="string">"/"</span>));</span><br><span class="line">    <span class="keyword">if</span>(url==<span class="keyword">null</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">"unable to get anything from package:"</span>+packageName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.依据不同的资源类型，采用不同的方式获取资源的集合</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//过滤出文件类型的资源:我们需要获取的是协议为file，即本地的资源</span></span><br><span class="line">    <span class="keyword">if</span>(url.getProtocol().equalsIgnoreCase(FILE_PROTOCOL))&#123;</span><br><span class="line">        classSet = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        <span class="comment">//首先通过获取的path路径获取路径的File对象</span></span><br><span class="line">        File packageDirectory = <span class="keyword">new</span> File(url.getPath());</span><br><span class="line">        extractClassFile(classSet,packageDirectory,packageName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：通过getResource（）返回的是URL数据，我们需要对返回的URL过滤，选出protocol为file类型（本地文件类型），并获取其中的Path路径信息，在提取该包路径中所有的Class类型文件</p><p><img src="https://pic.rmb.bdstatic.com/bjh/c4f8f523aae6d3d793ce6e0305142094.jpeg" alt="image-20200603194722808"></p><p><strong>getClassLoader()</strong>：通过获取当前线程的类加载器获取加载该类的类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取ClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当前线程的内容加载器即该类的类加载器</span></span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>extractClassFile(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName)</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归获取目标package里面的所有class文件（包括子package里面的class文件）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> emptyClassSet 装载目标类的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileSource 文件或者目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractClassFile</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件：当检索的不是文件夹时</span></span><br><span class="line">    <span class="keyword">if</span>(!fileSource.isDirectory()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果是一个文件夹，通过调用listFiles()获取这个文件夹中的所有文件或文件夹</span></span><br><span class="line">    <span class="comment">//并通过文件过滤器，留下文件夹类型，其余文件类型如果为class文件则直接加载</span></span><br><span class="line">    File[] files = fileSource.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果是文件夹类型，则通过</span></span><br><span class="line">            <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//获取文件的绝对值路径</span></span><br><span class="line">                String absoluteFilePath = file.getAbsolutePath();</span><br><span class="line">                <span class="keyword">if</span>(absoluteFilePath.endsWith(<span class="string">".class"</span>))&#123;</span><br><span class="line">                    <span class="comment">//若是class文件，则直接加载</span></span><br><span class="line">                    addToClassSet(absoluteFilePath);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToClassSet</span><span class="params">(String absoluteFilePath)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1.从class文件的绝对值路径里提取出包含了package的类名</span></span><br><span class="line">            <span class="comment">//比如：F:/simpleframework/simpleframwork/targt/classes/com/imooc/entity/dto/MainPage</span></span><br><span class="line">            <span class="comment">//提取为类名：com.imooc.entity.dto.MainPage</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//首先将绝对值路径中的分割符替换为“.”</span></span><br><span class="line">            absoluteFilePath = absoluteFilePath.replace(File.separator,<span class="string">"."</span>);</span><br><span class="line">                <span class="comment">//首先截取由包名开始的字段</span></span><br><span class="line">            String className = absoluteFilePath.substring(absoluteFilePath.indexOf(packageName));</span><br><span class="line">                <span class="comment">//之后再将最后“.”结尾的文件后缀去掉</span></span><br><span class="line">            className = className.substring(<span class="number">0</span>,className.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">            <span class="comment">//2.通过反射机制获取对应的Class对象并放入classSet中</span></span><br><span class="line">            Class targetCLass = loadClass(className);</span><br><span class="line">            emptyClassSet.add(targetCLass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            extractClassFile(emptyClassSet,file,packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>loadClass(className)</strong>：通过反射机制获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        log.error(<span class="string">"load class error:"</span>,e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单的做一个UT："><a href="#简单的做一个UT：" class="headerlink" title="简单的做一个UT："></a>简单的做一个UT：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtilTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"提取目标类方法：extractPackageClass"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extractPackageClassTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.extractPackageClass(<span class="string">"com.imooc.entity"</span>);</span><br><span class="line">        System.out.println(classSet);</span><br><span class="line">        Assertions.assertEquals(<span class="number">4</span>,classSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-先来了解下IoC&quot;&gt;&lt;a href=&quot;#1-先来了解下IoC&quot; class=&quot;headerlink&quot; title=&quot;1.先来了解下IoC&quot;&gt;&lt;/a&gt;1.先来了解下IoC&lt;/h3&gt;&lt;h4 id=&quot;1-1控制反转&quot;&gt;&lt;a href=&quot;#1-1控制反转&quot; class
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://www.kongkongbai.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.kongkongbai.com/tags/Spring/"/>
    
      <category term="自研框架" scheme="http://www.kongkongbai.com/tags/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>12.二叉搜索树的后序遍历序列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer12/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer12/</id>
    <published>2020-06-03T03:07:00.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><pre><code>     5   / \  2   6 / \1   3</code></pre><p>示例 1：</p><p>输入: [1,6,3,2,5]<br>输出: false<br>示例 2：</p><p>输入: [1,3,2,6,5]<br>输出: true</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：递归分治"><a href="#思路一：递归分治" class="headerlink" title="思路一：递归分治"></a>思路一：递归分治</h5><p>所有的子树都满足，左子树&lt;根&lt;右子树</p><p>如何判断哪里为左子树，哪里为右子树？最后一个结点为根，从开始出发，小于根的为左子树，其余为右子树</p><p>如何判断这棵树满足 左子树&lt;根&lt;右子树？从开始序列出发，保证刚刚分出来的左子树序列全部小于根，右子树序列全部大于根</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recue(postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recue</span><span class="params">(<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> p = i;</span><br><span class="line">    <span class="comment">//找到右子树的开始序号</span></span><br><span class="line">    <span class="keyword">while</span>(postorder[p]&lt;postorder[j]) p++;</span><br><span class="line">    <span class="keyword">int</span> m = p;</span><br><span class="line">    <span class="comment">//找到右子树的末尾序号</span></span><br><span class="line">    <span class="keyword">while</span>(postorder[p]&gt;postorder[j]) p++;</span><br><span class="line">    <span class="keyword">return</span> p==j&amp;&amp;recue(postorder,i,m-<span class="number">1</span>)&amp;&amp;recue(postorder,m,j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：单调辅助栈，还没看懂，基本思路是将后序遍历翻转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单调栈使用，单调递增的单调栈</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 表示上一个根节点的元素，这里可以把postorder的最后一个元素root看成无穷大节点的左孩子</span></span><br><span class="line">    <span class="keyword">int</span> pervElem = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 逆向遍历，就是翻转的先序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">// 左子树元素必须要小于递增栈被peek访问的元素，否则就不是二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> (postorder[i] &gt; pervElem)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; postorder[i] &lt; stack.peek())&#123;</span><br><span class="line">            <span class="comment">// 数组元素小于单调栈的元素了，表示往左子树走了，记录下上个根节点</span></span><br><span class="line">            <span class="comment">// 找到这个左子树对应的根节点，之前右子树全部弹出，不再记录，因为不可能在往根节点的右子树走了</span></span><br><span class="line">            pervElem = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个新元素入栈</span></span><br><span class="line">        stack.push(postorder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>11.栈的弹出序列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer11/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer11/</id>
    <published>2020-06-01T08:09:18.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：利用辅助栈模拟出入栈"><a href="#思路一：利用辅助栈模拟出入栈" class="headerlink" title="思路一：利用辅助栈模拟出入栈"></a>思路一：利用辅助栈模拟出入栈</h5><p>考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</p><p><strong>入栈操作</strong>： 按照压栈序列的顺序执行。<br><strong>出栈操作</strong>： 每次入栈后，<strong>循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立</strong>，将符合弹出序列顺序的栈顶元素全部弹出。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushed.length;i++)&#123;</span><br><span class="line">        s.push(pushed[i]);</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty()&amp;&amp;popped[index]==s.peek())&#123;</span><br><span class="line">            index++;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.isEmpty()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>10.树的子结构</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer10/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer10/</id>
    <published>2020-05-25T13:37:13.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><pre><code> 3/ \4   5  / \ 1   2</code></pre><p>给定的树 B：</p><p>   4<br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：深度优先遍历（先序遍历）+递归判断</p><ul><li>先序遍历树A的每个节点An</li><li>判断树A中以<strong>An为根节点的子树是否以相同根节点包含树B</strong></li></ul><h5 id="如何判断A树是否以相同根节点包含树B呢？"><a href="#如何判断A树是否以相同根节点包含树B呢？" class="headerlink" title="如何判断A树是否以相同根节点包含树B呢？"></a>如何判断A树是否以相同根节点包含树B呢？</h5><ul><li>如果树B为空，说明路径匹配成功，返回true</li><li>如果树A为空 或者 树A根节点值与树B不同，返回false</li><li>递归判断 (A.left, B.left) 与 (A.right, B.right)是否也满足条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (A!=<span class="keyword">null</span>&amp;&amp;B!=<span class="keyword">null</span>)&amp;&amp;(recure(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recure</span><span class="params">(TreeNode A, TreeNode B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.val!=B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> recure(A.left,B.left)&amp;&amp;recure(A.right,B.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;p&gt;B是A的子结构， 即 A中有
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>9.正则表达式</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer09/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer09/</id>
    <published>2020-05-24T04:50:09.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目（较难）"><a href="#1-题目（较难）" class="headerlink" title="1.题目（较难）"></a>1.题目（较难）</h3><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a>思路一：动态规划</h5><p><img src="https://pic.rmb.bdstatic.com/bjh/fd8f9b644377521e8df1d3ba3f2981ad.png" alt="image-20200524124527719"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/d2628a28ee50ae8d1d809aaed6d84ec2.png" alt="image-20200524124558964"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> m = p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                f[i][j] = (i==<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)!=<span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;(s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>)||p.charAt(j-<span class="number">1</span>)==<span class="string">'.'</span>))&#123;</span><br><span class="line">                        f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        f[i][j] = f[i][j-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">2</span>&amp;&amp;(s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">2</span>)||p.charAt(j-<span class="number">2</span>)==<span class="string">'.'</span>))&#123;</span><br><span class="line">                        f[i][j] = f[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目（较难）&quot;&gt;&lt;a href=&quot;#1-题目（较难）&quot; class=&quot;headerlink&quot; title=&quot;1.题目（较难）&quot;&gt;&lt;/a&gt;1.题目（较难）&lt;/h3&gt;&lt;p&gt;请实现一个函数用来匹配包含’. ‘和’&lt;em&gt;‘的正则表达式。模式中的字符’.’表示任意一个
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>9.打印从1到最大的n位数</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer08/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer08/</id>
    <published>2020-05-20T07:33:36.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>本题主要考察如何处理超过int、long阀值的数；这时肯定不能用数值来表示要打印的数，而需要借助字符串</p><p>increment函数，若发生进位则一直进行for循环，直到不产生进位则break。如果i为0（即到了最高位）还发生了进位，则设置isOverflow为true，并返回至主函数的while判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// 将str初始化为n个'0'字符组成的字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        str.append(<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!increment(str))&#123;</span><br><span class="line">        <span class="comment">// 去掉左侧的0</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; str.length() &amp;&amp; str.charAt(index) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(str.toString().substring(index)+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">increment</span><span class="params">(StringBuilder str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isOverflow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">char</span> s = (<span class="keyword">char</span>)(str.charAt(i) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果s大于'9'则发生进位</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            str.replace(i, i + <span class="number">1</span>, <span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                isOverflow = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没发生进位则跳出for循环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            str.replace(i, i + <span class="number">1</span>, String.valueOf(s));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOverflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入数字 &lt;code&gt;n&lt;/code&gt;，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>8.快速幂运算</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer08/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer08/</id>
    <published>2020-05-20T06:58:13.000Z</published>
    <updated>2020-07-20T16:59:47.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>说明:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] </li></ul><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：二进制角度"><a href="#思路一：二进制角度" class="headerlink" title="思路一：二进制角度"></a><strong>思路一：二进制角度</strong></h5><p><img src="https://pic.rmb.bdstatic.com/bjh/cfe0dae9267127f30c563da674b2d914.png" alt="01"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/3baa061fda1521a6dbc9928f95e8f305.png" alt="TIM截图20200520145209"></p><p><strong>特别注意：虽然不考虑大数，但是要考虑最小的负数情况，它的相反数会发生溢出，所以需要long类型进行控制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>/x;</span><br><span class="line">        N = -N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastPow(x,N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>) res = res*x;</span><br><span class="line">        x = x*x;</span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="思路二：分治思想，递归"><a href="#思路二：分治思想，递归" class="headerlink" title="思路二：分治思想，递归"></a>思路二：分治思想，递归</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        N = -N;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/fastPow(x,N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastPow(x,N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> s = fastPow(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> s*s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> s = fastPow(x,(n-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> s*s*x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;实现函数double Power(double base, int exponent)，求base的exponent次方。不
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
</feed>
