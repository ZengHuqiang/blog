<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空空白的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kongkongbai.com/"/>
  <updated>2020-08-29T10:54:54.631Z</updated>
  <id>http://www.kongkongbai.com/</id>
  
  <author>
    <name>kongkongbai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序</title>
    <link href="http://www.kongkongbai.com/Algorithm/Summary/undefined/"/>
    <id>http://www.kongkongbai.com/Algorithm/Summary/undefined/</id>
    <published>2020-08-29T10:52:27.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1.堆排序"></a>1.堆排序</h3><h5 id="大顶堆："><a href="#大顶堆：" class="headerlink" title="大顶堆："></a>大顶堆：</h5><ul><li>从最后一个的非叶子结点开始调整，保证所有的根结点大于其子结点</li><li>每次置换之后，需要重新调整置换后的叶子结点是否大于它的子结点（递归）</li><li>最后一个非叶子结点：heapsize/2-1。一个根结点的左子树：2parent+1；右子树：2parent+2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = nums.length;</span><br><span class="line">    buildMaxHeap(nums,size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        maxHeapfy(nums,<span class="number">0</span>,--size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建大顶堆,从最后一个非叶子结点开始置换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">//size/2-1为最后一个非叶子结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        maxHeapfy(nums,i,size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整第i个结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapfy</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parent = i;</span><br><span class="line">    <span class="keyword">int</span> left = i*<span class="number">2</span>+<span class="number">1</span>; <span class="comment">//结点的左子树</span></span><br><span class="line">    <span class="keyword">int</span> right = i*<span class="number">2</span>+<span class="number">2</span>; <span class="comment">//结点的右子树</span></span><br><span class="line">    <span class="keyword">if</span>(left&lt;size &amp;&amp; nums[parent]&lt;nums[left])&#123;</span><br><span class="line">        parent = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right&lt;size &amp;&amp; nums[parent]&lt;nums[right])&#123;</span><br><span class="line">        parent = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(parent!=i)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[parent];</span><br><span class="line">        nums[parent] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        maxHeapfy(nums,parent,size); <span class="comment">//递归，如果发生了交换 ，则需要让交换后的子结点也满足条件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h3><h5 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h5><p>在数组中选取一个数（一般都是选第一个数），分别与其它的每一个数比较，把比这个数小的数放到它的前面，比他大的数放到它的后面，此时数组分成两部分，该数前面的都比它小，后面的都比它大，然后分别对这两部分递归排序算法，就可以实现整个数组的排序。</p><h5 id="如何将数组分为两个部分呢？"><a href="#如何将数组分为两个部分呢？" class="headerlink" title="如何将数组分为两个部分呢？"></a>如何将数组分为两个部分呢？</h5><img src="https://img-blog.csdn.net/20180715212836892?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lCTGlwbHVz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:50%;" /><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partion(nums, left, right);</span><br><span class="line">        quickSort(nums,left,pivot-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums,pivot+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partion</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = nums[left]; <span class="comment">//默认第一个数为key</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;key)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;key)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = key;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-堆排序&quot;&gt;&lt;a href=&quot;#1-堆排序&quot; class=&quot;headerlink&quot; title=&quot;1.堆排序&quot;&gt;&lt;/a&gt;1.堆排序&lt;/h3&gt;&lt;h5 id=&quot;大顶堆：&quot;&gt;&lt;a href=&quot;#大顶堆：&quot; class=&quot;headerlink&quot; title=&quot;大顶堆：&quot;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Summary" scheme="http://www.kongkongbai.com/categories/Algorithm/Summary/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://www.kongkongbai.com/Algorithm/Summary/undefined/"/>
    <id>http://www.kongkongbai.com/Algorithm/Summary/undefined/</id>
    <published>2020-08-29T10:52:15.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-调整单链表使得奇数位置的元素位于偶数位置元素之前"><a href="#1-调整单链表使得奇数位置的元素位于偶数位置元素之前" class="headerlink" title="1.调整单链表使得奇数位置的元素位于偶数位置元素之前"></a>1.调整单链表使得奇数位置的元素位于偶数位置元素之前</h3><p><strong>需要四个指针</strong>，对应leetcode86，有时间练一练</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode node1head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode node1tail = node1head;</span><br><span class="line">        ListNode node2head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode node2tail = node2head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val&lt;x)&#123;</span><br><span class="line">              node1tail.next = head;</span><br><span class="line">              node1tail = node1tail.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node2tail.next = head;</span><br><span class="line">                node2tail = node2tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node2tail.next = <span class="keyword">null</span>;</span><br><span class="line">        node1tail.next = node2head.next;</span><br><span class="line">        <span class="keyword">return</span> node1head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="练习：奇偶链表leetcode328"><a href="#练习：奇偶链表leetcode328" class="headerlink" title="练习：奇偶链表leetcode328"></a>练习：奇偶链表leetcode328</h4><h3 id="2-根据指针删除结点"><a href="#2-根据指针删除结点" class="headerlink" title="2.根据指针删除结点"></a>2.根据指针删除结点</h3><p><strong>思路一：正常思路是我们要删除一个结点，需要让这个结点的前一个节点指向这个结点的下一个结点。</strong></p><p><strong>思路二：我们将这个结点的下一个结点的val赋值给当前结点，然后跳过下一个结点即可。即保存下一个结点的信息，然后跳过下一个结点</strong></p><h3 id="3-删除倒数第n个节点"><a href="#3-删除倒数第n个节点" class="headerlink" title="3.删除倒数第n个节点"></a>3.删除倒数第n个节点</h3><p><strong>思路一：遍历一遍确定位置，然后在删除指定位置的结点（可以考虑hashmap）</strong></p><p><strong>思路二：双指针思路，两个指针start和end同时指向head，然后end向后移动n位，之后start和end同时向后移动，直到end指向null</strong></p><h3 id="4-判断链表是否为回文"><a href="#4-判断链表是否为回文" class="headerlink" title="4.判断链表是否为回文"></a>4.判断链表是否为回文</h3><p><strong>思路一：用数组存储链表的数据，然后通过数组进行判断（不满足空间复杂度）</strong></p><p><strong>思路二：通过快慢指针找到中间结点，然后翻转后面一半的链表后，从head和中间结点以后比较</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//利用快慢指针找到中间结点</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast!=<span class="keyword">null</span>) slow = slow.next;</span><br><span class="line">  <span class="comment">//翻转一半的链表，然后进行比较</span></span><br><span class="line">        slow = reverse(slow);</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow.val!=head.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//翻转链表函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            newHead = temp;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            newHead.next = cur;</span><br><span class="line">            cur = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-合并链表"><a href="#5-合并链表" class="headerlink" title="5.合并链表"></a>5.合并链表</h3><h4 id="5-1-合并两个排序链表"><a href="#5-1-合并两个排序链表" class="headerlink" title="5.1 合并两个排序链表"></a>5.1 合并两个排序链表</h4><p>新建一个头结点和一个尾指针，一个个拼接两个链表的结点就行</p><h4 id="5-2-合并k个有序链表"><a href="#5-2-合并k个有序链表" class="headerlink" title="5.2 合并k个有序链表"></a>5.2 合并k个有序链表</h4><p><strong>思路：使用优先队列，将每个链表的头结点放入小顶堆中，每次循环poll()出最小的结点进行拼接，当poll出的结点next不为空时，将下一个结点添加到小顶堆中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;((e1,e2)-&gt;e1.val-e2.val);</span><br><span class="line">    <span class="keyword">for</span>(ListNode node:lists)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="keyword">null</span>)</span><br><span class="line">        queue.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = newHead;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        ListNode temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(temp.next!=<span class="keyword">null</span>) queue.add(temp.next);</span><br><span class="line">        cur.next = temp;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-链表的交点"><a href="#6-链表的交点" class="headerlink" title="6.链表的交点"></a>6.链表的交点</h3><h4 id="6-1两条单向链表的交点"><a href="#6-1两条单向链表的交点" class="headerlink" title="6.1两条单向链表的交点"></a>6.1两条单向链表的交点</h4><p><strong>双指针：</strong></p><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode node1 = headA;</span><br><span class="line">    ListNode node2 = headB;</span><br><span class="line">    <span class="comment">//为了防止因两个链表本来就不相交而设置的交换次数参数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(node1!=node2)&#123;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">        <span class="keyword">if</span>(node1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            node1 = headB;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node2==<span class="keyword">null</span>) &#123;</span><br><span class="line">            node2 = headA;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最多交换次数为两次，超过即证明是死循环</span></span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2判断链表是否有环"><a href="#6-2判断链表是否有环" class="headerlink" title="6.2判断链表是否有环"></a>6.2判断链表是否有环</h4><p><strong>思路一：快慢指针，如果相遇则代表有环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ListNode node1 = head;</span><br><span class="line">    ListNode node2 = head.next;</span><br><span class="line">    <span class="keyword">while</span>(node1!=node2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node2==<span class="keyword">null</span>||node2.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">        node2 = node2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路二：HashSet，存储每个结点的地址，如果重复则表示有环</strong></p><h4 id="6-3返回环形链表的交点"><a href="#6-3返回环形链表的交点" class="headerlink" title="6.3返回环形链表的交点"></a>6.3返回环形链表的交点</h4><p>这次不仅仅是要判断是否有环，还有判断环的交点</p><p><strong>思路一：继续采用HashSet是可行的，第一个重复的结点即为环点</strong></p><p><strong>思路二：快慢指针</strong></p><img src="/Users/huqiangzeng/Library/Application Support/typora-user-images/image-20200826203925042.png" alt="image-20200826203925042" style="zoom:50%;" /><p><strong>让fast比slow每次多走一步</strong></p><p>相遇时，fast走了D+n(S1+S2)+S1,slow走了D+S1</p><p>则D+n(S1+S2)+S1 = 2(D+S1) –&gt; D+S1 = n(S1+S2) –&gt;D = (n-1)(S1+S2)+S2–&gt;D的距离为n-1个圈长+S2的距离</p><p><strong>相遇后，让快指针从头开始以每次一步的速度走，他们下次相遇时，必是环点！</strong></p><p>下次相遇fast要走D，此时slow刚好走了n-1圈再加S2的长度，刚好在环点</p><h3 id="7-复杂链表的深拷贝"><a href="#7-复杂链表的深拷贝" class="headerlink" title="7.复杂链表的深拷贝"></a>7.复杂链表的深拷贝</h3><p><strong>思路一：HashMap</strong></p><p>两次遍历，第一次创建与原链表一一对应相等的结点，并用HashMap存储其一一对应的关系；第二次将原来链表的关系，复制给HashMap对应的Value结点中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        map.put(cur,<span class="keyword">new</span> Node(cur.val));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        map.get(temp).next = map.get(temp.next);</span><br><span class="line">        map.get(temp).random = map.get(temp.random);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路二：深度优先遍历和广度优先遍历</strong></p><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/lian-biao-de-shen-kao-bei-by-z1m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/lian-biao-de-shen-kao-bei-by-z1m/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-调整单链表使得奇数位置的元素位于偶数位置元素之前&quot;&gt;&lt;a href=&quot;#1-调整单链表使得奇数位置的元素位于偶数位置元素之前&quot; class=&quot;headerlink&quot; title=&quot;1.调整单链表使得奇数位置的元素位于偶数位置元素之前&quot;&gt;&lt;/a&gt;1.调整单链表使
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Summary" scheme="http://www.kongkongbai.com/categories/Algorithm/Summary/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://www.kongkongbai.com/Algorithm/Summary/undefined/"/>
    <id>http://www.kongkongbai.com/Algorithm/Summary/undefined/</id>
    <published>2020-08-29T10:52:06.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><h4 id="1-1-普通的二分查找"><a href="#1-1-普通的二分查找" class="headerlink" title="1.1 普通的二分查找"></a>1.1 普通的二分查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            end = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-循环有序数组的二分查找"><a href="#1-2-循环有序数组的二分查找" class="headerlink" title="1.2 循环有序数组的二分查找"></a>1.2 循环有序数组的二分查找</h4><p>类似这样的数组【7，8，9，10，1，2，3，4，5】</p><p>关键点：先确定转折点位置，然后会对应target的三种情况，我们只需要关心<strong>target单独在mid一边的情况，其余情况直接用else</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="comment">//转折点在mid右边</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;=nums[start])&#123;</span><br><span class="line">            <span class="comment">//只关心"一边"的那种情况</span></span><br><span class="line">            <span class="keyword">if</span>(nums[start]&lt;=target &amp;&amp; target&lt;nums[mid]) end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;nums[start]) start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> end = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-第K大元素"><a href="#2-第K大元素" class="headerlink" title="2.第K大元素"></a>2.第K大元素</h3><h4 id="2-1-堆排序（优先队列，小顶堆实现）"><a href="#2-1-堆排序（优先队列，小顶堆实现）" class="headerlink" title="2.1 堆排序（优先队列，小顶堆实现）"></a>2.1 堆排序（优先队列，小顶堆实现）</h4><p>通过堆排序每次找到k-小顶堆中的最小值排除出去，经过n-k次排出后，最后的k-小顶堆为最大的k个数，堆即为所求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">topK</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        queue.add(num);</span><br><span class="line">        <span class="keyword">if</span>(queue.size()&gt;k)&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-快速排序"><a href="#2-2-快速排序" class="headerlink" title="2.2 快速排序"></a>2.2 快速排序</h4><p>我们知道快速排序的核心是找到一个数将数组分为大于和小于这个数的两部分，当我们找打pivot后，将pivot与k相比，以类似二分法的方式进行快速排序的优化（只排序包含k的那部分），直到pivot=k</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        kk = nums.length - k; </span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);     </span><br><span class="line">        <span class="keyword">return</span> nums[kk];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = partition(data, start,end);</span><br><span class="line">            <span class="comment">//当第k大位置的数字归位时，结束递归遍历；</span></span><br><span class="line">            <span class="keyword">if</span>(mid == kk) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid &gt; kk) quickSort(data, start, mid-<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">else</span> quickSort(data, mid+<span class="number">1</span>, end);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//省略了partion函数</span></span><br></pre></td></tr></table></figure><h3 id="3-第一个缺失的正整数"><a href="#3-第一个缺失的正整数" class="headerlink" title="3.第一个缺失的正整数"></a>3.第一个缺失的正整数</h3><p>第一遍遍历，我们将大小为1-n的整数放到该数组中相应索引的位置；第二遍遍历，找出第一个不在相应索引上缺失的整数</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]&gt;=<span class="number">1</span>&amp;&amp;nums[i]&lt;=n&amp;&amp;nums[i]!=i+<span class="number">1</span>&amp;&amp;nums[nums[i]-<span class="number">1</span>]!=nums[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">            nums[nums[i]-<span class="number">1</span>] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=i+<span class="number">1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：我们在交换nums[i]和nums[nums[i]-1]时，需要判断它们是否相等，不然会导致无限循环</strong></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="4-三数之和为0"><a href="#4-三数之和为0" class="headerlink" title="4.三数之和为0"></a>4.三数之和为0</h3><h4 id="如何解决两数之和为0呢？"><a href="#如何解决两数之和为0呢？" class="headerlink" title="如何解决两数之和为0呢？"></a>如何解决两数之和为0呢？</h4><p>方法一：Hash表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = target-nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(num),i&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：双指针+排序</p><h4 id="问题转换："><a href="#问题转换：" class="headerlink" title="问题转换："></a>问题转换：</h4><p>方法一：Hash表，确定一个数n，然后将问题转换为两数之和为-n，<strong>效率非常低</strong>O(n*n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用set来避免重复解</span></span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = target - nums[j];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                List&lt;Integer&gt; list = Arrays.asList(nums[i],map.get(num),nums[j]);</span><br><span class="line">                <span class="comment">//使用list.sort(Comparator.naturalOrder())，对数组进行自然排序，避免重复解</span></span><br><span class="line">                list.sort(Comparator.naturalOrder());</span><br><span class="line">                result.add(list);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[j],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>使用 <strong>Set&lt;List<Integer>&gt; result = new LinkedHashSet&lt;&gt;()</strong>来避免重复解，使用<strong>list.sort(Comparator.naturalOrder())</strong>对result进行排序避免相同解的不同排序方式</p><p>方法二：排序+双指针，同样先确定一个数，然后用双指针夹逼的方式来获取结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//加速1：当选取的第一个数大于0时，就已经不可能三数和为0</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//加速2：如果一个数等于前面这个数，说明已经进行过筛选，跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;left)&#123;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">            <span class="keyword">if</span>(nums[left]+nums[right]&lt;target)&#123;</span><br><span class="line">                <span class="comment">//left+1，同时跳过相同数的情况</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[++left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]&gt;target)&#123;</span><br><span class="line">                <span class="comment">//right-1,同时跳过相同数的情况</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[--right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line">                <span class="comment">//left+1，同时跳过相同数的情况</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[++left]);</span><br><span class="line">                <span class="comment">//right-1,同时跳过相同数的情况</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[--right]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-数组中元素出现次数"><a href="#5-数组中元素出现次数" class="headerlink" title="5.数组中元素出现次数"></a>5.数组中元素出现次数</h3><h4 id="5-0-给定数组，求前k个频率最高的数"><a href="#5-0-给定数组，求前k个频率最高的数" class="headerlink" title="5.0 给定数组，求前k个频率最高的数"></a>5.0 给定数组，求前k个频率最高的数</h4><p><strong>思路跟5.1一致</strong></p><h4 id="5-1根据字符串字符出现次数排序"><a href="#5-1根据字符串字符出现次数排序" class="headerlink" title="5.1根据字符串字符出现次数排序"></a>5.1根据字符串字符出现次数排序</h4><p>使用<strong>HashMap</strong>来存储每个字符出现的次数，再将<strong>Map.Entry()放入大顶堆中</strong>对entry.getValue()进行排序，最后使用<strong>StringBuilder</strong>进行字符串的拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> chr:s.toCharArray())&#123;</span><br><span class="line">        map.put(chr, map.getOrDefault(chr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Character,Integer&gt;&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((e1,e2)-&gt;e2.getValue()-e1.getValue());</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">        queue.add(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Map.Entry&lt;Character,Integer&gt; entry = queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;entry.getValue();i++)&#123;</span><br><span class="line">            res.append(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>map.put(chr, map.getOrDefault(chr, 0) + 1);</code>优化了代码，简化判断逻辑</li><li><code>PriorityQueue&lt;Map.Entry&lt;Character,Integer&gt;&gt; queue = new PriorityQueue&lt;&gt;((e1,e2)-&gt;e2.getValue()-e1.getValue());</code>如何构建以Map.Entry为元素的大顶堆</li></ul><p>记忆：return e1-e2 为正数时是默认的降序(小顶堆)，反之为大顶堆</p><h4 id="5-2-数组中其余数字出现两次，找出只出现一次的那一个数字"><a href="#5-2-数组中其余数字出现两次，找出只出现一次的那一个数字" class="headerlink" title="5.2 数组中其余数字出现两次，找出只出现一次的那一个数字"></a>5.2 数组中其余数字出现两次，找出只出现一次的那一个数字</h4><p>我们将数组中所有的数组进行异或运算，相同的两个数字会两两抵消，最后剩下的即为只出现一次的那个数字</p><h4 id="5-2-数组中其余数字出现两次，找出中出现一次的那两个数字"><a href="#5-2-数组中其余数字出现两次，找出中出现一次的那两个数字" class="headerlink" title="5.2 数组中其余数字出现两次，找出中出现一次的那两个数字"></a>5.2 数组中其余数字出现两次，找出中出现一次的那两个数字</h4><p> <a href="数组中数字出现的次数.md">数组中数字出现的次数.md</a> </p><p>我们将数组中所有的数组进行异或运算，相同的两个数字会两两抵消，最后剩下的即为只出现一次的两个数字做异或得到的结果</p><p>即<strong>result = a^b</strong></p><p>分析两个数字做异或的情况：</p><ul><li>当数位上出现0，两种情况，a、b两个数相应数位相等，同为1，或者同为0。</li><li>当数位上出现1，a、b在该位置上的数位不相等</li></ul><p>我们无法从第一种情况中对a、b进行区分，<strong>从第二种情况下手</strong></p><p>我们找出result中 数位为1的那一位（任意），然后将这一位分别与a、b进行与运算，这样我们就可以区分出a、b</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        x = x^nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((div&amp;x)==<span class="number">0</span>)&#123;</span><br><span class="line">        div = div&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[i]&amp;div)==<span class="number">0</span>) a=nums[i]^a;</span><br><span class="line">        <span class="keyword">else</span> b = nums[i]^b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-数组中其余数字出现两次，找出中出现一次的那一个数字"><a href="#5-3-数组中其余数字出现两次，找出中出现一次的那一个数字" class="headerlink" title="5.3 数组中其余数字出现两次，找出中出现一次的那一个数字"></a>5.3 数组中其余数字出现两次，找出中出现一次的那一个数字</h4><h3 id="6-连续子数组问题"><a href="#6-连续子数组问题" class="headerlink" title="6.连续子数组问题"></a>6.连续子数组问题</h3><h4 id="6-1子数组之和等于所给数的个数"><a href="#6-1子数组之和等于所给数的个数" class="headerlink" title="6.1子数组之和等于所给数的个数"></a>6.1子数组之和等于所给数的个数</h4><p>方法一：双指针（针对数组已排序的情况）</p><p>方法二：创建数组sum[]，其中sum[n]表示数组前n个数之和，再二次遍历sum，计算sum[m]-sum[n]：表示n到m数字的和，与k进行比较（复杂，不推荐）</p><h4 id="6-2是否存在子数组之和等于所给数的整数倍"><a href="#6-2是否存在子数组之和等于所给数的整数倍" class="headerlink" title="6.2是否存在子数组之和等于所给数的整数倍"></a>6.2是否存在子数组之和等于所给数的整数倍</h4><p>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p><p>双指针无法实现</p><p><strong>方法二可以实现，但是时间复杂度始终为n*n，不推荐</strong></p><p><strong>使用HashMap+取余数 来优化方法二</strong></p><p>原理：HashMap中存放<strong>前i个数之和余k</strong>的值，当重复出现相同的sum且相应index大于1时，则表示出现了子数组之和能够整除所给数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//针对k=0的情况</span></span><br><span class="line">    map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(k!=<span class="number">0</span>) sum = sum%k;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(sum))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-map.get(sum)&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(sum,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3和为s的连续正数序列"><a href="#6-3和为s的连续正数序列" class="headerlink" title="6.3和为s的连续正数序列"></a>6.3和为s的连续正数序列</h4><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>方法一：<strong>双指针</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>, end = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = start + end;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(end&gt;start)&#123;</span><br><span class="line">        <span class="keyword">while</span>(end &gt; start&amp;&amp;sum &lt; target)&#123;</span><br><span class="line">            sum += ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(end &gt; start&amp;&amp;sum &gt; target)&#123;</span><br><span class="line">            sum -= start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end &gt; start&amp;&amp;sum == target)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                temp[index++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            sum -= start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二（推荐）：<strong>数学法</strong></p><p>如果存在和为target长度n的正数序列，那么（target-1-2-3-…-n)%n == 0;且开始的数为整除的除数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">       </span><br><span class="line">       List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>(target&gt;<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           target -= i++;</span><br><span class="line">           <span class="keyword">if</span>(target&gt;<span class="number">0</span> &amp;&amp; target%i == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[i];</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k = target/i, j = <span class="number">0</span>; k &lt; target/i+i; k++,j++)</span><br><span class="line">               &#123;</span><br><span class="line">                   array[j] = k;</span><br><span class="line">               &#125;</span><br><span class="line">               result.add(array);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Collections.reverse(result);</span><br><span class="line">       <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-最大子序列之和"><a href="#6-4-最大子序列之和" class="headerlink" title="6.4 最大子序列之和"></a>6.4 最大子序列之和</h4><p>思路：对于每个数而言都有两种选择，要么接着左边的子数组继续，要么另起炉灶。 sum = max{sum + nums[i], nums[i]}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            sum = Math.max(sum+i,i);</span><br><span class="line">            res = Math.max(sum,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-二分查找&quot;&gt;&lt;a href=&quot;#1-二分查找&quot; class=&quot;headerlink&quot; title=&quot;1.二分查找&quot;&gt;&lt;/a&gt;1.二分查找&lt;/h3&gt;&lt;h4 id=&quot;1-1-普通的二分查找&quot;&gt;&lt;a href=&quot;#1-1-普通的二分查找&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Summary" scheme="http://www.kongkongbai.com/categories/Algorithm/Summary/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://www.kongkongbai.com/Algorithm/Summary/undefined/"/>
    <id>http://www.kongkongbai.com/Algorithm/Summary/undefined/</id>
    <published>2020-08-29T10:51:57.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-二叉树的最大-最小深度"><a href="#1-二叉树的最大-最小深度" class="headerlink" title="1.二叉树的最大/最小深度"></a>1.二叉树的最大/最小深度</h3><p>深度都是考虑到<strong>叶子结点</strong>路径的长度</p><h4 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4><p>最大深度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最小深度：</p><p>相比于最大深度，计算最小深度时，需要考虑该节点是否存在左/右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.right==<span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.left)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-前、中、后序遍历的非递归方式"><a href="#2-前、中、后序遍历的非递归方式" class="headerlink" title="2.前、中、后序遍历的非递归方式"></a>2.前、中、后序遍历的非递归方式</h3><h4 id="递归写法（中序为例）："><a href="#递归写法（中序为例）：" class="headerlink" title="递归写法（中序为例）："></a>递归写法（中序为例）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归写法—利用栈"><a href="#非递归写法—利用栈" class="headerlink" title="非递归写法—利用栈"></a>非递归写法—利用栈</h4><h5 id="非递归前序遍历："><a href="#非递归前序遍历：" class="headerlink" title="非递归前序遍历："></a>非递归前序遍历：</h5><p>1.先将根节点入栈<br>2.访问根节点<br>3.如果根节点存在右孩子，则将右孩子入栈<br>4.如果根节点存在左孩子，则将左孩子入栈（<strong>注意：一定是右孩子先入栈，然后左孩子入栈</strong>）<br>5.重复2-4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        System.out.println(temp.val);</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>) stack.push(temp.right);</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>) stack.push(temp.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归中序遍历："><a href="#非递归中序遍历：" class="headerlink" title="非递归中序遍历："></a>非递归中序遍历：</h5><p>1.先将根节点入栈<br>2.将当前节点的所有左孩子入栈，直到左孩子为空<br>3.访问栈顶元素，如果栈顶元素存在右孩子，则继续第2步<br>4.重复第2、3步，直到栈为空并且所有的节点都被访问</p><p>为了避免搜索左孩子时重复入栈，需要定义一个temp来记录已访问过的结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode temp = stack.peek();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">            stack.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        System.out.println(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = root.right;</span><br><span class="line">            stack.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归后序遍历："><a href="#非递归后序遍历：" class="headerlink" title="非递归后序遍历："></a>非递归后序遍历：</h5><ol><li>根节点入栈，并定一个pre指针指向上一次访问的结点，初始为null</li><li>获取栈顶元素，如果栈顶元素的左右儿子同时为空或者pre指针为栈顶元素的左右儿子之一（即已被访问过的结点），则访问栈顶元素，并设置pre指针为刚刚的栈顶元素</li><li>如果栈顶元素不同时为空，则先判断右子树入栈，只有判断左子树入栈</li><li>循环直至栈为空</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = s.peek();</span><br><span class="line">        <span class="comment">//如果当前栈顶结点的左右子树同时为空，或者它的左右子节点为已访问过的节点</span></span><br><span class="line">        <span class="keyword">if</span>((cur.left==<span class="keyword">null</span>&amp;&amp;cur.right==<span class="keyword">null</span>)||(pre!=<span class="keyword">null</span>&amp;&amp;(pre==cur.left||pre==cur.right))) &#123;</span><br><span class="line">        pre = s.pop();</span><br><span class="line">        result.add(pre.val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>) s.push(cur.right);</span><br><span class="line">        <span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>) s.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-二叉树翻转左右子树"><a href="#3-二叉树翻转左右子树" class="headerlink" title="3.二叉树翻转左右子树"></a>3.二叉树翻转左右子树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    reverse(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>||root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(root.left);</span><br><span class="line">    reverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-求完全二叉树的节点个数"><a href="#4-求完全二叉树的节点个数" class="headerlink" title="4.求完全二叉树的节点个数"></a>4.求完全二叉树的节点个数</h3><p><strong>思路一</strong>：使用递归，以<strong>求一个普通二叉树的方式</strong>来求完成二叉树的节点个数（没有运用完全二叉树的特性）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> countNodes(root.left)+countNodes(root.right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路二</strong>：完成二叉树的节点个数=非底层节点个数+底层节点个数；非底层节点个数 = 高度*2 - 1；所以我们只需要关注底层节点个数：</p><p><strong>深度计算</strong>：</p><p>最右边节点的深度即为相应深度</p><p><strong>最后一层的节点</strong><br>使用helper()函数计算最后一层节点的数量，传入的depth是下面最多还有的深度，所以depth == 0也就是深度遍历终止的地方，此处有节点返回1，无节点返回0。<br>关键的剪枝操作：当左子树的最后一层的节点没有充满时，直接返回左子树中的最后一层的节点数（右子树最后一层一定没有节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    TreeNode temp = root;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        depth++;</span><br><span class="line">        temp = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bottom = helper(depth,root);</span><br><span class="line">    <span class="keyword">return</span> bottom+(<span class="number">1</span>&lt;&lt;depth)-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> depth,TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = helper(depth-<span class="number">1</span>,root.left);</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="number">1</span> &lt;&lt; depth - <span class="number">1</span>) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> left+helper(depth-<span class="number">1</span>,root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>减号优先级高于&lt;&lt;，所以1&lt;&lt;depth-1是先做减法</p><h3 id="5-根节点到叶子结点和为sum的路径"><a href="#5-根节点到叶子结点和为sum的路径" class="headerlink" title="5.根节点到叶子结点和为sum的路径"></a>5.根节点到叶子结点和为sum的路径</h3><p><strong>思路：</strong>递归，向子节点进行递归，当节点为null时，结束递归；每次递归sum都减去当前节点的值，当sum为0且当前节点为叶子结点时则将此路径添加到结果集中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    getPath(root,sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPath</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sum = sum - root.val;</span><br><span class="line">    path.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">    &#125;</span><br><span class="line">    getPath(root.left,sum);</span><br><span class="line">    getPath(root.right,sum);</span><br><span class="line">    path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-二叉树的最大-最小深度&quot;&gt;&lt;a href=&quot;#1-二叉树的最大-最小深度&quot; class=&quot;headerlink&quot; title=&quot;1.二叉树的最大/最小深度&quot;&gt;&lt;/a&gt;1.二叉树的最大/最小深度&lt;/h3&gt;&lt;p&gt;深度都是考虑到&lt;strong&gt;叶子结点&lt;/stron
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Summary" scheme="http://www.kongkongbai.com/categories/Algorithm/Summary/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>21.数组中的逆序对</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer21/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer21/</id>
    <published>2020-07-12T14:29:39.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p>示例 1:</p><p>输入: [7,5,6,4]<br>输出: 5</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：归并分治</p><p>我们知道归并排序是将一个数组分为不同的两个部分，分别对子数组进行排序，然后再将子数组归并为有序数组。</p><p>同样我们可以将这个思路引进，在归并过程中计算产生的逆序对</p><p><img src="https://pic.rmb.bdstatic.com/bjh/f9774e570479b5b3539e06c7680ace5e.png" alt="image-20200712223344729"></p><p><strong>总结来说，就是在归并排序基础上，在比较左右子数组指针时，当 左指针&gt;右指针 时，会产生有规律的逆序对，即此时左指针右边的数都会与这个右指针产生逆序对，所以我们只需要在这种情况下计算产生的逆序对即可。</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        copy[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">return</span> reversePairs(copy,<span class="number">0</span>,len-<span class="number">1</span>,temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> leftPairs = reversePairs(num,start,mid,temp);</span><br><span class="line">    <span class="keyword">int</span> rightPairs = reversePairs(num,mid+<span class="number">1</span>,end,temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num[mid]&lt;=num[mid+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> leftPairs+rightPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> crossPairs = mergeAndCount(num,start,mid,end,temp);</span><br><span class="line">    <span class="keyword">return</span> leftPairs+rightPairs+crossPairs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mergeAndCount</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> start,<span class="keyword">int</span> mid,<span class="keyword">int</span> end,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">        temp[i] = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p1 = start;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> key = start;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp[p1]&gt;temp[p2])&#123;</span><br><span class="line">            count+=mid-p1+<span class="number">1</span>;</span><br><span class="line">            num[key++] = temp[p2++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num[key++] = temp[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=mid) num[key++] = temp[p1++];</span><br><span class="line">    <span class="keyword">while</span>(p2&lt;=end) num[key++] = temp[p2++];</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>spring自研框架IoC03实现容器的依赖注入</title>
    <link href="http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC03/"/>
    <id>http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC03/</id>
    <published>2020-06-29T08:04:15.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-4-实现容器的依赖注入"><a href="#2-4-实现容器的依赖注入" class="headerlink" title="2.4.实现容器的依赖注入"></a>2.4.实现容器的依赖注入</h3><p><strong>Bean容器管理实例的作用域：singleton</strong></p><p><strong>目前容器存在的问题：容器管理的Bean实例不完备</strong>：</p><ul><li>实例里面某些必须的成员变量还没有被创建出来，比如某个Controller依赖某个Service成员，但是获取的Controller实例中的Service成员并没有被创建</li></ul><p><strong>实现思路（支持成员变量级别的注入）：</strong></p><ul><li>定义相关的注解标签</li><li>实现创建被注解标记的成员变量实例，并将其注入到成员变量里</li><li>依赖注入的使用</li></ul><h4 id="2-4-1-定义相关的注解标签"><a href="#2-4-1-定义相关的注解标签" class="headerlink" title="2.4.1 定义相关的注解标签"></a>2.4.1 定义相关的注解标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Autowired目前仅支持成员变量注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-实现创建被注解标记的成员变量实例，并将其注入到成员变量里"><a href="#2-4-2-实现创建被注解标记的成员变量实例，并将其注入到成员变量里" class="headerlink" title="2.4.2 实现创建被注解标记的成员变量实例，并将其注入到成员变量里"></a>2.4.2 实现创建被注解标记的成员变量实例，并将其注入到成员变量里</h4><p><strong>实现思路：</strong></p><ul><li>遍历获取所有的Class对象</li><li>遍历获取Class对象中所有成员变量</li><li>获取成员变量中被@Autowired标记的成员变量</li><li>获取这些成员变量的类型</li><li>先从容器中尝试能否获取该实例，如果不可以，那证明是其接口或者超类，则获取其接口的实现类</li><li>最后通过反射将创建的实例注入到成员变量中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行Ioc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIoc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ValidationUtil.isEmpty(beanContainer.getClasses()))&#123;</span><br><span class="line">        log.warn(<span class="string">"empty classset in BeanContainer"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.遍历Bean容器中所有的Class对象</span></span><br><span class="line">    <span class="keyword">for</span>(Class&lt;?&gt; clazz : beanContainer.getClasses())&#123;</span><br><span class="line">        <span class="comment">//2.遍历Class对象的所有成员变量</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">if</span> (ValidationUtil.isEmpty(fields))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">            <span class="comment">//3.找出被Autowired标记的成员变量</span></span><br><span class="line">            <span class="keyword">if</span>(field.isAnnotationPresent(Autowired<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                Autowired autowired = field.getAnnotation(Autowired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                String autowiredValue = autowired.value();</span><br><span class="line">                <span class="comment">//4.获取这些成员变量的类型</span></span><br><span class="line">                Class&lt;?&gt; fieldClass = field.getType();</span><br><span class="line">                <span class="comment">//5.获取这些成员变量的类型在容器里对应的实例</span></span><br><span class="line">                Object fieldValue = getFieldInstance(fieldClass, autowiredValue);</span><br><span class="line">                <span class="keyword">if</span>(fieldValue == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"unable to inject relevant type，target fieldClass is:"</span> + fieldClass.getName() + <span class="string">" autowiredValue is : "</span> + autowiredValue);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//6.通过反射将对应的成员变量实例注入到成员变量所在类的实例里</span></span><br><span class="line">                    Object targetBean =  beanContainer.getBean(clazz);</span><br><span class="line">                    ClassUtil.setField(field, targetBean, fieldValue, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>根据Class在beanContainer里获取其实例或者实现类</strong></li><li>如果成员变量接口对应多个实现类，用户需要指定是哪个实现类，<strong>所以还需要再Autowired注解中添加value属性</strong></li><li>同时需要将获取的属性值传入方法中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Autowired目前仅支持成员变量注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//默认值为空串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据class在beanContainer中获取其实例或者实现类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getFieldInstance</span><span class="params">(Class&lt;?&gt; fieldClass,String autowiredValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先看该成员变量的实例是否存在于该容器</span></span><br><span class="line">        Object fieldValue = beanContainer.getBean(fieldClass);</span><br><span class="line">        <span class="keyword">if</span>(fieldValue!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> fieldValue;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//获取接口的实现类</span></span><br><span class="line">            Class&lt;?&gt; implementedClass = getImplementClass(fieldClass,autowiredValue);</span><br><span class="line">            <span class="keyword">if</span>(implementedClass!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> beanContainer.getBean(implementedClass);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取接口的实现类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; getImplementClass(Class&lt;?&gt; fieldClass,String autowiredValue) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = beanContainer.getClassesBySuper(fieldClass);</span><br><span class="line">        <span class="keyword">if</span>(!ValidationUtil.isEmpty(classSet))&#123;</span><br><span class="line">            <span class="comment">//如果用户没有告诉我们是哪个实现类</span></span><br><span class="line">            <span class="keyword">if</span>(ValidationUtil.isEmpty(autowiredValue))&#123;</span><br><span class="line">                <span class="comment">//并且只有一个实现类</span></span><br><span class="line">                <span class="keyword">if</span>(classSet.size()==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> classSet.iterator().next();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果有多个实现类,我们不知道是哪个实现类，抛出异常</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"multiple implemented classes for"</span>+fieldClass.getName()+<span class="string">"please set @Autowired value to pick one"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果设置上了相关实现类值,找出与之对应的实现类即可</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(Class&lt;?&gt; clazz:classSet)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(autowiredValue.equals((clazz.getSimpleName())))&#123;</span><br><span class="line">                        <span class="keyword">return</span> clazz;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3-依赖注入的使用"><a href="#2-4-3-依赖注入的使用" class="headerlink" title="2.4.3 依赖注入的使用"></a>2.4.3 依赖注入的使用</h4><p> <strong>一个简单的UT</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInjectorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"依赖注入doIoc"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIocTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BeanContainer beanContainer = BeanContainer.getInstance();</span><br><span class="line">        beanContainer.loadBeans(<span class="string">"com.imooc"</span>);</span><br><span class="line">        Assertions.assertEquals(<span class="keyword">true</span>,beanContainer.isLoaded());</span><br><span class="line">        MainPageController mainPageController = (MainPageController)beanContainer.getBean(MainPageController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Assertions.assertEquals(<span class="keyword">true</span>,mainPageController <span class="keyword">instanceof</span> MainPageController);</span><br><span class="line">        Assertions.assertEquals(<span class="keyword">null</span>,mainPageController.getHeadLineShopCategoryCombineService());</span><br><span class="line">        <span class="keyword">new</span> DependencyInjector().doIoc();</span><br><span class="line">        Assertions.assertNotEquals(<span class="keyword">null</span>,mainPageController.getHeadLineShopCategoryCombineService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2-4-实现容器的依赖注入&quot;&gt;&lt;a href=&quot;#2-4-实现容器的依赖注入&quot; class=&quot;headerlink&quot; title=&quot;2.4.实现容器的依赖注入&quot;&gt;&lt;/a&gt;2.4.实现容器的依赖注入&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Bean容器管理实例的作用域：sin
      
    
    </summary>
    
    
      <category term="spring框架篇" scheme="http://www.kongkongbai.com/categories/spring%E6%A1%86%E6%9E%B6%E7%AF%87/"/>
    
    
      <category term="spring框架" scheme="http://www.kongkongbai.com/tags/spring%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>spring自研框架IoC02实现Bean容器</title>
    <link href="http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC02/"/>
    <id>http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC02/</id>
    <published>2020-06-29T08:03:57.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-3-实现容器"><a href="#2-3-实现容器" class="headerlink" title="2.3 实现容器"></a>2.3 实现容器</h3><h4 id="2-3-1-枚举单例容器"><a href="#2-3-1-枚举单例容器" class="headerlink" title="2.3.1 枚举单例容器"></a>2.3.1 枚举单例容器</h4><p>在框架中Bean容器需要保证唯一，适合采用<strong>单例模式</strong></p><p>但是一般的单例模式容易受到<strong>反射和序列化的攻击</strong>，采用<strong>枚举单例</strong>，能有效避免</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE) <span class="comment">//定义一个无参私有构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanContainer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取单例容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanContainer <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ContainerHolder.HOLDER.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> ContainerHolder&#123;</span><br><span class="line">        HOLDER;</span><br><span class="line">        <span class="keyword">private</span> BeanContainer instance;</span><br><span class="line">        ContainerHolder()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> BeanContainer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-实现容器"><a href="#2-3-2-实现容器" class="headerlink" title="2.3.2 实现容器"></a>2.3.2 实现容器</h4><ul><li>保存Class对象及其实例载体</li><li>容器的加载：定义并获取目标对象</li><li>容器的操作方式：对外提供操作</li></ul><h4 id="2-3-2-1-保存Class对象及其实例载体"><a href="#2-3-2-1-保存Class对象及其实例载体" class="headerlink" title="2.3.2.1 保存Class对象及其实例载体"></a>2.3.2.1 保存Class对象及其实例载体</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  存放所有被配置标记的目标对象的Map</span></span><br><span class="line"><span class="comment"> *  采用ConcurrentHashMap，因为它的并发性能较好</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;,Object&gt; beanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="2-3-2-2-容器的加载"><a href="#2-3-2-2-容器的加载" class="headerlink" title="2.3.2.2 容器的加载"></a>2.3.2.2 容器的加载</h4><p>1.定义loaded变量 private boolean loaded = false，加载前判断容器是否已经被加载</p><p>2.扫描包下的所有class文件：运用包装好的ClassUtil.extractPackageClass(packageName)</p><p>3.将获取的classSet进行遍历，判断是否被 <strong>加载bean的注解列表</strong> 所注释，有则利用反射创建实例放入map中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描并加载所有的Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadBeans</span><span class="params">(String packageName)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断bean容器是否被加载过</span></span><br><span class="line">    <span class="keyword">if</span>(isLoaded())&#123;</span><br><span class="line">        log.warn(<span class="string">"Bean Container is already loaded"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提取包下的所有class对象</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.extractPackageClass(packageName);</span><br><span class="line">    <span class="keyword">if</span>(classSet==<span class="keyword">null</span>||classSet.isEmpty())&#123;</span><br><span class="line">        log.warn(<span class="string">"extract nothing from package:"</span>+packageName);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历classSet</span></span><br><span class="line">    <span class="keyword">for</span>(Class&lt;?&gt; clazz:classSet)&#123;</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;? extends Annotation&gt; annotation:BEAN_ANNOTATION)&#123;</span><br><span class="line">            <span class="comment">//如果类上面标记了上面的注解</span></span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(annotation))&#123;</span><br><span class="line">                <span class="comment">//将目标本身作为key，目标类的实例作为值，放入beanMap中</span></span><br><span class="line">                beanMap.put(clazz,ClassUtil.newInstance(clazz,<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加载bean的注解列表：即容器需要扫描那些注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载bean的注解列表:即容器需要扫描那些注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? extends Annotation&gt;&gt; BEAN_ANNOTATION</span><br><span class="line">        = Arrays.asList(Component<span class="class">.<span class="keyword">class</span>, <span class="title">Controller</span>.<span class="title">class</span>, <span class="title">Service</span>.<span class="title">class</span>, <span class="title">Repository</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>简单的一个UT：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BeanContainer beanContainer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在UT开始之前会进行初始化</span></span><br><span class="line"><span class="meta">@BeforeAll</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    beanContainer = BeanContainer.getInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeansTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Assertions.assertEquals(<span class="keyword">false</span>,beanContainer.isLoaded());</span><br><span class="line">    beanContainer.loadBeans(<span class="string">"com.imooc"</span>);</span><br><span class="line">    Assertions.assertEquals(<span class="number">6</span>,beanContainer.size());</span><br><span class="line">    Assertions.assertEquals(<span class="keyword">true</span>,beanContainer.isLoaded());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-3-容器的操作方式"><a href="#2-3-2-3-容器的操作方式" class="headerlink" title="2.3.2.3 容器的操作方式"></a>2.3.2.3 容器的操作方式</h4><p><strong>涉及容器的CRUD</strong>：</p><ul><li>增加、删除操作</li><li>根据Class获取对应实例</li><li>获取所有的Class和实例</li><li>通过注解来获取被注解标注的Class</li><li>通过超类获取对应的子类Class</li><li>获取容器载体保存的Class的数量</li></ul><h5 id="1-增加、删除操作"><a href="#1-增加、删除操作" class="headerlink" title="1.增加、删除操作"></a>1.增加、删除操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz Class对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean  Class对象对应的Bean实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  原有的Bean实例，没有则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">addBean</span><span class="params">(Class&lt;?&gt; clazz,Object bean)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanMap.put(clazz, bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz 需要删除的Class键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除的Bean实例，没有则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">removeBean</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanMap.remove(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-根据Class获取对应实例"><a href="#2-根据Class获取对应实例" class="headerlink" title="2.根据Class获取对应实例"></a>2.根据Class获取对应实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据Class对象获取Bean实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz Class对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Class对象对应的Bean实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanMap.get(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-获取所有的Class和实例"><a href="#3-获取所有的Class和实例" class="headerlink" title="3.获取所有的Class和实例"></a>3.获取所有的Class和实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bean容器里的所有Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClasses()&#123;</span><br><span class="line">    <span class="keyword">return</span> beanMap.keySet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bean容器的所有实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">getBeans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(beanMap.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-通过注解来获取被注解标注的Class"><a href="#4-通过注解来获取被注解标注的Class" class="headerlink" title="4.通过注解来获取被注解标注的Class"></a>4.通过注解来获取被注解标注的Class</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过注解来获取被注解标记过的Class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotation 注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Class集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClassesByAnnotation(Class&lt;? extends Annotation&gt; annotation)&#123;</span><br><span class="line">    <span class="comment">//1.获取beanMap的所有class对象</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; keySet = getClasses();</span><br><span class="line">    <span class="keyword">if</span>(keySet==<span class="keyword">null</span>||keySet.isEmpty())&#123;</span><br><span class="line">        log.warn(<span class="string">"keySet is Empty!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.通过注解筛选被注解标记的Class对象，并添加到classSet里</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Class&lt;?&gt; clazz:keySet)&#123;</span><br><span class="line">        <span class="comment">//类是否有相关注解标记</span></span><br><span class="line">        <span class="keyword">if</span>(clazz.isAnnotationPresent(annotation))&#123;</span><br><span class="line">            classSet.add(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classSet.size()&gt;<span class="number">0</span>?classSet:<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-通过超类获取对应的子类Class"><a href="#5-通过超类获取对应的子类Class" class="headerlink" title="5.通过超类获取对应的子类Class"></a>5.通过超类获取对应的子类Class</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过接口或者父类获取实现类或者子类的Class集合，不包括其本身</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaceOrClass 接口Class或者弗雷Class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Class集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClassesBySuper(Class&lt;?&gt; interfaceOrClass )&#123;</span><br><span class="line">    <span class="comment">//1.获取beanMap的所有class对象</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; keySet = getClasses();</span><br><span class="line">    <span class="keyword">if</span>(keySet==<span class="keyword">null</span>||keySet.isEmpty())&#123;</span><br><span class="line">        log.warn(<span class="string">"keySet is Empty!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.判断keySet里的元素是否是传入的接口或者类的子类，是则添加到classSet里</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Class&lt;?&gt; clazz:keySet)&#123;</span><br><span class="line">        <span class="comment">//判断keySet里的元素是否是传入的接口或者类的子类，并排除等于自己本身</span></span><br><span class="line">        <span class="keyword">if</span>(interfaceOrClass.isAssignableFrom(clazz)&amp;&amp;!clazz.equals(interfaceOrClass))&#123;</span><br><span class="line">            classSet.add(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classSet.size()&gt;<span class="number">0</span>?classSet:<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充：class1.isAssignableFrom(class2)函数</strong></p><ul><li>如果class1表示的类或接口与class2表示的<strong>类或接口相同</strong>，返回true</li><li>如果class1表示class2的<strong>超类或者超接口或者实现类</strong>（隔代也可以），返回true</li></ul><h5 id="6-获取容器载体保存的Class的数量"><a href="#6-获取容器载体保存的Class的数量" class="headerlink" title="6.获取容器载体保存的Class的数量"></a>6.获取容器载体保存的Class的数量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Bean实例的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanMap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2-3-实现容器&quot;&gt;&lt;a href=&quot;#2-3-实现容器&quot; class=&quot;headerlink&quot; title=&quot;2.3 实现容器&quot;&gt;&lt;/a&gt;2.3 实现容器&lt;/h3&gt;&lt;h4 id=&quot;2-3-1-枚举单例容器&quot;&gt;&lt;a href=&quot;#2-3-1-枚举单例容器&quot; cla
      
    
    </summary>
    
    
      <category term="spring框架篇" scheme="http://www.kongkongbai.com/categories/spring%E6%A1%86%E6%9E%B6%E7%AF%87/"/>
    
    
      <category term="spring框架" scheme="http://www.kongkongbai.com/tags/spring%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>spring自研框架IoC01创建注解并提取标记对象</title>
    <link href="http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC01/"/>
    <id>http://www.kongkongbai.com/spring%E6%A1%86%E6%9E%B6%E7%AF%87/%E8%87%AA%E7%A0%94springIoC01/</id>
    <published>2020-06-29T08:03:15.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-总结嗷"><a href="#0-总结嗷" class="headerlink" title="0.总结嗷"></a>0.总结嗷</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/1bfbdfddb9ee63e5a80eb160f1f270cb.jpeg" alt="0001"></p><h3 id="1-先来了解下IoC"><a href="#1-先来了解下IoC" class="headerlink" title="1.先来了解下IoC"></a>1.先来了解下IoC</h3><h4 id="1-1控制反转"><a href="#1-1控制反转" class="headerlink" title="1.1控制反转"></a>1.1控制反转</h4><ul><li>依托一个类似工厂的IoC容器</li><li>将对象的创建、依赖关系的管理以及生命周期交由IoC容器管理</li><li>降低系统在实现上的复杂性和耦合度、易于拓展、满足开闭原则</li></ul><h4 id="1-2依赖注入—实现控制反转"><a href="#1-2依赖注入—实现控制反转" class="headerlink" title="1.2依赖注入—实现控制反转"></a>1.2依赖注入—实现控制反转</h4><ul><li><strong>把底层类作为参数传递给上层类</strong>，实现上层对下层的“控制”</li></ul><p>主流的依赖注入方式：</p><ol><li>By 构造函数</li><li>By setter方法</li><li>By 接口</li><li>By 注解</li></ol><h4 id="1-3为什么要依托IoC容器？"><a href="#1-3为什么要依托IoC容器？" class="headerlink" title="1.3为什么要依托IoC容器？"></a>1.3为什么要依托IoC容器？</h4><ul><li>避免在各处使用new来创建类，并且可以做到统一维护</li><li>创建实例的时候不需要知道具体的细节（通过读取配置文件，<u><em>用反射的机制来完成创建</em>？</u>）</li><li><strong>反射+工厂模式</strong>的合体，满足开闭原则</li></ul><h4 id="1-4框架具备的最基本功能"><a href="#1-4框架具备的最基本功能" class="headerlink" title="1.4框架具备的最基本功能"></a>1.4框架具备的最基本功能</h4><ul><li>解析配置：项目中采用注解</li><li>定位与注册对象</li><li>注入对象：在用户需要使用对象时，返回正确对象</li><li>提供通用的工具类</li></ul><h3 id="2-IoC容器的实现"><a href="#2-IoC容器的实现" class="headerlink" title="2.IoC容器的实现"></a>2.IoC容器的实现</h3><p><strong>基本步骤：</strong></p><ol><li>创建注解</li><li>提取标记对象</li><li>实现容器（项目中采用键值对）</li><li>依赖注入</li></ol><h4 id="2-1-创建注解"><a href="#2-1-创建注解" class="headerlink" title="2.1 创建注解"></a>2.1 创建注解</h4><table><thead><tr><th></th><th>作用</th><th>作用对象</th><th>生命周期</th><th></th></tr></thead><tbody><tr><td>Controller</td><td>标记Controller层</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime(因为要通过反射创建对象)</td><td></td></tr><tr><td>Service</td><td>标记Service层</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr><tr><td>Repository</td><td>用于标记Dao层中的实现类</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr><tr><td>Component</td><td>用于标记通用的需要容器管理的组件</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr></tbody></table><h4 id="2-2-提取标记对象"><a href="#2-2-提取标记对象" class="headerlink" title="2.2 提取标记对象"></a>2.2 提取标记对象</h4><p><strong>实现思路：</strong></p><ol><li>指定范围，获取范围内的所有类</li><li>遍历所有类，获取被注解标记的类并加载进容器中</li></ol><h5 id="2-2-1-获取范围内的所有类"><a href="#2-2-1-获取范围内的所有类" class="headerlink" title="2.2.1 获取范围内的所有类"></a>2.2.1 获取范围内的所有类</h5><p><strong>实现思路：</strong></p><ol><li>获取类的加载器 –&gt;目的：获取项目发布的实际路径</li><li>通过类的加载器获取到加载的资源信息</li><li>依据不同的资源类型，采用不同的方式获取资源的集合</li></ol><p><strong>extractPackageClass(String packageName)</strong>：通过输入的包名，返回包下所有类的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包下的类集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 类集合Set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; extractPackageClass(String packageName)&#123;</span><br><span class="line">    <span class="comment">//1.获取类的加载器--&gt;目的：获取项目发布的实际路径</span></span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    <span class="comment">//2.通过类的加载器获取到加载的资源信息</span></span><br><span class="line">    <span class="comment">//getResource()方法 接受‘/’来隔开的名称，所以需要先将packageName中‘.'替换为’/‘</span></span><br><span class="line">    <span class="comment">//getResource()返回包含该类资源的url</span></span><br><span class="line">    URL url = classLoader.getResource(packageName.replace(<span class="string">"."</span>,<span class="string">"/"</span>));</span><br><span class="line">    <span class="keyword">if</span>(url==<span class="keyword">null</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">"unable to get anything from package:"</span>+packageName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.依据不同的资源类型，采用不同的方式获取资源的集合</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//过滤出文件类型的资源:我们需要获取的是协议为file，即本地的资源</span></span><br><span class="line">    <span class="keyword">if</span>(url.getProtocol().equalsIgnoreCase(FILE_PROTOCOL))&#123;</span><br><span class="line">        classSet = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        <span class="comment">//首先通过获取的path路径获取路径的File对象</span></span><br><span class="line">        File packageDirectory = <span class="keyword">new</span> File(url.getPath());</span><br><span class="line">        extractClassFile(classSet,packageDirectory,packageName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getClassLoader()</strong>：通过获取当前线程的类加载器获取加载该类的类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取ClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当前线程的内容加载器即该类的类加载器</span></span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：通过getResource（）返回的是URL数据，我们需要对返回的URL过滤，选出protocol为file类型（本地文件类型），并获取其中的Path路径信息，在提取该包路径中所有的Class类型文件</p><p><img src="https://pic.rmb.bdstatic.com/bjh/c4f8f523aae6d3d793ce6e0305142094.jpeg" alt="image-20200603194722808"></p><p><strong>extractClassFile(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName)</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归获取目标package里面的所有class文件（包括子package里面的class文件）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> emptyClassSet 装载目标类的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileSource 文件或者目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractClassFile</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件：当检索的不是文件夹时</span></span><br><span class="line">    <span class="keyword">if</span>(!fileSource.isDirectory()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果是一个文件夹，通过调用listFiles()获取这个文件夹中的所有文件或文件夹</span></span><br><span class="line">    <span class="comment">//并通过文件过滤器，留下文件夹类型，其余文件类型如果为class文件则直接加载</span></span><br><span class="line">    File[] files = fileSource.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果是文件夹类型，则通过</span></span><br><span class="line">            <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//获取文件的绝对值路径</span></span><br><span class="line">                String absoluteFilePath = file.getAbsolutePath();</span><br><span class="line">                <span class="keyword">if</span>(absoluteFilePath.endsWith(<span class="string">".class"</span>))&#123;</span><br><span class="line">                    <span class="comment">//若是class文件，则直接加载</span></span><br><span class="line">                    addToClassSet(absoluteFilePath);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToClassSet</span><span class="params">(String absoluteFilePath)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1.从class文件的绝对值路径里提取出包含了package的类名</span></span><br><span class="line">            <span class="comment">//比如：F:/simpleframework/simpleframwork/targt/classes/com/imooc/entity/dto/MainPage</span></span><br><span class="line">            <span class="comment">//提取为类名：com.imooc.entity.dto.MainPage</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//首先将绝对值路径中的分割符替换为“.”</span></span><br><span class="line">            absoluteFilePath = absoluteFilePath.replace(File.separator,<span class="string">"."</span>);</span><br><span class="line">                <span class="comment">//首先截取由包名开始的字段</span></span><br><span class="line">            String className = absoluteFilePath.substring(absoluteFilePath.indexOf(packageName));</span><br><span class="line">                <span class="comment">//之后再将最后“.”结尾的文件后缀去掉</span></span><br><span class="line">            className = className.substring(<span class="number">0</span>,className.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">            <span class="comment">//2.通过反射机制获取对应的Class对象并放入classSet中</span></span><br><span class="line">            Class targetCLass = loadClass(className);</span><br><span class="line">            emptyClassSet.add(targetCLass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            extractClassFile(emptyClassSet,file,packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>loadClass(className)</strong>：通过反射机制获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        log.error(<span class="string">"load class error:"</span>,e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单的做一个UT："><a href="#简单的做一个UT：" class="headerlink" title="简单的做一个UT："></a>简单的做一个UT：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtilTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"提取目标类方法：extractPackageClass"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extractPackageClassTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.extractPackageClass(<span class="string">"com.imooc.entity"</span>);</span><br><span class="line">        System.out.println(classSet);</span><br><span class="line">        Assertions.assertEquals(<span class="number">4</span>,classSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-总结嗷&quot;&gt;&lt;a href=&quot;#0-总结嗷&quot; class=&quot;headerlink&quot; title=&quot;0.总结嗷&quot;&gt;&lt;/a&gt;0.总结嗷&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://pic.rmb.bdstatic.com/bjh/1bfbdfddb9ee63e
      
    
    </summary>
    
    
      <category term="spring框架篇" scheme="http://www.kongkongbai.com/categories/spring%E6%A1%86%E6%9E%B6%E7%AF%87/"/>
    
    
      <category term="spring框架" scheme="http://www.kongkongbai.com/tags/spring%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>20.把数组排成最小的数</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer20/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer20/</id>
    <published>2020-06-27T09:36:31.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p>示例 1:</p><p>输入: [10,2]<br>输出: “102”<br>示例 2:</p><p>输入: [3,30,34,5,9]<br>输出: “3033459”</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：将数组进行”特殊的排序“</p><p>两个字符串 x，y；若拼接起来（x+y）&gt;（y+x）则 x&gt;y;反之小于</p><p>那么把数组进行重新排序，然后再按序拼接即可</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        strs[i] = String.valueOf(nums[i]);</span><br><span class="line">    <span class="comment">//使用内置的函数进行排序</span></span><br><span class="line">    Arrays.sort(strs,<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1,String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (o1+o2).compareTo(o2+o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//还有lamaba写法：Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));</span></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String s : strs)</span><br><span class="line">        res.append(s);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理论证明：</strong></p><p>为什么这样排个序就可以了呢？简单证明一下。根据算法，如果a &lt; b，那么a排在b前面，否则b排在a前面。可利用反证法，假设排成的最小数字为xxxxxx，并且至少存在一对字符串满足这个关系：a &gt; b，但是在组成的数字中a排在b前面。根据a和b出现的位置，分三种情况考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1）xxxxab，用ba代替ab可以得到xxxxba，这个数字是小于xxxxab，与假设矛盾。因此排成的最小数字中，不存在上述假设的关系。</span><br><span class="line"></span><br><span class="line">（2）abxxxx，用ba代替ab可以得到baxxxx，这个数字是小于abxxxx，与假设矛盾。因此排成的最小数字中，不存在上述假设的关系。</span><br><span class="line"></span><br><span class="line">（3）axxxxb，这一步证明麻烦了一点。可以将中间部分看成一个整体ayb，则有ay &lt; ya，yb &lt; by成立。将ay和by表示成10进制数字形式，则有下述关系式，这里a，y，b的位数分别为n，m，k。</span><br><span class="line"></span><br><span class="line">  关系1： ay &lt; ya &#x3D;&gt; a * 10^m + y &lt; y * 10^n + a &#x3D;&gt; a * 10^m - a &lt; y * 10^n - y &#x3D;&gt; a( 10^m - 1)&#x2F;( 10^n - 1) &lt; y</span><br><span class="line"></span><br><span class="line">  关系2： yb &lt; by &#x3D;&gt; y * 10^k + b &lt; b * 10^m + y &#x3D;&gt; y * 10^k - y &lt; b * 10^m - b &#x3D;&gt; y &lt; b( 10^m -1)&#x2F;( 10^k -1) </span><br><span class="line"></span><br><span class="line">  关系3： a( 10^m - 1)&#x2F;( 10^n - 1) &lt; y &lt; b( 10^m -1)&#x2F;( 10^k -1)  &#x3D;&gt; a&#x2F;( 10^n - 1)&lt; b&#x2F;( 10^k -1) &#x3D;&gt; a*10^k - a &lt; b * 10^n - b &#x3D;&gt;a*10^k + b &lt; b * 10^n + a &#x3D;&gt; a &lt; b</span><br><span class="line"></span><br><span class="line"> 这与假设a &gt; b矛盾。因此排成的最小数字中，不存在上述假设的关系。</span><br><span class="line"></span><br><span class="line"> 综上所述，得出假设不成立，从而得出结论：对于排成的最小数字，不存在满足下述关系的一对字符串：a &gt; b，但是在组成的数字中a出现在b的前面。从而得出算法是正确的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>19.数字序列中某一位的数字</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer19/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer19/</id>
    <published>2020-06-27T08:54:42.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：题目本身并不难，就是找规律</p><p>1.我们需要确定n对应的是哪个数中的数字：我们需要找到阈值，比如位数为1的最大值为9，位数为2的最大值为99，对应第n位数的阈值，即一位数9对应9，二位数99对应9+90*2（位数），依次三位数999对应9+90 *2+900 *3….</p><p>2.我们用（n-序列阈值）/位数+最大值即为对应的数</p><p>3.我们（n-序列阈值）%位数 可以找到其对应数的第几位数为我们所求</p><p><strong>4.Long.toString(num).charAt((n - 1) % digit) - ‘0’</strong> 使用字符串的方式来获取第几位数很关键！</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; count) &#123; <span class="comment">// 1.</span></span><br><span class="line">        n -= count;</span><br><span class="line">        digit += <span class="number">1</span>;</span><br><span class="line">        start *= <span class="number">10</span>;</span><br><span class="line">        count = digit * start * <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> num = start+(n-<span class="number">1</span>)/digit;</span><br><span class="line">    <span class="keyword">return</span> Long.toString(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>18.1到n整数中1出现的次数</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer18/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer18/</id>
    <published>2020-06-27T08:04:41.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：分析每个位数中1出现的次数</p><p><img src="https://pic.rmb.bdstatic.com/bjh/2ef71217b898f3efb7e4d9495042b6e1.png" alt="image-20200627160605354"></p><p><strong>分析当前位中1出现的次数：</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/fb310e4ca9b5c4f289685201c3d0aed8.png" alt="image-20200627160648387"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/59e5cae58ebee43372e873700e1efffd.png" alt="image-20200627160706406"></p><p><img src="https://pic.rmb.bdstatic.com/bjh/0e0a7ed724090ac12aa74f1f7df62ff4.png" alt="image-20200627160720755"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n/<span class="number">10</span>, cur = n%<span class="number">10</span>, low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(high!=<span class="number">0</span>||cur!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="number">0</span>)&#123;</span><br><span class="line">            res+=high*digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">            res+=high*digit+low+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res+=(high+<span class="number">1</span>)*digit;</span><br><span class="line">        &#125;</span><br><span class="line">        low += cur * digit;</span><br><span class="line">        cur = high % <span class="number">10</span>;</span><br><span class="line">        high /= <span class="number">10</span>;</span><br><span class="line">        digit *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。&lt;/p&gt;
&lt;p&gt;例如，输入12，1～12这些整数中包含1 
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>17.寻找中位数_纪念第一次独立做出Hard题</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer17/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer17/</id>
    <published>2020-06-08T03:23:03.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p><strong>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</strong><br><strong>double findMedian() - 返回目前所有元素的中位数。</strong><br>示例 1：</p><p>输入：<br><code>[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</code><br><code>[[],[1],[2],[],[3],[]]</code><br><code>输出：[null,null,null,1.50000,null,2.00000]</code><br>示例 2：</p><p>输入：<br><code>[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</code><br><code>[[],[2],[],[3],[]]</code><br><code>输出：[null,null,2.00000,null,2.50000]</code></p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：采用两个堆维护中间数</p><p>较小的前半段用大顶堆，维护前面数字的最大值；较大的后半段用小顶堆，维护后面数字的最小值</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; p1 ;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; p2 ;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//大顶堆</span></span><br><span class="line">        p1 = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2-o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//小顶堆</span></span><br><span class="line">        p2 = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//偶数个时进入一个数</span></span><br><span class="line">        <span class="keyword">if</span>(size%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                p1.offer(num);</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;p2.peek())&#123;</span><br><span class="line">                p1.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p1.offer(p2.poll());</span><br><span class="line">                p2.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//奇数个时进入一个数</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;p1.peek())&#123;</span><br><span class="line">                p2.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p2.offer(p1.poll());</span><br><span class="line">                p1.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(p1.peek()+p2.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)p1.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>16.字符串的排列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer15/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer15/</id>
    <published>2020-06-07T02:42:01.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：递归回溯，dfs</p><p>从第一个字符开始向下递归，保证每层中的字符都不相同</p><p>排列方案数量： 对于一个长度为 nn 的字符串（假设字符互不重复），其排列共有 n \times (n-1) \times (n-2) … \times 2 \times 1n×(n−1)×(n−2)…×2×1 种方案。</p><p><strong>排列方案的生成方法：</strong> 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 11 位字符（ nn 种情况）、再固定第 22 位字符（ n-1n−1 种情况）、… 、最后固定第 nn 位字符（ 11 种情况）。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/b2b90a527d7d8aeb1bc3981c3634c791.png" alt="Picture1.png"></p><p><strong>重复方案与剪枝：</strong> 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/668302f70a8e3d11936ab655f0738225.png" alt="Picture2.png"></p><p>每次递归时，创建一个HashSet来保存当前层次中 已递归过的字符，当遇到重复时直接跳过。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"><span class="keyword">char</span>[] c;</span><br><span class="line"><span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    c = s.toCharArray();</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==c.length-<span class="number">1</span>)&#123;</span><br><span class="line">        res.add(String.valueOf(c));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;c.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>;</span><br><span class="line">        set.add(c[i]);</span><br><span class="line">        swap(i,x);</span><br><span class="line">        dfs(x+<span class="number">1</span>);</span><br><span class="line">        swap(x,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = c[i];</span><br><span class="line">    c[i] = c[x];</span><br><span class="line">    c[x] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一个字符串，打印出该字符串中字符的所有排列。&lt;/p&gt;
&lt;p&gt;你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>15.二叉树的序列与反序列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer15/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer15/</id>
    <published>2020-06-05T03:06:51.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>示例: </p><p>你可以将以下二叉树：</p><pre><code>  1 / \2   3   / \  4   5</code></pre><p>序列化为 “[1,2,3,null,null,4,5]” or “[1,2,3,null,null,4,5,null,null,null,null]”</p><p>如何序列化可以自己进行设计</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p>思路一：通过层次遍历进行序列化，反序列化时利用队列（也是层次遍历的思想）</p><p>需要注意，字符串的处理细节</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.append(<span class="string">"null,"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(temp.val);</span><br><span class="line">            res.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(temp.left);</span><br><span class="line">        queue.add(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">    res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">    res.append(<span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="string">"[]"</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//将[x,x,x,x]数据提取为字符串数组</span></span><br><span class="line">    String[] subData = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>).split(<span class="string">","</span>);</span><br><span class="line">    <span class="comment">//将字符转换为数字</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(subData[<span class="number">0</span>]));</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(!subData[index].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">            temp.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(subData[index]));</span><br><span class="line">            queue.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(!subData[index].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">            temp.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(subData[index]));</span><br><span class="line">            queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;请实现两个函数，分别用来序列化和反序列化二叉树。&lt;/p&gt;
&lt;p&gt;示例: &lt;/p&gt;
&lt;p&gt;你可以将以下二叉树：&lt;/p&gt;
&lt;pr
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>14.搜索二叉树和双向链表</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer14/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer14/</id>
    <published>2020-06-04T11:15:40.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://pic.rmb.bdstatic.com/bjh/76591cecc79c0ca89776fd6f5b84e552.png" alt="img"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p> <img src="https://pic.rmb.bdstatic.com/bjh/632c68e4611d23601d1bd6b2836b1f93.png" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p><strong>思路一：中序遍历</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node head,tail;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    head.left = tail;</span><br><span class="line">    tail.right = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    <span class="keyword">if</span>(tail!=<span class="keyword">null</span>) tail.right = root;</span><br><span class="line">    <span class="keyword">else</span> head = root;</span><br><span class="line">    root.left = tail;</span><br><span class="line">    tail = root;</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&lt;/p
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>13.复杂链表的深拷贝</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer13/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer13/</id>
    <published>2020-06-04T07:25:38.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><p><strong>思路一：HashMap</strong></p><p>第一步 遍历链表，复制各个结点，用next串接链表，在这个过程中使用HashMap&lt;oldNode,newNode&gt;将新旧节点一一对应</p><p>第二步 再遍历链表，将原链表的random对应关系，使用HashMap映射到新链表中</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//创建HashMap集合</span></span><br><span class="line">    Node cur=head;</span><br><span class="line">    <span class="comment">//复制结点值</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//存储put:&lt;key,value1&gt;</span></span><br><span class="line">        map.put(cur,<span class="keyword">new</span> Node(cur.val)); <span class="comment">//顺序遍历，存储老结点和新结点(先存储新创建的结点值)</span></span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制结点指向</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//得到get:&lt;key&gt;.value2,3</span></span><br><span class="line">        map.get(cur).next = map.get(cur.next); <span class="comment">//新结点next指向同旧结点的next指向</span></span><br><span class="line">        map.get(cur).random = map.get(cur.random); <span class="comment">//新结点random指向同旧结点的random指向</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回复制的链表</span></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://www.kongkongbai.com/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/singleton/"/>
    <id>http://www.kongkongbai.com/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/singleton/</id>
    <published>2020-06-03T13:02:54.000Z</published>
    <updated>2020-08-29T10:54:54.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><h4 id="1-1定义与类型"><a href="#1-1定义与类型" class="headerlink" title="1.1定义与类型"></a>1.1定义与类型</h4><ul><li>定义：保证一个类仅有一个实例，并提供一个全局访问点</li><li>类型：创建型</li></ul><h4 id="1-2使用场景"><a href="#1-2使用场景" class="headerlink" title="1.2使用场景"></a>1.2使用场景</h4><ul><li>想确保任何情况下都绝对只有一个实例</li></ul><h4 id="1-3优点"><a href="#1-3优点" class="headerlink" title="1.3优点"></a>1.3优点</h4><ul><li>在内存中只有一个实例，减小了内存开销</li><li>可以避免对资源的多重占用</li><li>设置全局访问点，严格的控制访问</li></ul><h4 id="1-4缺点"><a href="#1-4缺点" class="headerlink" title="1.4缺点"></a>1.4缺点</h4><ul><li>没有接口，拓展困难</li></ul><h4 id="1-5重点问题"><a href="#1-5重点问题" class="headerlink" title="1.5重点问题"></a>1.5重点问题</h4><ul><li><strong>私有构造器</strong></li><li><strong>线程安全问题</strong></li><li><strong>延迟加载</strong></li><li><strong>序列化和反序列化安全问题</strong></li><li><strong>反射</strong></li></ul><h4 id="1-6设计模式的结合"><a href="#1-6设计模式的结合" class="headerlink" title="1.6设计模式的结合"></a>1.6设计模式的结合</h4><ul><li>单例模式和工厂模式</li><li>单例模式和享元模式</li></ul><h3 id="2-三种单例模式的实现"><a href="#2-三种单例模式的实现" class="headerlink" title="2.三种单例模式的实现"></a>2.三种单例模式的实现</h3><h4 id="2-1懒汉式—延迟加载"><a href="#2-1懒汉式—延迟加载" class="headerlink" title="2.1懒汉式—延迟加载"></a>2.1懒汉式—延迟加载</h4><p><a href="http://39.107.124.120/wp-content/uploads/2020/04/懒汉式单例模式01.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/59c3f5111f1eac97c359a378d470ae7a.png" alt="懒汉式单例模式01"></a></p><p><strong>线程安全问题：</strong></p><ul><li>当多个线程同时运行到lazySingleton = new LazySingleton（）时，会创建不同的对象</li></ul><h4 id="2-1-1改进"><a href="#2-1-1改进" class="headerlink" title="2.1.1改进"></a>2.1.1改进</h4><p><strong>1.对这个静态方法上同步锁（即对这个类对象加锁）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazySingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺陷：由于上了同步类锁，上锁范围比较大，影响性能</strong></p><p><strong>2.双重检查机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式的双重检测机制改进</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckingSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckingSingleton lazyDoubleCheckingSingleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckingSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckingSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyDoubleCheckingSingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckingSingleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazyDoubleCheckingSingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazyDoubleCheckingSingleton = <span class="keyword">new</span> LazyDoubleCheckingSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyDoubleCheckingSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解：第一重空值检测，保证必须时单例为空的情况才能进入；加同步类锁，保证在单例为空的情况下，同一时间只有一个线程能够进入创建实例的代码段；第二重空值检测，保证进入了第一重检测的线程中后面进入同步代码块的线程不会再重新创建实例。</p><p><strong>双重检测机制中存在问题—指令重排序</strong></p><p><a href="http://39.107.124.120/wp-content/uploads/2020/03/单例的双重检测实现01.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/cb621d85d6104e69887c99e3a14ea28a.jpeg" alt="单例的双重检测实现01"></a></p><p><strong>解决1：使用volatile修饰实例，禁止重排序</strong></p><h4 id="2-2-基于类初始化的延迟加载解决方案（静态内部类）"><a href="#2-2-基于类初始化的延迟加载解决方案（静态内部类）" class="headerlink" title="2.2.基于类初始化的延迟加载解决方案（静态内部类）"></a><strong>2.2.基于类初始化的延迟加载解决方案（静态内部类）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleton staticInnerClassSingleton = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.staticInnerClassSingleton ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://39.107.124.120/wp-content/uploads/2020/04/静态内部类实现单例原理.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/5cd78a5b2ab0425e23c534ea06e163e8.jpeg" alt="静态内部类实现单例原理"></a></p><p><strong>延迟加载</strong>原理：加载一个类时，<strong>其内部类不会同时被加载</strong>。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。</p><p><strong>线程安全</strong>原理：Class对象在被初始化时，会加上<strong>Class对象初始化锁。</strong></p><p><strong>什么时候Java的类会被立刻初始化？</strong></p><p>1）T是一个类，而且一个T类型的<strong>实例被创建。</strong></p><p>2）T是一个类，且T中声明的一个<strong>静态方法被调用</strong>。</p><p>3）T中声明的一个<strong>静态字段被赋值</strong>。</p><p>4）T中声明的一个<strong>静态字段被使用</strong>，而且这个字段<strong>不是一个常量字段</strong>。</p><p>5）T是一个顶级类（Top Level Class，见Java语言规范的§7.6），而且一个断言语句（assert关键字修饰的语句）嵌套在T内部被执行（不常见）</p><h4 id="2-3饿汉式-–类加载时完成实例化"><a href="#2-3饿汉式-–类加载时完成实例化" class="headerlink" title="2.3饿汉式 –类加载时完成实例化"></a>2.3饿汉式 –类加载时完成实例化</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/11370a710100ca2ce46d02d775510759.png" alt="饿汉式"></p><ul><li>没有延迟加载，在类被加载时，实例就已经被加载</li><li>优点：简单，没有线程安全问题</li><li>缺点：如果该单例没有被使用，会增加内存负担</li></ul><h3 id="3-单例模式的安全问题"><a href="#3-单例模式的安全问题" class="headerlink" title="3.单例模式的安全问题"></a>3.单例模式的安全问题</h3><h4 id="3-1序列化与反序列化问题"><a href="#3-1序列化与反序列化问题" class="headerlink" title="3.1序列化与反序列化问题"></a>3.1序列化与反序列化问题</h4><ul><li><h5 id="序列化与反序列化破坏单例模式"><a href="#序列化与反序列化破坏单例模式" class="headerlink" title="序列化与反序列化破坏单例模式"></a>序列化与反序列化破坏单例模式</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将instance对象序列化写入oos中</span></span><br><span class="line">HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singleton_file"</span>));</span><br><span class="line">oos.writeObject(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再将其反序列化生成对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"singleton_file"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">HungrySingleton newInstance = (HungrySingleton) ois.readObject();</span><br></pre></td></tr></table></figure><ul><li><h5 id="为什么这两个对象不相同？"><a href="#为什么这两个对象不相同？" class="headerlink" title="为什么这两个对象不相同？"></a>为什么这两个对象不相同？</h5></li></ul><p>1.反序列化创建对象时，先调用<strong>isInstantialble()</strong>是否能生成对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>如果对象为serializable/externalizable并且可以在运行时可序列化，则返回true，否则返回false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns true if represented class is serializable&#x2F;externalizable and can</span><br><span class="line"> * be instantiated by the serialization runtime--i.e., if it is</span><br><span class="line"> * externalizable and defines a public no-arg constructor, or if it is</span><br><span class="line"> * non-externalizable and its first non-serializable superclass defines an</span><br><span class="line"> * accessible no-arg constructor.  Otherwise, returns false.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean isInstantiable() &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    return (cons !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.由于单例类实现了serializable，则通过<strong>desc.newInstance()*</strong><u>反射</u><em>的方式创建实例，这也是为什么序列化与反序列化可以破坏单例模式（*</em>一个是正常单例对象，一个是反射创建的对象**）</p><p>3.之后会进行<strong>hasReadResolveMethod()</strong>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    desc.hasReadResolveMethod())</span><br></pre></td></tr></table></figure><p>当class对象为serializable or externalizable，且定义了<strong>readResolve</strong>方法时，返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns true if represented class is serializable or externalizable and</span><br><span class="line"> * defines a conformant readResolve method.  Otherwise, returns false.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean hasReadResolveMethod() &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    return (readResolveMethod !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如果单例对象包含了readResolve方法，则通过<strong>反射调用readResolve方法</strong>来生成对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object rep = desc.invokeReadResolve(obj);</span><br></pre></td></tr></table></figure><p><strong>这也提供了解决序列化和反序列化破坏单例的方法：</strong>在单例类中添加readResolve方法，返回单例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决序列化与反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2反射攻击及其解决方案"><a href="#3-2反射攻击及其解决方案" class="headerlink" title="3.2反射攻击及其解决方案"></a>3.2反射攻击及其解决方案</h4><h5 id="对于类加载时创建单例对象（饿汉式-和-静态内部类）：在静态构造器中禁止反射加载"><a href="#对于类加载时创建单例对象（饿汉式-和-静态内部类）：在静态构造器中禁止反射加载" class="headerlink" title="对于类加载时创建单例对象（饿汉式 和 静态内部类）：在静态构造器中禁止反射加载"></a>对于类加载时创建单例对象（饿汉式 和 静态内部类）：在静态构造器中禁止反射加载</h5><p>饿汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//解决反射破坏单例</span></span><br><span class="line">    <span class="keyword">if</span>(hungrySingleton!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//禁止反射创建单例对象</span></span><br><span class="line">    <span class="keyword">if</span>(InnerClass.staticInnerClassSingleton!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的"><a href="#对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的" class="headerlink" title="对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的"></a>对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先反射创建对象，在调用getInstance创建对象时，无法触发设置在构造器中的保护代码</span></span><br><span class="line">LazySingleton newinstance = (LazySingleton)constructor.newInstance();</span><br><span class="line">LazySingleton instance = LazySingleton.getInstance();</span><br></pre></td></tr></table></figure><h5 id="可以再加一层保护"><a href="#可以再加一层保护" class="headerlink" title="可以再加一层保护"></a>可以再加一层保护</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加flag参数来保证构造器只被调用一次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这也并不是完美的，还可以通过反射改变flag的值后，在通过反射创建对象</p><h3 id="4-枚举单例"><a href="#4-枚举单例" class="headerlink" title="4.枚举单例"></a>4.枚举单例</h3><p><strong><a href="https://blog.csdn.net/javazejian/article/details/71333103#%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">参考博客</a></strong></p><ul><li><strong>为什么推荐使用枚举单例？</strong></li></ul><p>因为枚举单例不受序列化以及反射的影响，同时枚举类的特性（在类加载时通过静态代码块实例化单例）也很符合单例模式的要求</p><ul><li><h5 id="枚举单例的创建"><a href="#枚举单例的创建" class="headerlink" title="枚举单例的创建"></a>枚举单例的创建</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式的枚举单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumStarvingSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumStarvingSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumStarvingSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ContainerHolder.HOLDER.instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> ContainerHolder&#123;</span><br><span class="line">        HOLDER;</span><br><span class="line">        <span class="keyword">private</span> EnumStarvingSingleton instance;</span><br><span class="line">        ContainerHolder()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> EnumStarvingSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h5 id="为什么枚举单例不受序列化的影响？"><a href="#为什么枚举单例不受序列化的影响？" class="headerlink" title="为什么枚举单例不受序列化的影响？"></a>为什么枚举单例不受序列化的影响？</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TC_ENUM:</span><br><span class="line">    <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br></pre></td></tr></table></figure><p><strong>readEnum方法：</strong>通过调用Enum.valueOf()方法来获取枚举类，<strong>而枚举类中每个枚举常量具有唯一的name，所以反序列化的枚举类是唯一的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name = readString(<span class="keyword">false</span>);<span class="comment">//获取枚举常量的名称</span></span><br><span class="line">Enum&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line"><span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);<span class="comment">//通过获取的名称获得枚举类</span></span><br></pre></td></tr></table></figure><ul><li><strong>为什么枚举单例不受反射的影响？</strong></li></ul><ol><li>如果按默认方式反射获取构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line"><span class="comment">//会提示没有此构造器</span></span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.NoSuchMethodException: com.creational.singleton.EnumInstance.&lt;init&gt;()</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举的构造方法，只能由编译器调用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果我们传入参数类型呢，会报非法参数的异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = EnumInstance<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">EnumInstance instance = (EnumInstance)constructor.newInstance(<span class="string">"hello"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span></span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">417</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>为什么呢？</li></ol><p>在newInstance方法中，会进行是否为枚举类的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本介绍&quot;&gt;&lt;a href=&quot;#1-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.基本介绍&quot;&gt;&lt;/a&gt;1.基本介绍&lt;/h3&gt;&lt;h4 id=&quot;1-1定义与类型&quot;&gt;&lt;a href=&quot;#1-1定义与类型&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.kongkongbai.com/categories/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.kongkongbai.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>spring自研框架-一-创建注解并提取目标对象</title>
    <link href="http://www.kongkongbai.com/Spring/SimpleframeWork01/"/>
    <id>http://www.kongkongbai.com/Spring/SimpleframeWork01/</id>
    <published>2020-06-03T12:10:20.000Z</published>
    <updated>2020-08-29T10:54:54.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-先来了解下IoC"><a href="#1-先来了解下IoC" class="headerlink" title="1.先来了解下IoC"></a>1.先来了解下IoC</h3><h4 id="1-1控制反转"><a href="#1-1控制反转" class="headerlink" title="1.1控制反转"></a>1.1控制反转</h4><ul><li>依托一个类似工厂的IoC容器</li><li>将对象的创建、依赖关系的管理以及生命周期交由IoC容器管理</li><li>降低系统在实现上的复杂性和耦合度、易于拓展、满足开闭原则</li></ul><h4 id="1-2依赖注入—实现控制反转"><a href="#1-2依赖注入—实现控制反转" class="headerlink" title="1.2依赖注入—实现控制反转"></a>1.2依赖注入—实现控制反转</h4><ul><li><strong>把底层类作为参数传递给上层类</strong>，实现上层对下层的“控制”</li></ul><p>主流的依赖注入方式：</p><ol><li>By 构造函数</li><li>By setter方法</li><li>By 接口</li><li>By 注解</li></ol><h4 id="1-3为什么要依托IoC容器？"><a href="#1-3为什么要依托IoC容器？" class="headerlink" title="1.3为什么要依托IoC容器？"></a>1.3为什么要依托IoC容器？</h4><ul><li>避免在各处使用new来创建类，并且可以做到统一维护</li><li>创建实例的时候不需要知道具体的细节（通过读取配置文件，<u><em>用反射的机制来完成创建</em>？</u>）</li><li><strong>反射+工厂模式</strong>的合体，满足开闭原则</li></ul><h4 id="1-4框架具备的最基本功能"><a href="#1-4框架具备的最基本功能" class="headerlink" title="1.4框架具备的最基本功能"></a>1.4框架具备的最基本功能</h4><ul><li>解析配置：项目中采用注解</li><li>定位与注册对象</li><li>注入对象：在用户需要使用对象时，返回正确对象</li><li>提供通用的工具类</li></ul><h3 id="2-IoC容器的实现"><a href="#2-IoC容器的实现" class="headerlink" title="2.IoC容器的实现"></a>2.IoC容器的实现</h3><p><strong>基本步骤：</strong></p><ol><li>创建注解</li><li>提取标记对象</li><li>实现容器（项目中采用键值对）</li><li>依赖注入</li></ol><h4 id="2-1-创建注解"><a href="#2-1-创建注解" class="headerlink" title="2.1 创建注解"></a>2.1 创建注解</h4><table><thead><tr><th></th><th>作用</th><th>作用对象</th><th>生命周期</th><th></th></tr></thead><tbody><tr><td>Controller</td><td>标记Controller层</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime(因为要通过反射创建对象)</td><td></td></tr><tr><td>Service</td><td>标记Service层</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr><tr><td>Repository</td><td>用于标记Dao层中的实现类</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr><tr><td>Component</td><td>用于标记通用的需要容器管理的组件</td><td>类(@Target(ElementType.TYPE))</td><td>Runtime</td><td></td></tr></tbody></table><h4 id="2-2-提取标记对象"><a href="#2-2-提取标记对象" class="headerlink" title="2.2 提取标记对象"></a>2.2 提取标记对象</h4><p><strong>实现思路：</strong></p><ol><li>指定范围，获取范围内的所有类</li><li>遍历所有类，获取被注解标记的类并加载进容器中</li></ol><h5 id="2-2-1-获取范围内的所有类"><a href="#2-2-1-获取范围内的所有类" class="headerlink" title="2.2.1 获取范围内的所有类"></a>2.2.1 获取范围内的所有类</h5><p><strong>实现思路：</strong></p><ol><li>获取类的加载器 –&gt;目的：获取项目发布的实际路径</li><li>通过类的加载器获取到加载的资源信息</li><li>依据不同的资源类型，采用不同的方式获取资源的集合</li></ol><p><strong>extractPackageClass(String packageName)</strong>：通过输入的包名，返回包下所有类的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包下的类集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 类集合Set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; extractPackageClass(String packageName)&#123;</span><br><span class="line">    <span class="comment">//1.获取类的加载器--&gt;目的：获取项目发布的实际路径</span></span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    <span class="comment">//2.通过类的加载器获取到加载的资源信息</span></span><br><span class="line">    <span class="comment">//getResource()方法 接受‘/’来隔开的名称，所以需要先将packageName中‘.'替换为’/‘</span></span><br><span class="line">    <span class="comment">//getResource()返回包含该类资源的url</span></span><br><span class="line">    URL url = classLoader.getResource(packageName.replace(<span class="string">"."</span>,<span class="string">"/"</span>));</span><br><span class="line">    <span class="keyword">if</span>(url==<span class="keyword">null</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">"unable to get anything from package:"</span>+packageName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.依据不同的资源类型，采用不同的方式获取资源的集合</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//过滤出文件类型的资源:我们需要获取的是协议为file，即本地的资源</span></span><br><span class="line">    <span class="keyword">if</span>(url.getProtocol().equalsIgnoreCase(FILE_PROTOCOL))&#123;</span><br><span class="line">        classSet = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        <span class="comment">//首先通过获取的path路径获取路径的File对象</span></span><br><span class="line">        File packageDirectory = <span class="keyword">new</span> File(url.getPath());</span><br><span class="line">        extractClassFile(classSet,packageDirectory,packageName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：通过getResource（）返回的是URL数据，我们需要对返回的URL过滤，选出protocol为file类型（本地文件类型），并获取其中的Path路径信息，在提取该包路径中所有的Class类型文件</p><p><img src="https://pic.rmb.bdstatic.com/bjh/c4f8f523aae6d3d793ce6e0305142094.jpeg" alt="image-20200603194722808"></p><p><strong>getClassLoader()</strong>：通过获取当前线程的类加载器获取加载该类的类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取ClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当前线程的内容加载器即该类的类加载器</span></span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>extractClassFile(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName)</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归获取目标package里面的所有class文件（包括子package里面的class文件）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> emptyClassSet 装载目标类的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileSource 文件或者目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractClassFile</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件：当检索的不是文件夹时</span></span><br><span class="line">    <span class="keyword">if</span>(!fileSource.isDirectory()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果是一个文件夹，通过调用listFiles()获取这个文件夹中的所有文件或文件夹</span></span><br><span class="line">    <span class="comment">//并通过文件过滤器，留下文件夹类型，其余文件类型如果为class文件则直接加载</span></span><br><span class="line">    File[] files = fileSource.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果是文件夹类型，则通过</span></span><br><span class="line">            <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//获取文件的绝对值路径</span></span><br><span class="line">                String absoluteFilePath = file.getAbsolutePath();</span><br><span class="line">                <span class="keyword">if</span>(absoluteFilePath.endsWith(<span class="string">".class"</span>))&#123;</span><br><span class="line">                    <span class="comment">//若是class文件，则直接加载</span></span><br><span class="line">                    addToClassSet(absoluteFilePath);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToClassSet</span><span class="params">(String absoluteFilePath)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1.从class文件的绝对值路径里提取出包含了package的类名</span></span><br><span class="line">            <span class="comment">//比如：F:/simpleframework/simpleframwork/targt/classes/com/imooc/entity/dto/MainPage</span></span><br><span class="line">            <span class="comment">//提取为类名：com.imooc.entity.dto.MainPage</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//首先将绝对值路径中的分割符替换为“.”</span></span><br><span class="line">            absoluteFilePath = absoluteFilePath.replace(File.separator,<span class="string">"."</span>);</span><br><span class="line">                <span class="comment">//首先截取由包名开始的字段</span></span><br><span class="line">            String className = absoluteFilePath.substring(absoluteFilePath.indexOf(packageName));</span><br><span class="line">                <span class="comment">//之后再将最后“.”结尾的文件后缀去掉</span></span><br><span class="line">            className = className.substring(<span class="number">0</span>,className.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">            <span class="comment">//2.通过反射机制获取对应的Class对象并放入classSet中</span></span><br><span class="line">            Class targetCLass = loadClass(className);</span><br><span class="line">            emptyClassSet.add(targetCLass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            extractClassFile(emptyClassSet,file,packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>loadClass(className)</strong>：通过反射机制获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        log.error(<span class="string">"load class error:"</span>,e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单的做一个UT："><a href="#简单的做一个UT：" class="headerlink" title="简单的做一个UT："></a>简单的做一个UT：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtilTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"提取目标类方法：extractPackageClass"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extractPackageClassTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.extractPackageClass(<span class="string">"com.imooc.entity"</span>);</span><br><span class="line">        System.out.println(classSet);</span><br><span class="line">        Assertions.assertEquals(<span class="number">4</span>,classSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-先来了解下IoC&quot;&gt;&lt;a href=&quot;#1-先来了解下IoC&quot; class=&quot;headerlink&quot; title=&quot;1.先来了解下IoC&quot;&gt;&lt;/a&gt;1.先来了解下IoC&lt;/h3&gt;&lt;h4 id=&quot;1-1控制反转&quot;&gt;&lt;a href=&quot;#1-1控制反转&quot; class
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://www.kongkongbai.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.kongkongbai.com/tags/Spring/"/>
    
      <category term="自研框架" scheme="http://www.kongkongbai.com/tags/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>12.二叉搜索树的后序遍历序列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer12/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer12/</id>
    <published>2020-06-03T03:07:00.000Z</published>
    <updated>2020-08-29T10:54:54.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><pre><code>     5   / \  2   6 / \1   3</code></pre><p>示例 1：</p><p>输入: [1,6,3,2,5]<br>输出: false<br>示例 2：</p><p>输入: [1,3,2,6,5]<br>输出: true</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：递归分治"><a href="#思路一：递归分治" class="headerlink" title="思路一：递归分治"></a>思路一：递归分治</h5><p>所有的子树都满足，左子树&lt;根&lt;右子树</p><p>如何判断哪里为左子树，哪里为右子树？最后一个结点为根，从开始出发，小于根的为左子树，其余为右子树</p><p>如何判断这棵树满足 左子树&lt;根&lt;右子树？从开始序列出发，保证刚刚分出来的左子树序列全部小于根，右子树序列全部大于根</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recue(postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recue</span><span class="params">(<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> p = i;</span><br><span class="line">    <span class="comment">//找到右子树的开始序号</span></span><br><span class="line">    <span class="keyword">while</span>(postorder[p]&lt;postorder[j]) p++;</span><br><span class="line">    <span class="keyword">int</span> m = p;</span><br><span class="line">    <span class="comment">//找到右子树的末尾序号</span></span><br><span class="line">    <span class="keyword">while</span>(postorder[p]&gt;postorder[j]) p++;</span><br><span class="line">    <span class="keyword">return</span> p==j&amp;&amp;recue(postorder,i,m-<span class="number">1</span>)&amp;&amp;recue(postorder,m,j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：单调辅助栈，还没看懂，基本思路是将后序遍历翻转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单调栈使用，单调递增的单调栈</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 表示上一个根节点的元素，这里可以把postorder的最后一个元素root看成无穷大节点的左孩子</span></span><br><span class="line">    <span class="keyword">int</span> pervElem = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 逆向遍历，就是翻转的先序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">// 左子树元素必须要小于递增栈被peek访问的元素，否则就不是二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> (postorder[i] &gt; pervElem)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; postorder[i] &lt; stack.peek())&#123;</span><br><span class="line">            <span class="comment">// 数组元素小于单调栈的元素了，表示往左子树走了，记录下上个根节点</span></span><br><span class="line">            <span class="comment">// 找到这个左子树对应的根节点，之前右子树全部弹出，不再记录，因为不可能在往根节点的右子树走了</span></span><br><span class="line">            pervElem = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个新元素入栈</span></span><br><span class="line">        stack.push(postorder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>11.栈的弹出序列</title>
    <link href="http://www.kongkongbai.com/Algorithm/Offer/Offer11/"/>
    <id>http://www.kongkongbai.com/Algorithm/Offer/Offer11/</id>
    <published>2020-06-01T08:09:18.000Z</published>
    <updated>2020-08-29T10:54:54.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><h3 id="2-解答"><a href="#2-解答" class="headerlink" title="2.解答"></a>2.解答</h3><h5 id="思路一：利用辅助栈模拟出入栈"><a href="#思路一：利用辅助栈模拟出入栈" class="headerlink" title="思路一：利用辅助栈模拟出入栈"></a>思路一：利用辅助栈模拟出入栈</h5><p>考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</p><p><strong>入栈操作</strong>： 按照压栈序列的顺序执行。<br><strong>出栈操作</strong>： 每次入栈后，<strong>循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立</strong>，将符合弹出序列顺序的栈顶元素全部弹出。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushed.length;i++)&#123;</span><br><span class="line">        s.push(pushed[i]);</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty()&amp;&amp;popped[index]==s.peek())&#123;</span><br><span class="line">            index++;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.isEmpty()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h3&gt;&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/categories/Algorithm/"/>
    
      <category term="Offer" scheme="http://www.kongkongbai.com/categories/Algorithm/Offer/"/>
    
    
      <category term="Algorithm" scheme="http://www.kongkongbai.com/tags/Algorithm/"/>
    
  </entry>
  
</feed>
