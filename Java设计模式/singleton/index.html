<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 单例模式 · 空空白的博客</title><meta name="description" content="单例模式 - kongkongbai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.kongkongbai.comundefined" title="空空白的博客"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="空空白的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/categories/" target="_self">CATEGORY</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/zenghuqiang" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/friends/" target="_self">FRIENDS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">单例模式</h1><div class="post-info">Jun 3, 2020<a class="tag-title" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a></div><div class="post-content"><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><h4 id="1-1定义与类型"><a href="#1-1定义与类型" class="headerlink" title="1.1定义与类型"></a>1.1定义与类型</h4><ul>
<li>定义：保证一个类仅有一个实例，并提供一个全局访问点</li>
<li>类型：创建型</li>
</ul>
<h4 id="1-2使用场景"><a href="#1-2使用场景" class="headerlink" title="1.2使用场景"></a>1.2使用场景</h4><ul>
<li>想确保任何情况下都绝对只有一个实例</li>
</ul>
<h4 id="1-3优点"><a href="#1-3优点" class="headerlink" title="1.3优点"></a>1.3优点</h4><ul>
<li>在内存中只有一个实例，减小了内存开销</li>
<li>可以避免对资源的多重占用</li>
<li>设置全局访问点，严格的控制访问</li>
</ul>
<h4 id="1-4缺点"><a href="#1-4缺点" class="headerlink" title="1.4缺点"></a>1.4缺点</h4><ul>
<li>没有接口，拓展困难</li>
</ul>
<h4 id="1-5重点问题"><a href="#1-5重点问题" class="headerlink" title="1.5重点问题"></a>1.5重点问题</h4><ul>
<li><strong>私有构造器</strong></li>
<li><strong>线程安全问题</strong></li>
<li><strong>延迟加载</strong></li>
<li><strong>序列化和反序列化安全问题</strong></li>
<li><strong>反射</strong></li>
</ul>
<h4 id="1-6设计模式的结合"><a href="#1-6设计模式的结合" class="headerlink" title="1.6设计模式的结合"></a>1.6设计模式的结合</h4><ul>
<li>单例模式和工厂模式</li>
<li>单例模式和享元模式</li>
</ul>
<h3 id="2-三种单例模式的实现"><a href="#2-三种单例模式的实现" class="headerlink" title="2.三种单例模式的实现"></a>2.三种单例模式的实现</h3><h4 id="2-1懒汉式—延迟加载"><a href="#2-1懒汉式—延迟加载" class="headerlink" title="2.1懒汉式—延迟加载"></a>2.1懒汉式—延迟加载</h4><p><a href="http://39.107.124.120/wp-content/uploads/2020/04/懒汉式单例模式01.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/59c3f5111f1eac97c359a378d470ae7a.png" alt="懒汉式单例模式01"></a></p>
<p><strong>线程安全问题：</strong></p>
<ul>
<li>当多个线程同时运行到lazySingleton = new LazySingleton（）时，会创建不同的对象</li>
</ul>
<h4 id="2-1-1改进"><a href="#2-1-1改进" class="headerlink" title="2.1.1改进"></a>2.1.1改进</h4><p><strong>1.对这个静态方法上同步锁（即对这个类对象加锁）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazySingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺陷：由于上了同步类锁，上锁范围比较大，影响性能</strong></p>
<p><strong>2.双重检查机制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式的双重检测机制改进</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckingSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckingSingleton lazyDoubleCheckingSingleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckingSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckingSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyDoubleCheckingSingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckingSingleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazyDoubleCheckingSingleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazyDoubleCheckingSingleton = <span class="keyword">new</span> LazyDoubleCheckingSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyDoubleCheckingSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解：第一重空值检测，保证必须时单例为空的情况才能进入；加同步类锁，保证在单例为空的情况下，同一时间只有一个线程能够进入创建实例的代码段；第二重空值检测，保证进入了第一重检测的线程中后面进入同步代码块的线程不会再重新创建实例。</p>
<p><strong>双重检测机制中存在问题—指令重排序</strong></p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/单例的双重检测实现01.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/cb621d85d6104e69887c99e3a14ea28a.jpeg" alt="单例的双重检测实现01"></a></p>
<p><strong>解决1：使用volatile修饰实例，禁止重排序</strong></p>
<h4 id="2-2-基于类初始化的延迟加载解决方案（静态内部类）"><a href="#2-2-基于类初始化的延迟加载解决方案（静态内部类）" class="headerlink" title="2.2.基于类初始化的延迟加载解决方案（静态内部类）"></a><strong>2.2.基于类初始化的延迟加载解决方案（静态内部类）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleton staticInnerClassSingleton = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.staticInnerClassSingleton ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://39.107.124.120/wp-content/uploads/2020/04/静态内部类实现单例原理.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/5cd78a5b2ab0425e23c534ea06e163e8.jpeg" alt="静态内部类实现单例原理"></a></p>
<p><strong>延迟加载</strong>原理：加载一个类时，<strong>其内部类不会同时被加载</strong>。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。</p>
<p><strong>线程安全</strong>原理：Class对象在被初始化时，会加上<strong>Class对象初始化锁。</strong></p>
<p><strong>什么时候Java的类会被立刻初始化？</strong></p>
<p>1）T是一个类，而且一个T类型的<strong>实例被创建。</strong></p>
<p>2）T是一个类，且T中声明的一个<strong>静态方法被调用</strong>。</p>
<p>3）T中声明的一个<strong>静态字段被赋值</strong>。</p>
<p>4）T中声明的一个<strong>静态字段被使用</strong>，而且这个字段<strong>不是一个常量字段</strong>。</p>
<p>5）T是一个顶级类（Top Level Class，见Java语言规范的§7.6），而且一个断言语句（assert关键字修饰的语句）嵌套在T内部被执行（不常见）</p>
<h4 id="2-3饿汉式-–类加载时完成实例化"><a href="#2-3饿汉式-–类加载时完成实例化" class="headerlink" title="2.3饿汉式 –类加载时完成实例化"></a>2.3饿汉式 –类加载时完成实例化</h4><p><img src="https://pic.rmb.bdstatic.com/bjh/11370a710100ca2ce46d02d775510759.png" alt="饿汉式"></p>
<ul>
<li>没有延迟加载，在类被加载时，实例就已经被加载</li>
<li>优点：简单，没有线程安全问题</li>
<li>缺点：如果该单例没有被使用，会增加内存负担</li>
</ul>
<h3 id="3-单例模式的安全问题"><a href="#3-单例模式的安全问题" class="headerlink" title="3.单例模式的安全问题"></a>3.单例模式的安全问题</h3><h4 id="3-1序列化与反序列化问题"><a href="#3-1序列化与反序列化问题" class="headerlink" title="3.1序列化与反序列化问题"></a>3.1序列化与反序列化问题</h4><ul>
<li><h5 id="序列化与反序列化破坏单例模式"><a href="#序列化与反序列化破坏单例模式" class="headerlink" title="序列化与反序列化破坏单例模式"></a>序列化与反序列化破坏单例模式</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将instance对象序列化写入oos中</span></span><br><span class="line">HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singleton_file"</span>));</span><br><span class="line">oos.writeObject(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再将其反序列化生成对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"singleton_file"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">HungrySingleton newInstance = (HungrySingleton) ois.readObject();</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="为什么这两个对象不相同？"><a href="#为什么这两个对象不相同？" class="headerlink" title="为什么这两个对象不相同？"></a>为什么这两个对象不相同？</h5></li>
</ul>
<p>1.反序列化创建对象时，先调用<strong>isInstantialble()</strong>是否能生成对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>如果对象为serializable/externalizable并且可以在运行时可序列化，则返回true，否则返回false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns true if represented class is serializable&#x2F;externalizable and can</span><br><span class="line"> * be instantiated by the serialization runtime--i.e., if it is</span><br><span class="line"> * externalizable and defines a public no-arg constructor, or if it is</span><br><span class="line"> * non-externalizable and its first non-serializable superclass defines an</span><br><span class="line"> * accessible no-arg constructor.  Otherwise, returns false.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean isInstantiable() &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    return (cons !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.由于单例类实现了serializable，则通过<strong>desc.newInstance()*</strong><u>反射</u><em>的方式创建实例，这也是为什么序列化与反序列化可以破坏单例模式（*</em>一个是正常单例对象，一个是反射创建的对象**）</p>
<p>3.之后会进行<strong>hasReadResolveMethod()</strong>判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    desc.hasReadResolveMethod())</span><br></pre></td></tr></table></figure>

<p>当class对象为serializable or externalizable，且定义了<strong>readResolve</strong>方法时，返回true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns true if represented class is serializable or externalizable and</span><br><span class="line"> * defines a conformant readResolve method.  Otherwise, returns false.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean hasReadResolveMethod() &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    return (readResolveMethod !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果单例对象包含了readResolve方法，则通过<strong>反射调用readResolve方法</strong>来生成对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object rep = desc.invokeReadResolve(obj);</span><br></pre></td></tr></table></figure>

<p><strong>这也提供了解决序列化和反序列化破坏单例的方法：</strong>在单例类中添加readResolve方法，返回单例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决序列化与反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2反射攻击及其解决方案"><a href="#3-2反射攻击及其解决方案" class="headerlink" title="3.2反射攻击及其解决方案"></a>3.2反射攻击及其解决方案</h4><h5 id="对于类加载时创建单例对象（饿汉式-和-静态内部类）：在静态构造器中禁止反射加载"><a href="#对于类加载时创建单例对象（饿汉式-和-静态内部类）：在静态构造器中禁止反射加载" class="headerlink" title="对于类加载时创建单例对象（饿汉式 和 静态内部类）：在静态构造器中禁止反射加载"></a>对于类加载时创建单例对象（饿汉式 和 静态内部类）：在静态构造器中禁止反射加载</h5><p>饿汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//解决反射破坏单例</span></span><br><span class="line">    <span class="keyword">if</span>(hungrySingleton!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//禁止反射创建单例对象</span></span><br><span class="line">    <span class="keyword">if</span>(InnerClass.staticInnerClassSingleton!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的"><a href="#对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的" class="headerlink" title="对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的"></a>对于懒汉式：光判断单例对象是否被创建来禁止反射是不够的</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先反射创建对象，在调用getInstance创建对象时，无法触发设置在构造器中的保护代码</span></span><br><span class="line">LazySingleton newinstance = (LazySingleton)constructor.newInstance();</span><br><span class="line">LazySingleton instance = LazySingleton.getInstance();</span><br></pre></td></tr></table></figure>

<h5 id="可以再加一层保护"><a href="#可以再加一层保护" class="headerlink" title="可以再加一层保护"></a>可以再加一层保护</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加flag参数来保证构造器只被调用一次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这也并不是完美的，还可以通过反射改变flag的值后，在通过反射创建对象</p>
<h3 id="4-枚举单例"><a href="#4-枚举单例" class="headerlink" title="4.枚举单例"></a>4.枚举单例</h3><p><strong><a href="https://blog.csdn.net/javazejian/article/details/71333103#%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">参考博客</a></strong></p>
<ul>
<li><strong>为什么推荐使用枚举单例？</strong></li>
</ul>
<p>因为枚举单例不受序列化以及反射的影响，同时枚举类的特性（在类加载时通过静态代码块实例化单例）也很符合单例模式的要求</p>
<ul>
<li><h5 id="枚举单例的创建"><a href="#枚举单例的创建" class="headerlink" title="枚举单例的创建"></a>枚举单例的创建</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingletonEnum <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="为什么枚举单例不受序列化的影响？"><a href="#为什么枚举单例不受序列化的影响？" class="headerlink" title="为什么枚举单例不受序列化的影响？"></a>为什么枚举单例不受序列化的影响？</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TC_ENUM:</span><br><span class="line">    <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br></pre></td></tr></table></figure>

<p><strong>readEnum方法：</strong>通过调用Enum.valueOf()方法来获取枚举类，<strong>而枚举类中每个枚举常量具有唯一的name，所以反序列化的枚举类是唯一的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name = readString(<span class="keyword">false</span>);<span class="comment">//获取枚举常量的名称</span></span><br><span class="line">Enum&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line"><span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);<span class="comment">//通过获取的名称获得枚举类</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>为什么枚举单例不受反射的影响？</strong></li>
</ul>
<ol>
<li>如果按默认方式反射获取构造器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line"><span class="comment">//会提示没有此构造器</span></span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.NoSuchMethodException: com.creational.singleton.EnumInstance.&lt;init&gt;()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举的构造方法，只能由编译器调用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果我们传入参数类型呢，会报非法参数的异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = EnumInstance<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">EnumInstance instance = (EnumInstance)constructor.newInstance(<span class="string">"hello"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span></span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">417</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>为什么呢？</li>
</ol>
<p><strong>在newInstance方法中，会进行是否为枚举类的判断</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br></pre></td></tr></table></figure>

</div></article></div></main><footer><div class="paginator"><a class="next" href="/Spring/SimpleframeWork01/">下一篇</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '2cdbd7aa1fe9fd30e3c5',     
    clientSecret: '0d12d75f0e1788ffc85796b5a38bdddbbf40c77d',     
    id: window.location.pathname,    
    repo: 'blog',     
    owner: 'zenghuqiang',     
    admin: 'zenghuqiang',     
})   
gitalk.render('gitalk-container')
</script><div class="copyright"><p>© 2020 <a href="http://www.kongkongbai.com">kongkongbai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/achjqz/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/github-gist.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/dockerfile.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/x86asm.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>