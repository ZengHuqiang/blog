<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 编程技巧篇 · 空空白的博客</title><meta name="description" content="编程技巧篇 - kongkongbai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.kongkongbai.com/atom.xml" title="空空白的博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="空空白的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/categories/" target="_self">CATEGORY</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/achjqz" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/friends/" target="_self">FRIENDS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">编程技巧篇</h1><div class="post-info">May 13, 2020<a class="tag-title" href="/tags/Algorithm/">#Algorithm</a></div><div class="post-content"><h2 id="1-数学归纳法"><a href="#1-数学归纳法" class="headerlink" title="1.数学归纳法"></a>1.数学归纳法</h2><p>数学归纳法时编码的依据</p>
<h4 id="用于证明断言对所有自然数成立"><a href="#用于证明断言对所有自然数成立" class="headerlink" title="用于证明断言对所有自然数成立"></a>用于证明断言对所有自然数成立</h4><ul>
<li>证明对于N=1成立</li>
<li>证明N&gt;1时：如果对于N-1成立，那么对于N成立</li>
</ul>
<h4 id="实例：证明1-2-3…-n-n-n-1-2成立"><a href="#实例：证明1-2-3…-n-n-n-1-2成立" class="headerlink" title="实例：证明1+2+3…+n = n(n+1)/2成立"></a>实例：证明1+2+3…+n = n(n+1)/2成立</h4><ul>
<li>当n=1时，1 = 1*2/2 成立</li>
<li>当n = n-1时，如果1+2+3+…+(n-1)=(n-1)n/2成立</li>
<li>那么1+2+3+…+n = 1+2+3+…+(n-1) + n</li>
<li>则1+2+3+…+n = (n-1)n/2 + n = n(n+1)/2成立</li>
<li>所以等式成立</li>
</ul>
<h4 id="类比编码：设计int-sum（int-n）：返回1-2-…-n的值"><a href="#类比编码：设计int-sum（int-n）：返回1-2-…-n的值" class="headerlink" title="类比编码：设计int sum（int n）：返回1+2+…+n的值"></a>类比编码：设计int sum（int n）：返回1+2+…+n的值</h4><ul>
<li>当n = 1时，if(n == 1) return 1;</li>
<li>当n = n-1时，else return sum(n-1) +n;</li>
</ul>
<h2 id="2-递归控制"><a href="#2-递归控制" class="headerlink" title="2.递归控制"></a>2.递归控制</h2><h4 id="如何证明递归函数正确执行？数学归纳法的数学语言–-gt-程序语言"><a href="#如何证明递归函数正确执行？数学归纳法的数学语言–-gt-程序语言" class="headerlink" title="如何证明递归函数正确执行？数学归纳法的数学语言–&gt;程序语言"></a>如何证明递归函数正确执行？数学归纳法的数学语言–&gt;程序语言</h4><h3 id="2-1递归书写方法"><a href="#2-1递归书写方法" class="headerlink" title="2.1递归书写方法"></a>2.1递归书写方法</h3><ul>
<li><strong>严格定义递归函数的作用</strong>，包括参数，返回值，Side-effect（附加影响，比如它改变的全局变量）</li>
<li><strong>先一般，后特殊</strong></li>
<li>每次调用必须<strong>缩小问题规模</strong></li>
<li>每次问题规模<strong>缩小程度必须为1</strong></li>
</ul>
<h3 id="2-2实战例题"><a href="#2-2实战例题" class="headerlink" title="2.2实战例题"></a>2.2实战例题</h3><h5 id="例1-链表创建-使用递归"><a href="#例1-链表创建-使用递归" class="headerlink" title="例1.链表创建(使用递归)"></a>例1.链表创建(使用递归)</h5><p>输入一个数组，将数组中的每个数据放在结点中，组成一个链表，并返回头指针</p>
<p>Node CreateLinkedList(List<Integer> values)</p>
<p>总体思路：将问题的规模减小1，从<strong>创建长度为n的链表，到创建长度为n-1的链表</strong>，然后将头结点与长度为n-1的链表组合起来。</p>
<p>创建结点类 ：</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/createLinkedList01.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/55eab06880ed96dc42d0b9e250ae91a7.png" alt="createLinkedList01"></a></p>
<p>函数算法：</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/createLinkedList02.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/e62f4bc39edc3cd4be1fff864771164f.png" alt="createLinkedList02"></a></p>
<h5 id="例2：链表反转"><a href="#例2：链表反转" class="headerlink" title="例2：链表反转"></a>例2：链表反转</h5><p>总体思路：将问题规模减少1，即<strong>从将长度为n的链表进行反转，转换为将长度为n-1的链表进行反转</strong>，再将第一个结点放置链表的尾部</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/reverseLinkedList01.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/b9c0007af0de086a2d2db16f3cabe501.png" alt="reverseLinkedList01"></a></p>
<p>实现过程：</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/reverseLinkedList02.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/dfcdcb61d650abe73a13bec789959dc7.png" alt="reverseLinkedList02"></a></p>
<h5 id="例三：列出所有的组合（较难理解）"><a href="#例三：列出所有的组合（较难理解）" class="headerlink" title="例三：列出所有的组合（较难理解）"></a>例三：列出所有的组合（较难理解）</h5><ul>
<li>input：【1，2，3，4】，2</li>
<li>output：【1，2】、【1，3】、【1，4】、【2，3】、【2，4】、【3，4】列出所有两个数字组成的组合</li>
</ul>
<p>总体思路：将问题规模减少为选择第一个元素：combainations（data[m-1] , n-1 ) 和 不选择第一个元素：combainations (data[m-1],n)。每次只选择第一个元素，当n为0时，表示全部元素已选完，输出存放的元素。</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/combinations01.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/d5448b1a780b3f703fa8ee99450b83e4.png" alt="combinations01"></a></p>
<h3 id="2-3递归的缺点"><a href="#2-3递归的缺点" class="headerlink" title="2.3递归的缺点"></a>2.3递归的缺点</h3><h5 id="Stack："><a href="#Stack：" class="headerlink" title="Stack："></a>Stack：</h5><ul>
<li>函数调用<strong>开销大</strong></li>
<li>Stack Overflow：递归过大时可能出现<strong>栈溢出</strong></li>
<li>问题规模大时，<strong>消耗资源过大</strong></li>
</ul>
<h2 id="3-循环控制"><a href="#3-循环控制" class="headerlink" title="3.循环控制"></a>3.循环控制</h2><h3 id="3-1写循环的基本思路"><a href="#3-1写循环的基本思路" class="headerlink" title="3.1写循环的基本思路"></a>3.1写循环的基本思路</h3><h5 id="数学归纳法运用于循环中"><a href="#数学归纳法运用于循环中" class="headerlink" title="数学归纳法运用于循环中"></a>数学归纳法运用于循环中</h5><h5 id="循环不变式（loop-invariant）、"><a href="#循环不变式（loop-invariant）、" class="headerlink" title="循环不变式（loop invariant）、"></a>循环不变式（loop invariant）、</h5><ul>
<li>是一句断言定义各变量所满足的条件</li>
</ul>
<p>var a,b;</p>
<p>while(){</p>
<p>}</p>
<p>a,b必须满足 <strong>进入循环之前满足条件，退出循环之后也要满足条件</strong></p>
<h5 id="循环书写方法："><a href="#循环书写方法：" class="headerlink" title="循环书写方法："></a>循环书写方法：</h5><ul>
<li>定义循环不变式，并在循环体每次结束后<strong>保持</strong>循环不变式</li>
<li>先<strong>一般</strong>，后<strong>特殊</strong></li>
<li>每次必须<strong>向前推进</strong>循环不变式中涉及的变量值</li>
<li>每次推进规模必须为1</li>
</ul>
<h3 id="3-2实战例题"><a href="#3-2实战例题" class="headerlink" title="3.2实战例题"></a>3.2实战例题</h3><h5 id="例一：链表反转"><a href="#例一：链表反转" class="headerlink" title="例一：链表反转"></a>例一：链表反转</h5><p>总体思路：定义循环不变式，定义两个变量：<strong>newHead指向已经成功反转链表的头指针，currentHead还未反转链表的头指针</strong>；通过不断推进两个变量（缩小规模），来完成所有结点反转</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/LinkedListReverser-loop01.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/c63b2bed9df072a4f7f1fab9f753c5d4.png" alt="LinkedListReverser-loop01"></a></p>
<h5 id="例二：链表中delete-if"><a href="#例二：链表中delete-if" class="headerlink" title="例二：链表中delete_if"></a>例二：链表中delete_if</h5><p>总体思路：定义循环不变式，定义一个变量：prevHead指向已经成功处理完成链表的尾结点；通过不断推进该变量直至其getNext()==null时，所有链表处理完毕。</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/deleteIfEquals-loop.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/1b4461c6363f84490cd5a24f9fc4736b.png" alt="deleteIfEquals-loop"></a></p>
<h2 id="3-3边界控制"><a href="#3-3边界控制" class="headerlink" title="3.3边界控制"></a>3.3边界控制</h2><h5 id="例一：二分查找"><a href="#例一：二分查找" class="headerlink" title="例一：二分查找"></a>例一：二分查找</h5><ul>
<li>在有序数组中查找元素K，返回K所在下标</li>
<li>binarySearch（【1，2，10，15，100】，15） == 3</li>
</ul>
<p>二分查找思路：</p>
<ul>
<li>规定查找的值可能在数组arr内下标区间a，b</li>
<li>计算区间a，b的中间点m</li>
<li>若k&lt;arr【m】，将区间缩小为a，m，继续二分查找</li>
<li>若k&gt;arr【m】，将区间缩小为m，b，继续二分查找</li>
</ul>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/binaruSearch01.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/7ea352c1c9eb805c61f435c2ce4c94b4.png" alt="binaruSearch01"></a></p>
<ul>
<li>b的边界控制可以为arr.length，也可以为arr.length-1(这里选择length)</li>
<li>考虑三种边界情况<br>//a == b : m = a –&gt;空集的时候<br>//b == a+1 : m = a –&gt;一个元素的时候<br>//b == a+2 : m = a+1 –&gt;多个元素的时候</li>
<li>int m = (a + b) / 2 可能会引起整数溢出</li>
</ul>
<h2 id="4-树"><a href="#4-树" class="headerlink" title="4.树"></a>4.树</h2><h3 id="4-1二叉树的遍历"><a href="#4-1二叉树的遍历" class="headerlink" title="4.1二叉树的遍历"></a>4.1二叉树的遍历</h3><ul>
<li>前序遍历：先遍历<strong>树根</strong>，然后前序遍历<strong>左子树</strong>，再前序遍历<strong>右子树</strong></li>
<li>中序遍历：先中序遍历<strong>左子树</strong>，然后中序遍历<strong>树根</strong>，再中序遍历<strong>右子树 【中序遍历的结果是顺序结果】</strong></li>
<li>后序遍历：先后序遍历<strong>左子树</strong>，然后后序遍历<strong>右子树</strong>，再后序遍历<strong>树根</strong></li>
</ul>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/树的遍历.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/782c366bb0f1702a81d19485d208332e.png" alt="树的遍历"></a></p>
<p>代码实现：</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/树的遍历02.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/57ccc49d5236d95048aa4f75cd81e9cc.png" alt="树的遍历02"></a></p>
<h3 id="4-2根据前序中序构造二叉树"><a href="#4-2根据前序中序构造二叉树" class="headerlink" title="4.2根据前序中序构造二叉树"></a>4.2根据前序中序构造二叉树</h3><p>总体思路：</p>
<ul>
<li>通过前序第一个结点–&gt;确定根节点</li>
<li>确认前序中左子树序号和中序中左子树序号，重新递归找左子树的根节点</li>
<li>右子树同上</li>
</ul>
<p>代码实现：</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/通过前中序寻找后序.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/f3c5b6cde772d1bb689a69c258b3d3a2.png" alt="通过前中序寻找后序"></a></p>
<p>细节：<strong>subString(startindex,endindex) –&gt;截取字符串 [startIndex，endIndex)</strong></p>
<h3 id="4-3寻找中序遍历的下一个结点"><a href="#4-3寻找中序遍历的下一个结点" class="headerlink" title="4.3寻找中序遍历的下一个结点"></a>4.3寻找中序遍历的下一个结点</h3><p>前提条件：这棵二叉树是双向的，子树存储了根的指针</p>
<p>总体实现：</p>
<ul>
<li>考虑N下一个结点为：左子树、根节点、右子树这三种情况</li>
<li>N的下一个结点不可能为左子树，因为中序遍历为：左根右</li>
<li>若N的右子树存在，返回右子树的<strong>第一个结点（中序遍历的第一个结点）</strong>；否则考虑根节点</li>
<li>若N的根节点存在，若N为根节点的左子树，则返回该根节点，否则一直往根节点走，指导是某个结点的左子树为止</li>
</ul>
<p>代码实现：</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/中序遍历的下一个结点.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/86432d98799804379f0c1a0566dc4ba8.png" alt="中序遍历的下一个结点"></a></p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/Algorithm/Offer/Offer01/">上一篇</a><a class="next" href="/Algorithm/Summary/interviewAlgorithm/">下一篇</a></div><div class="copyright"><p>© 2020 <a href="http://www.kongkongbai.com">kongkongbai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/achjqz/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/github-gist.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/dockerfile.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/x86asm.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>