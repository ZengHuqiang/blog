<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 二叉树 · 空空白的博客</title><meta name="description" content="二叉树 - kongkongbai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.kongkongbai.comundefined" title="空空白的博客"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="空空白的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/categories/" target="_self">CATEGORY</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/zenghuqiang" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/friends/" target="_self">FRIENDS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">二叉树</h1><div class="post-info">Aug 29, 2020<a class="tag-title" href="/tags/Algorithm/">#Algorithm</a></div><div class="post-content"><h3 id="1-二叉树的最大-最小深度"><a href="#1-二叉树的最大-最小深度" class="headerlink" title="1.二叉树的最大/最小深度"></a>1.二叉树的最大/最小深度</h3><p>深度都是考虑到<strong>叶子结点</strong>路径的长度</p>
<h4 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4><p>最大深度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最小深度：</p>
<p>相比于最大深度，计算最小深度时，需要考虑该节点是否存在左/右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.right==<span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.left)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-前、中、后序遍历的非递归方式"><a href="#2-前、中、后序遍历的非递归方式" class="headerlink" title="2.前、中、后序遍历的非递归方式"></a>2.前、中、后序遍历的非递归方式</h3><h4 id="递归写法（中序为例）："><a href="#递归写法（中序为例）：" class="headerlink" title="递归写法（中序为例）："></a>递归写法（中序为例）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归写法—利用栈"><a href="#非递归写法—利用栈" class="headerlink" title="非递归写法—利用栈"></a>非递归写法—利用栈</h4><h5 id="非递归前序遍历："><a href="#非递归前序遍历：" class="headerlink" title="非递归前序遍历："></a>非递归前序遍历：</h5><p>1.先将根节点入栈<br>2.访问根节点<br>3.如果根节点存在右孩子，则将右孩子入栈<br>4.如果根节点存在左孩子，则将左孩子入栈（<strong>注意：一定是右孩子先入栈，然后左孩子入栈</strong>）<br>5.重复2-4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        System.out.println(temp.val);</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>) stack.push(temp.right);</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>) stack.push(temp.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="非递归中序遍历："><a href="#非递归中序遍历：" class="headerlink" title="非递归中序遍历："></a>非递归中序遍历：</h5><p>1.先将根节点入栈<br>2.将当前节点的所有左孩子入栈，直到左孩子为空<br>3.访问栈顶元素，如果栈顶元素存在右孩子，则继续第2步<br>4.重复第2、3步，直到栈为空并且所有的节点都被访问</p>
<p>为了避免搜索左孩子时重复入栈，需要定义一个temp来记录已访问过的结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode temp = stack.peek();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">            stack.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        System.out.println(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = root.right;</span><br><span class="line">            stack.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="非递归后序遍历："><a href="#非递归后序遍历：" class="headerlink" title="非递归后序遍历："></a>非递归后序遍历：</h5><ol>
<li>根节点入栈，并定一个pre指针指向上一次访问的结点，初始为null</li>
<li>获取栈顶元素，如果栈顶元素的左右儿子同时为空或者pre指针为栈顶元素的左右儿子之一（即已被访问过的结点），则访问栈顶元素，并设置pre指针为刚刚的栈顶元素</li>
<li>如果栈顶元素不同时为空，则先判断右子树入栈，只有判断左子树入栈</li>
<li>循环直至栈为空</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">        	TreeNode cur = s.peek();</span><br><span class="line">        	<span class="comment">//如果当前栈顶结点的左右子树同时为空，或者它的左右子节点为已访问过的节点</span></span><br><span class="line">        	<span class="keyword">if</span>((cur.left==<span class="keyword">null</span>&amp;&amp;cur.right==<span class="keyword">null</span>)||(pre!=<span class="keyword">null</span>&amp;&amp;(pre==cur.left||pre==cur.right))) &#123;</span><br><span class="line">        		pre = s.pop();</span><br><span class="line">        		result.add(pre.val);</span><br><span class="line">        	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>) s.push(cur.right);</span><br><span class="line">        		<span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>) s.push(cur.left);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-二叉树翻转左右子树"><a href="#3-二叉树翻转左右子树" class="headerlink" title="3.二叉树翻转左右子树"></a>3.二叉树翻转左右子树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    reverse(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>||root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(root.left);</span><br><span class="line">    reverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-求完全二叉树的节点个数"><a href="#4-求完全二叉树的节点个数" class="headerlink" title="4.求完全二叉树的节点个数"></a>4.求完全二叉树的节点个数</h3><p><strong>思路一</strong>：使用递归，以<strong>求一个普通二叉树的方式</strong>来求完成二叉树的节点个数（没有运用完全二叉树的特性）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> countNodes(root.left)+countNodes(root.right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路二</strong>：完成二叉树的节点个数=非底层节点个数+底层节点个数；非底层节点个数 = 高度*2 - 1；所以我们只需要关注底层节点个数：</p>
<p><strong>深度计算</strong>：</p>
<p>最右边节点的深度即为相应深度</p>
<p><strong>最后一层的节点</strong><br>使用helper()函数计算最后一层节点的数量，传入的depth是下面最多还有的深度，所以depth == 0也就是深度遍历终止的地方，此处有节点返回1，无节点返回0。<br>关键的剪枝操作：当左子树的最后一层的节点没有充满时，直接返回左子树中的最后一层的节点数（右子树最后一层一定没有节点）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    TreeNode temp = root;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        depth++;</span><br><span class="line">        temp = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bottom = helper(depth,root);</span><br><span class="line">    <span class="keyword">return</span> bottom+(<span class="number">1</span>&lt;&lt;depth)-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> depth,TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = helper(depth-<span class="number">1</span>,root.left);</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="number">1</span> &lt;&lt; depth - <span class="number">1</span>) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> left+helper(depth-<span class="number">1</span>,root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>减号优先级高于&lt;&lt;，所以1&lt;&lt;depth-1是先做减法</p>
<h3 id="5-根节点到叶子结点和为sum的路径"><a href="#5-根节点到叶子结点和为sum的路径" class="headerlink" title="5.根节点到叶子结点和为sum的路径"></a>5.根节点到叶子结点和为sum的路径</h3><p><strong>思路：</strong>递归，向子节点进行递归，当节点为null时，结束递归；每次递归sum都减去当前节点的值，当sum为0且当前节点为叶子结点时则将此路径添加到结果集中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    getPath(root,sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPath</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sum = sum - root.val;</span><br><span class="line">    path.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">    &#125;</span><br><span class="line">    getPath(root.left,sum);</span><br><span class="line">    getPath(root.right,sum);</span><br><span class="line">    path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









</div></article></div></main><footer><div class="paginator"><a class="prev" href="/Algorithm/Summary/undefined/">上一篇</a><a class="next" href="/Algorithm/Offer/Offer21/">下一篇</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '2cdbd7aa1fe9fd30e3c5',     
    clientSecret: '0d12d75f0e1788ffc85796b5a38bdddbbf40c77d',     
    id: window.location.pathname,    
    repo: 'blog',     
    owner: 'zenghuqiang',     
    admin: 'zenghuqiang',     
})   
gitalk.render('gitalk-container')
</script><div class="copyright"><p>© 2020 <a href="http://www.kongkongbai.com">kongkongbai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/achjqz/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/github-gist.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/dockerfile.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/x86asm.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>