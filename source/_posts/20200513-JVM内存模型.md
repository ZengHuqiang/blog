---
title: JMM内存模型
date: 2020-05-13 13:53:50
tags: Java
categories: Java基础知识
urlname: JVM02
---

##### [参考博客](https://zhuanlan.zhihu.com/p/38348646)

### 1.内存简介

[![内存管理简介](https://pic.rmb.bdstatic.com/bjh/13297e07270c3f512206b4441cd8ca18.jpeg)

#### 1.1地址空间的划分

- 内核空间：是主要的操作系统空间和C运行时的空间
- 用户空间：Java实际运行时的空间

### 2.JVM内存结构

[![JVM内存模型](https://pic.rmb.bdstatic.com/bjh/0a5ec30149244284bfad8dc1a1539308.png)

#### 2.1线程私有

程序计数器、虚拟机栈、本地方法栈

##### 2.1.1程序计数器

- 当前线程所执行的字节码行号指示器（逻辑）
- 改变计数器的值来选取**下一条**需要执行的**字节码指令**
- 和线程是一对一的关系即“**线程私有**”
- 对Java方法计数，如果是Native方法则计数器值为Undefined
- 不会发生内存泄漏

##### 2.1.2虚拟机栈

- **Java方法**执行的内存模型
- 包含多个**栈帧**

[![JVM虚拟机栈](https://pic.rmb.bdstatic.com/bjh/6619bb90982e09ce9b228f0de026449e.jpeg)

1. 局部变量表：包含方法执行过程中的所有变量
2. 操作数栈：入栈、出栈、复制、交换、产生消费变量
3. 动态连接
4. 返回地址

**栈帧解析实例：**

[![JVM字节码例子](https://pic.rmb.bdstatic.com/bjh/09235bc215f539dabe975b79bed99ecb.png)

- descriptor：指示返回值类型
- flags：stack指示操作数栈的大小；locals指示局部变量总数；args_size指示传入参数个数

[![JVM栈帧解析](https://pic.rmb.bdstatic.com/bjh/067d44de5843a674a3cd32cdb7ce295f.jpeg)

- iconst_0：定义局部变量0压入操作数栈中
- istore_2：将操作数栈中的数**pop()**，放入局部变量表中的**第2个**位置
- iload_0：将局部变量表第0个参数**push()**到操作数栈中
- iadd：将操作数栈中数进行加法运算后压入栈中

**递归为什么会引发java.lang.StackOverflowError异常？**

- 递归过深，栈帧数超出虚拟栈的深度

##### 2.1.3本地方法栈

任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。然而当它调用的是本地方法时，**虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法**。

#### 2.2线程共享部分

MetaSpace、Java堆

##### 2.2.1MetaSpace

**元空间（MetaSpace）与永久代（PermGen）的区别**

- JDK8元空间替代了永久代
- 元空间和永久代都是用于**存储类的信息**
- **元空间使用本地内存，而永久代使用的是JVM的内存（主要区别）**

**Meta Space相比PermGen的优势：**

- 字符串常量池存在永久代中，容易出现性能问题和内存溢出
- 类和方法的信息大小难以确定，给永久代的大小指定带来困难
- 永久代会为GC带来不必要的复杂性
- 方便HotSpot与其他JVM如Jrockit的集成

##### 2.2.2Java堆（Heap）

- **对象实例**的分配区域
- **GC**管理的主要区域

### 3.面试问题

#### 3.1JVM三大性能调优参数 -Xms -Xmx -Xss的含义

- -Xss：规定每个线程**虚拟机栈**（堆栈）的大小
- -Xms：堆的**初始大小**
- -Xmx：堆能够达到的最大值（一般Xms和Xmx设置为一样，因为当堆不够用时进行拓展会引起内存抖动，影响程序运行时的稳定性）

#### 3.2Java内存模型中堆和栈的区别——内存分配策略

- 静态存储：**编译时确定**每个数据目标在运行时的存储空间需求
- 栈式存储：数据区需求在编译时未知，运行时模块入口前确定
- 堆式存储：编译时或运行时模块入口都无法确定，**动态分配**

**联系：**

- 引用对象、数组时，栈里定义变量保存堆中目标首地址

[![JVM栈与堆的联系](https://pic.rmb.bdstatic.com/bjh/438afc12bc4fbb64fcb2f2950dc49dfc.jpeg)

**区别：**

- 栈内存自动释放，堆内存需要GC
- 空间大小：栈空间比堆小
- 碎片相关：栈产生的碎片远小于堆
- 分配方式：栈支持静态和动态分配，而堆仅支持动态分配
- 效率：栈的效率比堆高，但灵活程度不够

#### 3.3不同JDK版本之间的intern()方法的区别——JDK6 vs JDK6之后

- **JDK6**：当调用intern方法时，如果字符串常量池先去已创建出该字符串对象，则返回池中的该字符串引用。否则，将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用。（**常量池受永久代的限制**）
- JDK6+：当调用intern方法时，如果字符串常量池先前已经创建出该字符串对象，则返回池中的该字符串的引用。否则，**如果该字符串对象已经存在于Java堆中，则将堆中对此对象的引用添加到字符串常量池中，并且返回该引用**；如果堆中不存在，则在池中创建该字符串并返回引用（**常量池受元空间限制**）

例子：

[![internDifference](https://pic.rmb.bdstatic.com/bjh/be73ab34fd6d6362b62894b3ee15a116.jpeg)

**JDK6结果：false  false**

JDK6:

[![JDK6的intern方法](https://pic.rmb.bdstatic.com/bjh/b4115c436c194fd6dc118c0715f4baf7.jpeg)

- String s = new String （“a”)：**将“a”字符串对象存放在常量池中，并在堆中new String创建了一个String对象的引用**，**s指向堆中的引用**；
- s2 = “a”：由于常量池中存在“a”，直接**返回常量池中的引用**
- 所以 s ！=s2

**JDK6+结果：false  true**

[![JDK6+的intern方法](https://pic.rmb.bdstatic.com/bjh/a261242b553dbd5f404ce1d1ef84181c.jpeg)

- s 与 s2判断与JDK6一致
- String s3 = new String(“a”) + new String (“a”):在**堆中创建“aa”对象，s3是堆中“aa”的引用
  
  **
- String s4 = “aa”：**由于Java堆存在“aa”字符串对象，先将该对象的引用添加到常量池中，然后返回常量池中的引用，此时两个对象的引用指向同一个对象**