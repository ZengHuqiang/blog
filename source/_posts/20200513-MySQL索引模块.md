---
title: MySQL索引模块
date: 2020-05-13 16:17:43
tags: 数据库
categories: MySQL
urlname: MySQLIndex
---

### 0.解决的问题

- 为什么要使用索引–>**因为索引可以避免全表扫描,提升查找数据的效率,**
- 什么样的信息能成为索引–>**主键、唯一键以及普通键等能够让数据存在区分的字段**
- 索引的数据结构–>**主流:B+树**
- 密集索引和稀疏索引的区别–>看下面解答

###  1.索引实现数据结构之间的比较

#### 1.1二叉查找树

查找效率一般情况较高，如果出现线性情况，效率会很低

#### 1.2B/B+树

**////引用**

### 3.2索引的实现

### 3.2.0相关数据结构的区别

- 二叉树与B/B+树的区别：二叉树**优化比较次数**，B/B+树**优化磁盘读写次数**
- B树与B+树的区别：B+树的数据都存放在叶子结点中
- B树和二叉搜索树（如红黑树）的区别：B树的每一个结点可以存放多个数据，这样可以优化硬盘的读写速度

### 3.2.1 B树

#### 定义（m阶B树）：

- 每个非叶子节点（除根外）至多有m个子结点，至少有向上取整【m/2】个子结点
- 根节点（如果不是叶子）至少有两个子结点
- 所有叶子节点在同一层
- 每个非根结点都包含k个元素（关键字），这里m/2≤k<m，这里m/2向下取整。

#### 实例：[如何插入/删除一颗B树](https://www.cnblogs.com/nullzx/p/8729425.html)

插入总体思路：先将元素直接按大小插入对应结点中，如果结点中元素数量>=m-1，则进行分裂（向上分裂）

删除总体思路：将元素删除后，如果结点中元素数量<m/2(向下取整)，则进行合并操作

### 3.2.2 B+树

#### 定义（m阶B+树，在B树上的优化）：

- 非叶子节点只做索引，不存储实际信息
- 所有的叶子结点中包含了全部元素的实际信息
- 所有叶子节点之间都有一个链指针

#### 实例：[如何插入/删除一颗B+树](https://www.cnblogs.com/nullzx/p/8729425.html)

总体思路与B树差不多，只是在分裂结点时，只是将关键元素复制一遍后分裂

### 3.2.3为什么B+Tree更适合用来做存储索引

- B+树的磁盘读写代价更低
- B+树的查询效率更加稳定
- B+树更有利于对数据库的扫描（叶子节点有链表指针链接）

**////////引用**

#### 1.3Hash索引

优点：

- **查找效率高**

缺点：

- 仅能满足“=”，**不能使用范围查询**
- 无法被用来避免数据的**排序操作**
- 不能利用部分索引键？查询（B+树支持）
- 不能避免表扫描？
- 遇到大量Hash值相等的情况后性能并不一定就会比B-Tree高

#### 1.4BitMap

### 2.索引分类

#### 2.1密集索引和稀疏索引的区别

- 密集索引文件中的每个搜索码都对应一个索引值(这就可以理解为**叶子结点不但需要保存键值,还保存位于同一行记录的其他列信息**。由于密集索引决定了表的物理排列顺序，**一个表只有一个物理排列顺序**，所以一个表只能创建一个密集索引)
- 稀疏索引文件只为索引码的某些值建立索引项(这可以理解为**叶子结点只保存了键位信息以及该行数据的地址**，有的稀疏索引只保存了键位信息主键)

#### 2.1MySQL中InnoDB和MyISAM索引的区别

**InnoDB:聚簇表分布**

- 只有一个**主键索引为密集索引,其他都是稀疏索引**

主键索引(密集索引)的选取

- 若一个主键被定义,该主键为密集索引
- 若没有主键被定义,该表的第一个唯一非空索引作为密集索引
- 若不满足以上条件,innoDB内部会生成一个隐藏主键(密集索引)
- 非主键索引存储 **相关键位与其对应的主键值**,之后查找主键索引来获取数据,**包含两次查找**

[![InnoDB的密集索引](https://pic.rmb.bdstatic.com/bjh/e8c6cc75986aa242aa67426e2d7dcd1c.jpeg)

非主键索引的两次查找

- 在**非主键稀疏索引**中查找出该行数据对应的主键
- 将该主键在**主键的密集索引**中查出整行的所有信息

**MyISAM:非聚簇分布**

- 无论主键还是什么都是**稀疏索引**

[![MyISAM稀疏索引](https://pic.rmb.bdstatic.com/bjh/c976d0ec57537f269f37b43d62e78bca.jpeg)

- 主键索引和辅助键索引没有区别,只是存储的键值不一样
- **索引和数据分开存储**
- 稀疏索引查找后会得到一个数据的存储地址,对应查询的结果

[![InnoDB和MyISAM文件存储区别](https://pic.rmb.bdstatic.com/bjh/0944b3986fd7e6ecfe21e80d7813965c.png)

### 3.如何定位并优化MySQL

**大致思路:**

- 根据**慢日志**定位慢查询sql
- 使用explain等工具分析sql
- 修改sql或者尽量让sql走索引

**慢日志:**

- 默认慢日志关闭,可以通过命令(改变参数)开启慢日志,慢日志会记录所有被认为是慢查询的记录
- 修改**long_query_time** : 超过这个阀值会被判定为慢查询
- **slow_queries** : 本次会话中的慢查询次数

**explain工具(在sql语句前加explain字段,用于分析sql语句):**

- type字段 : **index、all**表示全表查询,可能需要优化
- extra字段 :

[![extra字段](https://pic.rmb.bdstatic.com/bjh/80e1fcabc5972452605b4168769a1198.jpeg)

**修改优化sql:**

- 添加索引 : **alter table** person_info **add inedex** idx_name(name)
- 选择最优索引 : 有时候InnoDB优化器选择的索引方式不一定最优,需要根据实际情况调优

### 4.联合索引

**定义:对多个字段同时建立的索引**

#### 4.1最左匹配原则

- mysql会一直向右匹配直到**遇到范围查询**（>、<、beteewn、like）就**停止匹配**（比如建立索引(a,b,c,d),那么a=1 and b=2 and c>5 and d=6中d就用不到索引**,其中a和b的顺序是任意的**）

#### 4.2联合索引的最左匹配原则的成因

- mysql在创建联合索引时, 会先对最左边第一个字段进行排序, 在第一个字段排序的基础上再一次比较第二个字段以及后面的字段, 最后得到索引的数据
- 因此如果不从最左边的开始匹配, 就无法得到后面排序的结果

#### 4.3索引建立得越多越好吗?

- **数据量小**的表不需要建立索引，建立**会增加额外的索引开销**
- 数据变更需要维护索引，因此更多的索引意味着**更多的维护成本**
- 更多的索引意味着也需要**更多的空间**

 