---
title: MySQL锁模块
date: 2020-05-13 16:18:00
tags: 数据库
categories: MySQL
urlname: MySQLLock
---

#### 0.常见问题

- MyISAM与InnoDB关于锁方面的区别是什么？
- 数据库事务的四大特性
- 事务隔离级别以及各级别下的并发访问问题
- InnoDB可重复度隔离级别下如何避免幻读
- RC、RR级别下的InnoDB的非阻塞读如何实现

### 1.MyISAM与InnoDB关于锁方面的区别

[（参考博客）！非常详细](https://blog.csdn.net/xifeijian/article/details/20313977#t10)

- MyISAM默认用的表级锁，不支持行级锁
- InnoDB默认用的行级锁，也支持表级锁

#### 1.1MyISAM：表级锁

- 在对数据表进行select操作时，MyISAM会为该表加上一个表的**读锁（共享锁）**，在对数据表进行增删改时，MyISAM会为该表叫上一个**写锁（排它锁）**
- **两个锁互斥**，必须等另一种锁释放之后，才能加上不同种类的锁
- 读锁与读锁之间不互斥，**写锁与写锁之间会发生互斥**
- 显式的加锁：**lock table** XXX **read**(或者**write**) ；解锁：unlock table

#### 1.2InnoDB：索引时用行级锁，非索引时用表级锁

- 相对于表级锁，**行级锁只对操作的行数进行加锁操作**，其锁的行为与表级锁一致
- 显式的对某行加锁：在末尾加**lock in share mode（加读锁）**；**for update（加写锁）**

#### **如何加表锁？**

- MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。
- 在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。**这也正是MyISAM表不会出现死锁（Deadlock Free）的原因**。

#### 如何加行锁？

- 意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。

  ¡ 共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。

  ¡ 排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。

- **InnoDB行锁是通过给索引上的索引项加锁来实现的**，这一点MySQL与Oracle不同，后者是**通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！**

#### 1.3MyISAM适合的场景

- 频繁执行全表count语句（**MyISAM会保存一个表行数的变量**，InnoDB则需要重新扫描全表）
- 对数据进行增删改的频率不高，查询非常频繁（MyISAM增删改会涉及锁表操作，InnoDB只会锁行）
- 没有事务

#### 1.4InnoDB适合的场景

- 数据增删改查都相当频繁（InnoDB只锁行，避免很多操作的阻塞）
- 可靠性要求比较高，要求支持事务

#### 1.5数据库锁的分类

- 按锁的粒度划分，可分为**表级锁、行级锁、页级锁**（介于两者之间）
- 按锁级别划分，可分为**共享锁、排它锁**
- 按加锁方式划分，可分为**自动锁、显式锁**
- 按操作划分，可分为**DML锁**（对数据上的锁）、**DDL锁**（对表结构上的锁）
- 按使用方式划分，可分为**乐观锁**（通过加版本号或时间戳来实现，更新提交时检查版本号是否对应）**、悲观锁**