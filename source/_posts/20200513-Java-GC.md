---
title: Java GC
date: 2020-05-13 13:35:09
tags: Java
categories: Java基础知识
urlname: JavaGC
---

### 1判定对象为垃圾的算法

#### 1.1引用计数算法

- 通过判断对象的引用数量来决定对象是否被回收
- 每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1
- 任何引用计数为0的对象实例可以被当作垃圾回收

**优点：**

- 执行效率，程序受影响较小

**缺点：**

[![循环引用](https://pic.rmb.bdstatic.com/bjh/3eee5d59f1895edce031872447f929ca.jpeg)

- 无法检测处循环引用的情况，导致内存泄漏

##### 1.2可达性分析算法

- 通过判断对象的引用链是否可达来决定对象是否可以被回收

[![可达性分析算法](https://pic.rmb.bdstatic.com/bjh/c4d0e77240a4bcd87da19fac8e3a6bd3.jpeg)

**可以作为GC Root的对象：**

- 虚拟机栈中引用的对象（栈帧中的本地变量表）
- 方法区中的常量引用对象
- 方法区中的类静态属性引用的变量
- 本地方法栈中JNI（Native方法）的引用对象
- 活跃线程的引用对象

### 2.垃圾回收算法

#### 2.1标记-清除算法（Mark and Sweep）

- 标记：从根集合进行扫描，对存活的对象进行标记
- 清除：对对内存从头到尾进行 线性遍历，回收不可达对象内存

[![标记-清除算法](https://pic.rmb.bdstatic.com/bjh/46cb76f86a90dba0f60783a8bc5bfcea.jpeg)

**缺点：**

- 垃圾回收完后，内存**碎片化**（**产生大量不连续的对象**）

#### 2.2复制算法

- 分为**对象面**和**空闲面**
- 对象在对象面上创建
- 存活的对象被从对象面复制到空闲面
- 将对象面所有对象内存清楚

**优点：**

- 解决碎片化问题
- 顺序分配内存，简单高效
- 适用于**对象存活率低**的场景（一般运用于**新生代**）

#### 2.3标记-整理算法

- 标记：从根集合进行扫描，对存活的对象进行标记
- 整理：移动存活的对象，且**按照内存地址次序依次排列**，然后将**末端内存地址以后的内存全部回收**

**优点：**

- 解决碎片化问题
- 不用设置两块内存互换
- 使用于**存活率高**的场景（**老年代的回收**）

#### 2.4分代收集算法

- 垃圾回收算法的组合
- **按照对象生命周期的不同划分区域以采用不同的垃圾算法**

##### 2.4.1不同时期的分代算法

Jdk6、Jdk7：分为**年轻代、老年代、永久代**

Jdk8及以后：分为**年轻代、老年代**

### 3.Java内存GC

#### 3.1GC的分类

- Minor GC（用于**年轻代的复制算法**）
- Full GC

#### 3.2年轻代：尽可能的快速收集掉哪些生命周期短的对象

[![Java堆内存](https://pic.rmb.bdstatic.com/bjh/747ed25a31ad9bda64bac8e4821dc569.jpeg)

- Eden区
- 两个Survivor区（from区，to区）

**复制算法描述：**

- 新生代对象创建后放在Eden区
- **当Eden区的对象存满时，触发一次Minor GC**，将Eden区和一个Survivor区(from区)的存活对象复制放到另一个Survivor区(to区)并清除Eden和from区的所有对象
- **每进行一次Minor GC，该对象的年龄会加1，当年龄达到一定数（默认15）时，会转换到老年代**
- 当再次触发Minor GC时，之前的to区转换为from区，与Eden区一起将存活对象复制给另一个Survivor区

**对象如何晋升到老年代：**

- 经历一定次数的Minor后年龄达到一定数（默认15）
- **Survivor区（to区）中存放不下的对象**
- 新生产的**大对象(-XX:+PretenuerSizeThreshold)**

**常用的调优参数：**

- -XX:  **SurvivorRatio**：Eden和Survivor区的比值，默认8：1
- -XX：**NewRatio**：老年代和年轻代内存大小比例，默认2：1
- -XX：**MaxTenuringThreshold**：对象从年轻代晋升到老年代经过GC次数的最大阀值

#### 3.3老年代：存放生命周期较长的对象

- **标记-清理算法**
- **标记-整理算法**

**Full GC（所有的GC）和Major GC（一般指对老年的GC）**

- Full GC比Minor GC慢，但执行频率低

**触发Full GC的条件：**

- 老年代空间不足
- 永久代空间不足（Jdk8后元空间代替了永久代，条件不成立了）
- CMS GC时出现promotion failed(触发MinorGC时，新生代和永久代空间都不足)，concurrent mode failure(执行CMS GC时同时有对象要放入老年代中，此时老年代空间不足时)
- Minor GC晋升到老年代的平均大小大于老年代的剩余空间
- 调用System.gc()
- 使用RMI来进行RPC或管理的JDK应用，每小时执行依次Full GC

### 4.Java垃圾收集器

**Stop-the-World：**

- JVM由于要执行GC而停止了应用程序的执行
- 任何一种GC算法中都会发生
- 多数**GC优化**通过减少Stop-the-world发生的时间来提高程序性能

**Safepoint安全点：**

- 分析过程中对象引用关系不会发生变化的点
- 产生Safepoint的地方：方法调用、循环跳转、异常跳转等
- 安全点数量得适中

**JVM的运行模式**

- Server：启动速度慢，但一旦启动稳定后，运行速度比Client快，采用重量级虚拟机
- Client：启动速度快，采用轻量级虚拟机

#### 4.1新生代常见的垃圾收集器

**Serial收集器**（-XX:+UseSerialGC，**复制算法**）：

- **单线程收集**，进行垃圾收集时，必须暂停所有的工作线程
- 简单高效，Client模式下默认的年轻代收集器

**ParNew收集器**（-XX：+UseParNewGC，**复制算法**）：

- **多线程收集**，其余的行为、特点和Serial收集器一样
- 单核执行效率不如Serial，**再多核下执行才有优势**

**Parallel Scavenge收集器**（-XX：+UseParallelGC，**复制算法**）：

- 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
- 比起关注用户线程停顿时间，更关注系统的吞吐量
- 也是多线程收集，在多核下才有优势，Server模式下默认的年轻代收集器

#### 4.2老年代常见的垃圾收集器

**Serial Old收集器**（-XX：+UseSerialOldGC，**标记整理算法**）

- 单线程收集，进行垃圾收集时，必须暂停所有的工作线程
- 简单高效，Client模式下默认的老年代收集器

**Parallel Old收集器**（-XX：+UseParallelOldGC，**标记整理算法**）

- 多线程，吞吐量优先

**CMS收集器**（-XX：+UseConcMarkSweepGC，**标记清除算法**）

运行过程：

[![CMS收集器的工作过程](https://pic.rmb.bdstatic.com/bjh/0ec8990af36c57a1b5f581a9e45e6d94.jpeg)

- 初始化标记：stop-the-world，暂停工作线程，扫描到能与根对象直接关联的对象
- 并发标记：并发追踪标记，程序不会停顿
- 并发预清理：查找执行并发标记阶段从年轻代晋升为老年代的对象
- 重新标记：暂停虚拟机，扫描CMS堆中的剩余对象
- 并发清理：清理垃圾对象，程序不会停顿
- 并发重置：重置CMS收集的数据结构

**G1收集器**（-XX：+UseG1GC，**复制+标记-整理算法**）：运用于新生代和老年代

**特点：**

- 并发和并行
- 分代收集
- 空间整合
- 可预测的停顿

**Garbage First收集器工作机制：**

[![G](https://pic.rmb.bdstatic.com/bjh/0cea4c3a1951a6c71cc84e7cb552ac1e.jpeg)

- 将整个Java堆内存划分为多个**大小相等的\**Regi\**on**
- 年轻代和老年代不再物理隔离（不需要连续的内存空间）

### 5.GC相关的面试题

##### 5.1Object的finalize()方法的作用是否与C++的析构函数作用相同

- 与C++的析构函数不同，析构函数调用确定，而**finalize()是不确定的**
- 方法执行随时可能会被终止（低优先级）
- **给予对象最后一次重生的机会**
- 原理：java的垃圾回收器要宣告一个对象死亡需要经过**两次标记**过程，经过可达性分析后，如果**对象未被引用且重构了finalize()方法**，则会被放置于F-Queue队列中，并在稍后由JVM以**低优先级**来处理这个队列

##### 5.2Java中强引用、软引用、弱引用、虚引用有什么用

**强引用（Strong Reference）**：

- 最普遍的引用：Object obj = new Object()
- 宁可抛出OutOfMemoryError终止程序也不会回收具有强引用的对象
- 通过将**对象设置为null来弱化引用**，使其被回收

**软引用（Soft Reference）：**

String str = new String（”abc“）//强引用
SoftReference<String> softstr = new SoftReference<String>(str)//强引用转换为软引用

- 对象处在**有用但非必须**的状态
- 只有当**内存空间不足**时，GC会回收该引用的对象内存
- 可以用来实现**高速缓存**

**弱引用（Weak Reference）：**

String str = new String(“abc”)
WeakReference<String> weakStr = new WeakReference<String>(str)//弱引用

- **非必须**的对象，比软引用更弱一些
- GC时会被回收
- 被回收的概率也不大，因为GC线程优先级比较低
- 适用于**引用偶尔被使用且不影响垃圾收集的对象**

**虚引用（PhantomReference）：**

String str = new String (“abc”)
ReferenceQueue queue = new ReferenceQueue();
PhantomReference ref = new PhantomReference(str , queue);

- 不会决定对象的生命周期
- 任何时候都可能被垃圾收集器回收
- 跟踪对象被垃圾收集器回收的活动，起**哨兵作用**
- 必须和**引用队列ReferenceQueue**联合使用

**总结：**

- 强引用>软引用>弱引用>虚引用

[![JavaGC的引用](https://pic.rmb.bdstatic.com/bjh/35ef32949f717f8615d4e262400607ff.jpeg)

**引用队列：**

- 作用：这样可以**在外部对对象进行监控**，如果一个对象即将被回收，则可以通过ReferenceQueue来进行操作
- 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达
- 存储关联的且被GC的软引用，弱引用以及虚引用
- 原理：**一个对象如果被回收，其弱引用会被放置到引用队列中**

**应用：**

利用软引用和弱引用解决OOM问题：假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。

设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。