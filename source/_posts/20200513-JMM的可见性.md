---
title: JMM的可见性
date: 2020-05-13 13:53:21
tags: Java
categories: Java基础知识
urlname: JVM03
---

### 1.JMM简介

[![JMM内存模型](https://pic.rmb.bdstatic.com/bjh/88652a11e96b574703cf35d6ccbd54e3.png)

Java内存模型JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式

**理解：每个线程都有自己的工作内存，相互独立；线程之间的共享资源都是存储在主内存中，线程要想获取共享资源，只能获取其在主内存的副本，修改完后返回至主内存以达到通信的目的。**

#### 1.1JMM中的主内存

- 存储Java**实例对象**
- 包括**成员变量、类信息、常量、静态变量**等
- 属于**数据共享的区域**，多线程并发操作时会引发线程安全问题

#### 1.2JMM中的工作内存

- 存储当前方法的所有本地变量信息，本地变量对其他线程不可见
- 字节码行号指示器、Native方法信息
- 属于线程**私有数据区域**，不存在线程安全问题

#### 1.3JMM与Java内存区域的概念区别

- 内存区域是指 Jvm 运行时将数据分区域存储，**强调对内存空间的划分**
- 内存模型（Java Memory Model，简称 JMM ）是定义了**线程的工作内存和主内存之间的抽象关系**，即 **JMM 定义了 JVM 在计算机内存(RAM)中的工作方式**

#### 1.4主内存与工作内存的数据存储类型以及操作方式归纳

- 方法里的**基本数据类型**的本地变量将直接存储在工作内存的栈帧结构中
- **引用类型**的本地变量：引用存储在工作内存中，实例存储在主内存中
- **成员变量、static变量、类信息**均会被存储在主内存中
- 主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存

### 2.JMM如何解决可见性问题

#### 2.1指令重排序

JVM为了提高程序运行速度，一般都会对指令重排序

**条件：**

- 在单线程环境下不能改变程序运行的结果
- 存在数据依赖关系的不允许重排序
- 无法通过**happens-before原则**推导出来的，才能进行指令重排序

#### 2.2happens-before原则

A操作的结果需要对B操作可见，则A与B存在happens-before关系

[![happens-before八大原则](https://pic.rmb.bdstatic.com/bjh/fd3bef59c906055fc8146164b88fdc9e.jpeg)

**概念：**

- 如果两个操作不满足上述任意一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序
- 如果操作A happens-before 操作B，那么操作A在内存上所做的操作对操作B都是可见的

#### 2.3volatile：JVM提供的轻量级同步机制

- 保证被volatile修饰的共享变量对所有线程总是可见
- 禁止指令重排序优化

##### **2.3.1volatile的可见性理解：**

[![volatile的可见性01](https://pic.rmb.bdstatic.com/bjh/51163ab7384797c7d1da63721184fbed.jpeg)

value++的操作不具备原子性（**原子操作**：是指**不会被线程调度机制打断**的操作）：如果在读取value值和返回新value值期间另一个线程获取了久的value就会导致线程安全问题

为了避免线程安全问题，需要使用sychronized进行同步限制，此时就没有必要使用volatile修饰

[![volatile的可见性02](https://pic.rmb.bdstatic.com/bjh/fabbf9b6b8675562647a822510ffe010.jpeg)

shutdown的操作具备原子性，使用volatile修饰比较合理

##### 2.3.2volatile变量的机制

- 当写一个volatile变量时，JMM会把该线程对应的工作内存中共享变量值刷新到主内存中
- 当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效

##### 2.3.3volatile如何进行重排优化？

- **通过插入内存屏障指令禁止在内存屏障前后的指令执行重排优化**
- 强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本

**内存屏障**（Memory Barrier）

1. 保证特定操作的执行顺序
2. 保证某些变量的内存可见性

##### 2.3.4单例的双重检测实现中的问题

[![单例的双重检测实现01](https://pic.rmb.bdstatic.com/bjh/cb621d85d6104e69887c99e3a14ea28a.jpeg)

instance = new Singleton（）这一步中分为三个阶段，其中1、2阶段有可能会被重排优化而导致线程安全问题

解决：

private **volatile** static Singleton instance：给实例对象添加volatile字段，使之初始化过程不能被重排序

##### 2.3.5volatile与sychronized的区别

- volatile本质是告诉JVM当前变量在寄存器（工作内存）中的值时不确定的，需要从主存中读取；sychronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止
- volatile仅能使用在变量级别；sychronized则可以使用在变量、方法和类级别
- volatile仅能实现变量的修改可见性，不能保证原子性；而sychronized则可以保证变量修改的可变性和原子性
- volatile不会造成线程的阻塞；sychronized可能会造成线程的阻塞
- volatile标记的变量不会被编译器优化；sychronized标记的变量可以被编译器优化