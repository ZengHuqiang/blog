<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JMM内存模型 · 空空白的博客</title><meta name="description" content="JMM内存模型 - kongkongbai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.kongkongbai.comundefined" title="空空白的博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="空空白的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/categories/" target="_self">CATEGORY</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/zenghuqiang" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/friends/" target="_self">FRIENDS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JMM内存模型</h1><div class="post-info">May 13, 2020<a class="tag-title" href="/tags/Java/">#Java</a></div><div class="post-content"><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a><a href="https://zhuanlan.zhihu.com/p/38348646" target="_blank" rel="noopener">参考博客</a></h5><h3 id="1-内存简介"><a href="#1-内存简介" class="headerlink" title="1.内存简介"></a>1.内存简介</h3><p><a href="http://39.107.124.120/wp-content/uploads/2020/03/内存管理简介.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/13297e07270c3f512206b4441cd8ca18.jpeg" alt="内存管理简介"></a></p>
<h4 id="1-1地址空间的划分"><a href="#1-1地址空间的划分" class="headerlink" title="1.1地址空间的划分"></a>1.1地址空间的划分</h4><ul>
<li>内核空间：是主要的操作系统空间和C运行时的空间</li>
<li>用户空间：Java实际运行时的空间</li>
</ul>
<h3 id="2-JVM内存结构"><a href="#2-JVM内存结构" class="headerlink" title="2.JVM内存结构"></a>2.JVM内存结构</h3><p><a href="http://39.107.124.120/wp-content/uploads/2020/03/JVM内存模型.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/0a5ec30149244284bfad8dc1a1539308.png" alt="JVM内存模型"></a></p>
<h4 id="2-1线程私有"><a href="#2-1线程私有" class="headerlink" title="2.1线程私有"></a>2.1线程私有</h4><p>程序计数器、虚拟机栈、本地方法栈</p>
<h5 id="2-1-1程序计数器"><a href="#2-1-1程序计数器" class="headerlink" title="2.1.1程序计数器"></a>2.1.1程序计数器</h5><ul>
<li>当前线程所执行的字节码行号指示器（逻辑）</li>
<li>改变计数器的值来选取<strong>下一条</strong>需要执行的<strong>字节码指令</strong></li>
<li>和线程是一对一的关系即“<strong>线程私有</strong>”</li>
<li>对Java方法计数，如果是Native方法则计数器值为Undefined</li>
<li>不会发生内存泄漏</li>
</ul>
<h5 id="2-1-2虚拟机栈"><a href="#2-1-2虚拟机栈" class="headerlink" title="2.1.2虚拟机栈"></a>2.1.2虚拟机栈</h5><ul>
<li><strong>Java方法</strong>执行的内存模型</li>
<li>包含多个<strong>栈帧</strong></li>
</ul>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/JVM虚拟机栈.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/6619bb90982e09ce9b228f0de026449e.jpeg" alt="JVM虚拟机栈"></a></p>
<ol>
<li>局部变量表：包含方法执行过程中的所有变量</li>
<li>操作数栈：入栈、出栈、复制、交换、产生消费变量</li>
<li>动态连接</li>
<li>返回地址</li>
</ol>
<p><strong>栈帧解析实例：</strong></p>
<h3 id=""><a href="#" class="headerlink" title=""></a><a href="http://39.107.124.120/wp-content/uploads/2020/03/JVM字节码例子.png" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/09235bc215f539dabe975b79bed99ecb.png" alt="JVM字节码例子"></a></h3><ul>
<li>descriptor：指示返回值类型</li>
<li>flags：stack指示操作数栈的大小；locals指示局部变量总数；args_size指示传入参数个数</li>
</ul>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/JVM栈帧解析.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/067d44de5843a674a3cd32cdb7ce295f.jpeg" alt="JVM栈帧解析"></a></p>
<ul>
<li>iconst_0：定义局部变量0压入操作数栈中</li>
<li>istore_2：将操作数栈中的数<strong>pop()</strong>，放入局部变量表中的<strong>第2个</strong>位置</li>
<li>iload_0：将局部变量表第0个参数<strong>push()</strong>到操作数栈中</li>
<li>iadd：将操作数栈中数进行加法运算后压入栈中</li>
</ul>
<p><strong>递归为什么会引发java.lang.StackOverflowError异常？</strong></p>
<ul>
<li>递归过深，栈帧数超出虚拟栈的深度</li>
</ul>
<h5 id="2-1-3本地方法栈"><a href="#2-1-3本地方法栈" class="headerlink" title="2.1.3本地方法栈"></a>2.1.3本地方法栈</h5><p>任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。然而当它调用的是本地方法时，<strong>虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法</strong>。</p>
<h4 id="2-2线程共享部分"><a href="#2-2线程共享部分" class="headerlink" title="2.2线程共享部分"></a>2.2线程共享部分</h4><p>MetaSpace、Java堆</p>
<h5 id="2-2-1MetaSpace"><a href="#2-2-1MetaSpace" class="headerlink" title="2.2.1MetaSpace"></a>2.2.1MetaSpace</h5><p><strong>元空间（MetaSpace）与永久代（PermGen）的区别</strong></p>
<ul>
<li>JDK8元空间替代了永久代</li>
<li>元空间和永久代都是用于<strong>存储类的信息</strong></li>
<li><strong>元空间使用本地内存，而永久代使用的是JVM的内存（主要区别）</strong></li>
</ul>
<p><strong>Meta Space相比PermGen的优势：</strong></p>
<ul>
<li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li>
<li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li>
<li>永久代会为GC带来不必要的复杂性</li>
<li>方便HotSpot与其他JVM如Jrockit的集成</li>
</ul>
<h5 id="2-2-2Java堆（Heap）"><a href="#2-2-2Java堆（Heap）" class="headerlink" title="2.2.2Java堆（Heap）"></a>2.2.2Java堆（Heap）</h5><ul>
<li><strong>对象实例</strong>的分配区域</li>
<li><strong>GC</strong>管理的主要区域</li>
</ul>
<h3 id="3-面试问题"><a href="#3-面试问题" class="headerlink" title="3.面试问题"></a>3.面试问题</h3><h4 id="3-1JVM三大性能调优参数-Xms-Xmx-Xss的含义"><a href="#3-1JVM三大性能调优参数-Xms-Xmx-Xss的含义" class="headerlink" title="3.1JVM三大性能调优参数 -Xms -Xmx -Xss的含义"></a>3.1JVM三大性能调优参数 -Xms -Xmx -Xss的含义</h4><ul>
<li>-Xss：规定每个线程<strong>虚拟机栈</strong>（堆栈）的大小</li>
<li>-Xms：堆的<strong>初始大小</strong></li>
<li>-Xmx：堆能够达到的最大值（一般Xms和Xmx设置为一样，因为当堆不够用时进行拓展会引起内存抖动，影响程序运行时的稳定性）</li>
</ul>
<h4 id="3-2Java内存模型中堆和栈的区别——内存分配策略"><a href="#3-2Java内存模型中堆和栈的区别——内存分配策略" class="headerlink" title="3.2Java内存模型中堆和栈的区别——内存分配策略"></a>3.2Java内存模型中堆和栈的区别——内存分配策略</h4><ul>
<li>静态存储：<strong>编译时确定</strong>每个数据目标在运行时的存储空间需求</li>
<li>栈式存储：数据区需求在编译时未知，运行时模块入口前确定</li>
<li>堆式存储：编译时或运行时模块入口都无法确定，<strong>动态分配</strong></li>
</ul>
<p><strong>联系：</strong></p>
<ul>
<li>引用对象、数组时，栈里定义变量保存堆中目标首地址</li>
</ul>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/JVM栈与堆的联系.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/438afc12bc4fbb64fcb2f2950dc49dfc.jpeg" alt="JVM栈与堆的联系"></a></p>
<p><strong>区别：</strong></p>
<ul>
<li>栈内存自动释放，堆内存需要GC</li>
<li>空间大小：栈空间比堆小</li>
<li>碎片相关：栈产生的碎片远小于堆</li>
<li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li>
<li>效率：栈的效率比堆高，但灵活程度不够</li>
</ul>
<h4 id="3-3不同JDK版本之间的intern-方法的区别——JDK6-vs-JDK6之后"><a href="#3-3不同JDK版本之间的intern-方法的区别——JDK6-vs-JDK6之后" class="headerlink" title="3.3不同JDK版本之间的intern()方法的区别——JDK6 vs JDK6之后"></a>3.3不同JDK版本之间的intern()方法的区别——JDK6 vs JDK6之后</h4><ul>
<li><strong>JDK6</strong>：当调用intern方法时，如果字符串常量池先去已创建出该字符串对象，则返回池中的该字符串引用。否则，将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用。（<strong>常量池受永久代的限制</strong>）</li>
<li>JDK6+：当调用intern方法时，如果字符串常量池先前已经创建出该字符串对象，则返回池中的该字符串的引用。否则，<strong>如果该字符串对象已经存在于Java堆中，则将堆中对此对象的引用添加到字符串常量池中，并且返回该引用</strong>；如果堆中不存在，则在池中创建该字符串并返回引用（<strong>常量池受元空间限制</strong>）</li>
</ul>
<p>例子：</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/internDifference.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/be73ab34fd6d6362b62894b3ee15a116.jpeg" alt="internDifference"></a></p>
<p><strong>JDK6结果：false  false</strong></p>
<p>JDK6:</p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/JDK6的intern方法.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/b4115c436c194fd6dc118c0715f4baf7.jpeg" alt="JDK6的intern方法"></a></p>
<ul>
<li>String s = new String （“a”)：<strong>将“a”字符串对象存放在常量池中，并在堆中new String创建了一个String对象的引用</strong>，<strong>s指向堆中的引用</strong>；</li>
<li>s2 = “a”：由于常量池中存在“a”，直接<strong>返回常量池中的引用</strong></li>
<li>所以 s ！=s2</li>
</ul>
<p><strong>JDK6+结果：false  true</strong></p>
<p><a href="http://39.107.124.120/wp-content/uploads/2020/03/JDK6-的intern方法.jpg" target="_blank" rel="noopener"><img src="https://pic.rmb.bdstatic.com/bjh/other/a261242b553dbd5f404ce1d1ef84181c.jpeg" alt="JDK6+的intern方法"></a></p>
<ul>
<li><p>s 与 s2判断与JDK6一致</p>
</li>
<li><p>String s3 = new String(“a”) + new String (“a”):在**堆中创建“aa”对象，s3是堆中“aa”的引用</p>
<p>**</p>
</li>
<li><p>String s4 = “aa”：<strong>由于Java堆存在“aa”字符串对象，先将该对象的引用添加到常量池中，然后返回常量池中的引用，此时两个对象的引用指向同一个对象</strong></p>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/Algorithm/Summary/sortAlgorithm/">上一篇</a><a class="next" href="/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM01/">下一篇</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '2cdbd7aa1fe9fd30e3c5',     
    clientSecret: '0d12d75f0e1788ffc85796b5a38bdddbbf40c77d',     
    id: window.location.pathname,    
    repo: 'blog',     
    owner: 'zenghuqiang',     
    admin: 'zenghuqiang',     
})   
gitalk.render('gitalk-container')
</script><div class="copyright"><p>© 2020 <a href="http://www.kongkongbai.com">kongkongbai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/achjqz/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/github-gist.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/dockerfile.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/x86asm.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>