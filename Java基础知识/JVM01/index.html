<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JVM类加载原理 · 空空白的博客</title><meta name="description" content="JVM类加载原理 - kongkongbai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.kongkongbai.comundefined" title="空空白的博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="空空白的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/categories/" target="_self">CATEGORY</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/zenghuqiang" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/friends/" target="_self">FRIENDS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JVM类加载原理</h1><div class="post-info">May 13, 2020<a class="tag-title" href="/tags/Java/">#Java</a></div><div class="post-content"><h3 id="1-谈谈对Java的理解"><a href="#1-谈谈对Java的理解" class="headerlink" title="1.谈谈对Java的理解"></a>1.谈谈对Java的理解</h3><ul>
<li>平台无关性</li>
<li>GC</li>
<li>语言特性</li>
<li>面向对象</li>
<li>类库</li>
<li>异常处理</li>
</ul>
<h3 id="2-java如何实现平台无关性"><a href="#2-java如何实现平台无关性" class="headerlink" title="2.java如何实现平台无关性"></a>2.java如何实现平台无关性</h3><ul>
<li><strong>java的编译过程</strong></li>
</ul>
<p>[<img src="https://pic.rmb.bdstatic.com/bjh/4f9786d8230886631faf4c083dd52d55.png" alt="Java编译过程"></p>
<p>Java源码首先呗编译为字节码，再有不同平台的<strong>JVM进行解析</strong>，Java语言在不同的平台上运行时，不需要进行重新编译，Java虚拟机在执行字节码的时候，把<strong>字节码转换成具体平台上的机器指令</strong></p>
<ul>
<li><strong>Java字节码</strong></li>
</ul>
<p>[<img src="https://pic.rmb.bdstatic.com/bjh/ae2f19b9049a3ba5d7c7d67fb16ab1b2.png" alt="Java字节码"></p>
<ol>
<li>查看字节码：先编译（javac）、然后javap -c 查看字节码</li>
</ol>
<ul>
<li><strong>为什么JVM不直接将源码解析成机器码去执行</strong></li>
</ul>
<ol>
<li>如果直接转换成机器码，每次在解析源码的时候都要对源码进行编译检查（<strong>引入中间字节码，可以多次执行程序，而不需要校验</strong>）</li>
<li>兼容性：也可以将别的语言（比如Ruby）解析成字节码</li>
</ol>
<h3 id="3-JVM如何加载-class文件"><a href="#3-JVM如何加载-class文件" class="headerlink" title="3.JVM如何加载.class文件"></a>3.JVM如何加载.class文件</h3><h4 id="3-1JVM架构"><a href="#3-1JVM架构" class="headerlink" title="3.1JVM架构"></a>3.1JVM架构</h4><p>[<img src="https://pic.rmb.bdstatic.com/bjh/80b88a69f2fbf420805095eca1140b7f.png" alt="JVM结构"></p>
<ul>
<li>Class Loader：依据特定格式，<strong>加载class文件</strong>到内存</li>
<li>Execution Engine：对<strong>命令</strong>进行<strong>解析</strong></li>
<li>Native Interface：融合不同开发语言的原生库为Java所用</li>
<li>Runtime Data Area：JVM内存空间结构模型</li>
</ul>
<h3 id="4-反射"><a href="#4-反射" class="headerlink" title="4.反射"></a>4.反射</h3><p>定义：JAVA反射机制实在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种<strong>动态获取信息以及动态调用对象方法</strong>的功能称为java语言的反射机制</p>
<p>理解：反射就是将Java类中各个成分，映射成一个个的java对象</p>
<p><strong>写一个反射的例子：</strong></p>
<p>[<img src="https://pic.rmb.bdstatic.com/bjh/90f82fe5362174d85d73cce23c75cd06.png" alt="反射的例子"></p>
<p><strong>常用方法：</strong></p>
<ul>
<li><strong>Class.forName(类的路径)</strong>：创建一个类对象</li>
<li>类对象.<strong>newInstance()</strong>：创建一个类的实例</li>
<li>Method  类实例.<strong>getDeclaredMethod（方法名，接受参数的Class对象）</strong>:能够获取类所有方法，不能获取继承和实现接口的方法</li>
<li>Method  类实例.<strong>getMethod</strong>（<strong>方法名，接受参数的Class对象</strong>）：只能获取public方法，可以获取继承和接口实现的方法</li>
<li><strong>setAccessible</strong>(true)：调用私有方法或者属性时，需要设置访问权限为true</li>
<li>方法对象.<strong>invoke</strong>（类实例，参数）：调用方法对象映射的类的方法</li>
<li>Field  类实例.<strong>getDeclaredField</strong>（参数名）：获取属性实例</li>
<li>Field对象.<strong>set</strong>（类实例，参数）：给Filed对象映射的属性设置值</li>
</ul>
<h3 id="5-ClassLoader"><a href="#5-ClassLoader" class="headerlink" title="5.ClassLoader"></a>5.ClassLoader</h3><h4 id="5-1类从编译到执行的过程"><a href="#5-1类从编译到执行的过程" class="headerlink" title="5.1类从编译到执行的过程"></a><strong>5.1类从编译到执行的过程</strong></h4><ul>
<li>编译器将Robot.java源文件编译为Robot.class字节码文件</li>
<li>ClassLoader将字节码转换为JVM中的Class<Robot>对象</li>
<li>JVM利用CLass<Robot>对象实例化为Robot对象</li>
</ul>
<h4 id="5-2ClassLoader的工作"><a href="#5-2ClassLoader的工作" class="headerlink" title="5.2ClassLoader的工作"></a>5.2ClassLoader的工作</h4><p>CLassLoader的主要工作再Class装载的加载阶段，其主要作用是从系统外部获得Class二进制数据流。它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，<strong>ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作</strong>。</p>
<h4 id="5-3ClassLoader的种类"><a href="#5-3ClassLoader的种类" class="headerlink" title="5.3ClassLoader的种类"></a>5.3ClassLoader的种类</h4><ul>
<li>BootStrapClassLoader：C++编写，加载核心库java.*（java.lib.dir）</li>
<li>ExtClassLoader：Java编写，加载拓展库javax.*（java.ext.dir）</li>
<li>AppClassLoader：Java编写，加载程序所在目录，加载用户类路径(CLASSPATH)下的类库</li>
<li>自定义ClassLoader：Java编写，定制化加载：</li>
</ul>
<p>关键函数：</p>
<p>1.<strong>findClass</strong>（String name）：用于寻找类文件，将类文件从二进制字节码转换为Class对象</p>
<p>2.<strong>defineClass</strong>（byte[]，int off，int len）：传入class文件的二进制字节码，返回类对象</p>
<p>3<strong>.loadClass</strong>（String name）：加载类文件，它会调用我们实现的findClass方法</p>
<p>[<img src="https://pic.rmb.bdstatic.com/bjh/bc6b9abb863af1cbe251946a06db3025.png" alt="自定义ClassLoader">)[<img src="https://pic.rmb.bdstatic.com/bjh/d4742eaee2bf3c931cf6a4e15e1191d2.png" alt="自定义ClassLoader02"></p>
<h4 id="5-4ClassLoader的双亲委派机制"><a href="#5-4ClassLoader的双亲委派机制" class="headerlink" title="5.4ClassLoader的双亲委派机制"></a>5.4ClassLoader的双亲委派机制</h4><p>[<img src="https://pic.rmb.bdstatic.com/bjh/b94a6f99c0feb05951ec6d40bfdf91be.png" alt="类加载器的双亲委派机制"></p>
<ul>
<li>第一遍自底而上（从自定义ClassLoader到BootstrpClassLoader）：检查各个加载器是否已经加载了该类</li>
<li>第二遍自上到底：从各个加载器目录中尝试加载该类</li>
</ul>
<p><strong>为什么要使用双亲委派机制去加载类？</strong></p>
<ul>
<li><strong>避免多份同样字节码的加载</strong>：如果该类之前已经被ClassLoader加载过，在检查时就不会由新的ClassLoader加载两次</li>
</ul>
<h4 id="5-5类的加载方式"><a href="#5-5类的加载方式" class="headerlink" title="5.5类的加载方式"></a>5.5类的加载方式</h4><ul>
<li>隐式加载：new</li>
<li>显式加载：loadClass、forName等（创建实例必须使用newInstance（），并且不支持传入参数，只能使用反射来设置参数的值）</li>
</ul>
<h4 id="5-7类的装载过程："><a href="#5-7类的装载过程：" class="headerlink" title="5.7类的装载过程："></a><strong>5.7类的装载过程：</strong></h4><ul>
<li><strong>加载</strong>：通过ClassLoader加载class文件字节码，生成Class对象</li>
<li><strong>链接</strong>：</li>
</ul>
<ol>
<li>校验：检查加载的class的正确性和安全性</li>
<li>准备：为类变量分配存储空间并设置类变量初始值</li>
<li>解析：JVM将常量池内的符号引用转换为直接引用</li>
</ol>
<ul>
<li><strong>初始化</strong>：执行类变量赋值和静态代码块</li>
</ul>
<h4 id="5-6loadClass和forName的区别"><a href="#5-6loadClass和forName的区别" class="headerlink" title="5.6loadClass和forName的区别"></a>5.6loadClass和forName的区别</h4><ul>
<li>Class.forName得到的class是已经<strong>完成初始化</strong>（第三步）的</li>
<li>ClassLoader.loadClass得到的class是还没链接的（<strong>还未完成第二步</strong>）</li>
</ul>
<p>ClassLoader的使用例子：在<strong>Spring IOC容器</strong>中，资源加载器读取bean的配置文件时，如果要使用<strong>classpath的方式加载</strong>，则需要ClassLoader。这与Spring IOC的lazyLoading（<strong>延迟加载</strong>）有关，Spring IOC<strong>为了加快初始化速度</strong>，大量使用延迟加载</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM02/">上一篇</a><a class="next" href="/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM03/">下一篇</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '2cdbd7aa1fe9fd30e3c5',     
    clientSecret: '0d12d75f0e1788ffc85796b5a38bdddbbf40c77d',     
    id: window.location.pathname,    
    repo: 'blog',     
    owner: 'zenghuqiang',     
    admin: 'zenghuqiang',     
})   
gitalk.render('gitalk-container')
</script><div class="copyright"><p>© 2020 <a href="http://www.kongkongbai.com">kongkongbai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/achjqz/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/github-gist.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/dockerfile.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/x86asm.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>