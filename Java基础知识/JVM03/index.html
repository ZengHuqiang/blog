<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JMM的可见性 · 空空白的博客</title><meta name="description" content="JMM的可见性 - kongkongbai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.kongkongbai.comundefined" title="空空白的博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="空空白的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/categories/" target="_self">CATEGORY</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/zenghuqiang" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/friends/" target="_self">FRIENDS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JMM的可见性</h1><div class="post-info">May 13, 2020<a class="tag-title" href="/tags/Java/">#Java</a></div><div class="post-content"><h3 id="1-JMM简介"><a href="#1-JMM简介" class="headerlink" title="1.JMM简介"></a>1.JMM简介</h3><p>[<img src="https://pic.rmb.bdstatic.com/bjh/88652a11e96b574703cf35d6ccbd54e3.png" alt="JMM内存模型"></p>
<p>Java内存模型JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式</p>
<p><strong>理解：每个线程都有自己的工作内存，相互独立；线程之间的共享资源都是存储在主内存中，线程要想获取共享资源，只能获取其在主内存的副本，修改完后返回至主内存以达到通信的目的。</strong></p>
<h4 id="1-1JMM中的主内存"><a href="#1-1JMM中的主内存" class="headerlink" title="1.1JMM中的主内存"></a>1.1JMM中的主内存</h4><ul>
<li>存储Java<strong>实例对象</strong></li>
<li>包括<strong>成员变量、类信息、常量、静态变量</strong>等</li>
<li>属于<strong>数据共享的区域</strong>，多线程并发操作时会引发线程安全问题</li>
</ul>
<h4 id="1-2JMM中的工作内存"><a href="#1-2JMM中的工作内存" class="headerlink" title="1.2JMM中的工作内存"></a>1.2JMM中的工作内存</h4><ul>
<li>存储当前方法的所有本地变量信息，本地变量对其他线程不可见</li>
<li>字节码行号指示器、Native方法信息</li>
<li>属于线程<strong>私有数据区域</strong>，不存在线程安全问题</li>
</ul>
<h4 id="1-3JMM与Java内存区域的概念区别"><a href="#1-3JMM与Java内存区域的概念区别" class="headerlink" title="1.3JMM与Java内存区域的概念区别"></a>1.3JMM与Java内存区域的概念区别</h4><ul>
<li>内存区域是指 Jvm 运行时将数据分区域存储，<strong>强调对内存空间的划分</strong></li>
<li>内存模型（Java Memory Model，简称 JMM ）是定义了<strong>线程的工作内存和主内存之间的抽象关系</strong>，即 <strong>JMM 定义了 JVM 在计算机内存(RAM)中的工作方式</strong></li>
</ul>
<h4 id="1-4主内存与工作内存的数据存储类型以及操作方式归纳"><a href="#1-4主内存与工作内存的数据存储类型以及操作方式归纳" class="headerlink" title="1.4主内存与工作内存的数据存储类型以及操作方式归纳"></a>1.4主内存与工作内存的数据存储类型以及操作方式归纳</h4><ul>
<li>方法里的<strong>基本数据类型</strong>的本地变量将直接存储在工作内存的栈帧结构中</li>
<li><strong>引用类型</strong>的本地变量：引用存储在工作内存中，实例存储在主内存中</li>
<li><strong>成员变量、static变量、类信息</strong>均会被存储在主内存中</li>
<li>主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存</li>
</ul>
<h3 id="2-JMM如何解决可见性问题"><a href="#2-JMM如何解决可见性问题" class="headerlink" title="2.JMM如何解决可见性问题"></a>2.JMM如何解决可见性问题</h3><h4 id="2-1指令重排序"><a href="#2-1指令重排序" class="headerlink" title="2.1指令重排序"></a>2.1指令重排序</h4><p>JVM为了提高程序运行速度，一般都会对指令重排序</p>
<p><strong>条件：</strong></p>
<ul>
<li>在单线程环境下不能改变程序运行的结果</li>
<li>存在数据依赖关系的不允许重排序</li>
<li>无法通过<strong>happens-before原则</strong>推导出来的，才能进行指令重排序</li>
</ul>
<h4 id="2-2happens-before原则"><a href="#2-2happens-before原则" class="headerlink" title="2.2happens-before原则"></a>2.2happens-before原则</h4><p>A操作的结果需要对B操作可见，则A与B存在happens-before关系</p>
<p>[<img src="https://pic.rmb.bdstatic.com/bjh/fd3bef59c906055fc8146164b88fdc9e.jpeg" alt="happens-before八大原则"></p>
<p><strong>概念：</strong></p>
<ul>
<li>如果两个操作不满足上述任意一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序</li>
<li>如果操作A happens-before 操作B，那么操作A在内存上所做的操作对操作B都是可见的</li>
</ul>
<h4 id="2-3volatile：JVM提供的轻量级同步机制"><a href="#2-3volatile：JVM提供的轻量级同步机制" class="headerlink" title="2.3volatile：JVM提供的轻量级同步机制"></a>2.3volatile：JVM提供的轻量级同步机制</h4><ul>
<li>保证被volatile修饰的共享变量对所有线程总是可见</li>
<li>禁止指令重排序优化</li>
</ul>
<h5 id="2-3-1volatile的可见性理解："><a href="#2-3-1volatile的可见性理解：" class="headerlink" title="2.3.1volatile的可见性理解："></a><strong>2.3.1volatile的可见性理解：</strong></h5><p>[<img src="https://pic.rmb.bdstatic.com/bjh/51163ab7384797c7d1da63721184fbed.jpeg" alt="volatile的可见性01"></p>
<p>value++的操作不具备原子性（<strong>原子操作</strong>：是指<strong>不会被线程调度机制打断</strong>的操作）：如果在读取value值和返回新value值期间另一个线程获取了久的value就会导致线程安全问题</p>
<p>为了避免线程安全问题，需要使用sychronized进行同步限制，此时就没有必要使用volatile修饰</p>
<p>[<img src="https://pic.rmb.bdstatic.com/bjh/fabbf9b6b8675562647a822510ffe010.jpeg" alt="volatile的可见性02"></p>
<p>shutdown的操作具备原子性，使用volatile修饰比较合理</p>
<h5 id="2-3-2volatile变量的机制"><a href="#2-3-2volatile变量的机制" class="headerlink" title="2.3.2volatile变量的机制"></a>2.3.2volatile变量的机制</h5><ul>
<li>当写一个volatile变量时，JMM会把该线程对应的工作内存中共享变量值刷新到主内存中</li>
<li>当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效</li>
</ul>
<h5 id="2-3-3volatile如何进行重排优化？"><a href="#2-3-3volatile如何进行重排优化？" class="headerlink" title="2.3.3volatile如何进行重排优化？"></a>2.3.3volatile如何进行重排优化？</h5><ul>
<li><strong>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排优化</strong></li>
<li>强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本</li>
</ul>
<p><strong>内存屏障</strong>（Memory Barrier）</p>
<ol>
<li>保证特定操作的执行顺序</li>
<li>保证某些变量的内存可见性</li>
</ol>
<h5 id="2-3-4单例的双重检测实现中的问题"><a href="#2-3-4单例的双重检测实现中的问题" class="headerlink" title="2.3.4单例的双重检测实现中的问题"></a>2.3.4单例的双重检测实现中的问题</h5><p>[<img src="https://pic.rmb.bdstatic.com/bjh/cb621d85d6104e69887c99e3a14ea28a.jpeg" alt="单例的双重检测实现01"></p>
<p>instance = new Singleton（）这一步中分为三个阶段，其中1、2阶段有可能会被重排优化而导致线程安全问题</p>
<p>解决：</p>
<p>private <strong>volatile</strong> static Singleton instance：给实例对象添加volatile字段，使之初始化过程不能被重排序</p>
<h5 id="2-3-5volatile与sychronized的区别"><a href="#2-3-5volatile与sychronized的区别" class="headerlink" title="2.3.5volatile与sychronized的区别"></a>2.3.5volatile与sychronized的区别</h5><ul>
<li>volatile本质是告诉JVM当前变量在寄存器（工作内存）中的值时不确定的，需要从主存中读取；sychronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止</li>
<li>volatile仅能使用在变量级别；sychronized则可以使用在变量、方法和类级别</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而sychronized则可以保证变量修改的可变性和原子性</li>
<li>volatile不会造成线程的阻塞；sychronized可能会造成线程的阻塞</li>
<li>volatile标记的变量不会被编译器优化；sychronized标记的变量可以被编译器优化</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM01/">上一篇</a><a class="next" href="/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JavaAnnotation/">下一篇</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '2cdbd7aa1fe9fd30e3c5',     
    clientSecret: '0d12d75f0e1788ffc85796b5a38bdddbbf40c77d',     
    id: window.location.pathname,    
    repo: 'blog',     
    owner: 'zenghuqiang',     
    admin: 'zenghuqiang',     
})   
gitalk.render('gitalk-container')
</script><div class="copyright"><p>© 2020 <a href="http://www.kongkongbai.com">kongkongbai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/achjqz/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/github-gist.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/dockerfile.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/x86asm.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>